<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>~/h/g/appannie/aa/media/lib/ng-v1.2.4/angular.js.html</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="javascript">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="solarized">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #333; background-color: #ffffff; }
body { font-family: monospace; color: #333; background-color: #ffffff;
 font-size: 16px;
}
.Todo { color: #999; font-weight: bold; }
.Comment { color: #999; }
.Constant { color: #222; }
.Special { color: #666; }
.Identifier { color: #222; font-weight: bold; }
.Statement { font-weight: bold; }
.Type { font-style: italic; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment">/**</span>
<span class="Comment"> * @license AngularJS v1.2.4</span>
<span class="Comment"> * (c) 2010-2014 Google, Inc. <a href="http://angularjs.org">http://angularjs.org</a></span>
<span class="Comment"> * License: MIT</span>
<span class="Comment"> */</span>
(<span class="Identifier">function</span>(<span class="Statement">window</span>, <span class="Statement">document</span>, <span class="Statement">undefined</span>) <span class="Identifier">{</span><span class="Constant">'use strict'</span>;

<span class="Comment">/**</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * This object provides a utility for producing rich Error messages within</span>
<span class="Comment"> * Angular. It can be called as follows:</span>
<span class="Comment"> *</span>
<span class="Comment"> * var exampleMinErr = minErr('example');</span>
<span class="Comment"> * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);</span>
<span class="Comment"> *</span>
<span class="Comment"> * The above creates an instance of minErr in the example namespace. The</span>
<span class="Comment"> * resulting error will have a namespaced error code of example.one.  The</span>
<span class="Comment"> * resulting error will replace {0} with the value of foo, and {1} with the</span>
<span class="Comment"> * value of bar. The object is not restricted in the number of arguments it can</span>
<span class="Comment"> * take.</span>
<span class="Comment"> *</span>
<span class="Comment"> * If fewer arguments are specified than necessary for interpolation, the extra</span>
<span class="Comment"> * interpolation markers will be preserved in the final string.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Since data will be parsed statically during a build step, some restrictions</span>
<span class="Comment"> * are applied with respect to how minErr instances are created and called.</span>
<span class="Comment"> * Instances should have names of the form namespaceMinErr for a minErr created</span>
<span class="Comment"> * using minErr('namespace') . Error codes, namespaces and template strings</span>
<span class="Comment"> * should all be static strings, not variables or general expressions.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} module The namespace to use for the new minErr instance.</span>
<span class="Comment"> * @returns {function(string, string, ...): Error} instance</span>
<span class="Comment"> */</span>

<span class="Identifier">function</span> minErr(module) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">function</span> () <span class="Identifier">{</span>
    <span class="Identifier">var</span> code = <span class="Identifier">arguments</span><span class="Identifier">[</span>0<span class="Identifier">]</span>,
      prefix = <span class="Constant">'['</span> + (module ? module + <span class="Constant">':'</span> : <span class="Constant">''</span>) + code + <span class="Constant">'] '</span>,
      template = <span class="Identifier">arguments</span><span class="Identifier">[</span>1<span class="Identifier">]</span>,
      templateArgs = <span class="Identifier">arguments</span>,
      stringify = <span class="Identifier">function</span> (obj) <span class="Identifier">{</span>
        <span class="Statement">if</span> (<span class="Statement">typeof</span> obj === <span class="Constant">'function'</span>) <span class="Identifier">{</span>
          <span class="Statement">return</span> obj.toString().replace(<span class="Constant">/ \{[\s\S]*$/</span>, <span class="Constant">''</span>);
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Statement">typeof</span> obj === <span class="Constant">'undefined'</span>) <span class="Identifier">{</span>
          <span class="Statement">return</span> <span class="Constant">'undefined'</span>;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Statement">typeof</span> obj !== <span class="Constant">'string'</span>) <span class="Identifier">{</span>
          <span class="Statement">return</span> JSON.stringify(obj);
        <span class="Identifier">}</span>
        <span class="Statement">return</span> obj;
      <span class="Identifier">}</span>,
      message, i;

    message = prefix + template.replace(<span class="Constant">/\{\d+\}/g</span>, <span class="Identifier">function</span> (match) <span class="Identifier">{</span>
      <span class="Identifier">var</span> index = +match.slice(1, -1), arg;

      <span class="Statement">if</span> (index + 2 &lt; templateArgs.length) <span class="Identifier">{</span>
        arg = templateArgs<span class="Identifier">[</span>index + 2<span class="Identifier">]</span>;
        <span class="Statement">if</span> (<span class="Statement">typeof</span> arg === <span class="Constant">'function'</span>) <span class="Identifier">{</span>
          <span class="Statement">return</span> arg.toString().replace(<span class="Constant">/ ?\{[\s\S]*$/</span>, <span class="Constant">''</span>);
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Statement">typeof</span> arg === <span class="Constant">'undefined'</span>) <span class="Identifier">{</span>
          <span class="Statement">return</span> <span class="Constant">'undefined'</span>;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Statement">typeof</span> arg !== <span class="Constant">'string'</span>) <span class="Identifier">{</span>
          <span class="Statement">return</span> toJson(arg);
        <span class="Identifier">}</span>
        <span class="Statement">return</span> arg;
      <span class="Identifier">}</span>
      <span class="Statement">return</span> match;
    <span class="Identifier">}</span>);

    message = message + <span class="Constant">'</span><span class="Special">\n</span><span class="Constant"><a href="http://errors.angularjs.org/1.2.4/">http://errors.angularjs.org/1.2.4/</a>'</span> +
      (module ? module + <span class="Constant">'/'</span> : <span class="Constant">''</span>) + code;
    <span class="Statement">for</span> (i = 2; i &lt; <span class="Identifier">arguments</span>.length; i++) <span class="Identifier">{</span>
      message = message + (i == 2 ? <span class="Constant">'?'</span> : <span class="Constant">'&amp;'</span>) + <span class="Constant">'p'</span> + (i-2) + <span class="Constant">'='</span> +
        encodeURIComponent(stringify(<span class="Identifier">arguments</span><span class="Identifier">[</span>i<span class="Identifier">]</span>));
    <span class="Identifier">}</span>

    <span class="Statement">return</span> <span class="Statement">new</span> Error(message);
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Comment">/* We need to tell jshint what variables are being exported */</span>
<span class="Comment">/* global</span>
<span class="Comment">    -angular,</span>
<span class="Comment">    -msie,</span>
<span class="Comment">    -jqLite,</span>
<span class="Comment">    -jQuery,</span>
<span class="Comment">    -slice,</span>
<span class="Comment">    -push,</span>
<span class="Comment">    -toString,</span>
<span class="Comment">    -ngMinErr,</span>
<span class="Comment">    -_angular,</span>
<span class="Comment">    -angularModule,</span>
<span class="Comment">    -nodeName_,</span>
<span class="Comment">    -uid,</span>

<span class="Comment">    -lowercase,</span>
<span class="Comment">    -uppercase,</span>
<span class="Comment">    -manualLowercase,</span>
<span class="Comment">    -manualUppercase,</span>
<span class="Comment">    -nodeName_,</span>
<span class="Comment">    -isArrayLike,</span>
<span class="Comment">    -forEach,</span>
<span class="Comment">    -sortedKeys,</span>
<span class="Comment">    -forEachSorted,</span>
<span class="Comment">    -reverseParams,</span>
<span class="Comment">    -nextUid,</span>
<span class="Comment">    -setHashKey,</span>
<span class="Comment">    -extend,</span>
<span class="Comment">    -int,</span>
<span class="Comment">    -inherit,</span>
<span class="Comment">    -noop,</span>
<span class="Comment">    -identity,</span>
<span class="Comment">    -valueFn,</span>
<span class="Comment">    -isUndefined,</span>
<span class="Comment">    -isDefined,</span>
<span class="Comment">    -isObject,</span>
<span class="Comment">    -isString,</span>
<span class="Comment">    -isNumber,</span>
<span class="Comment">    -isDate,</span>
<span class="Comment">    -isArray,</span>
<span class="Comment">    -isFunction,</span>
<span class="Comment">    -isRegExp,</span>
<span class="Comment">    -isWindow,</span>
<span class="Comment">    -isScope,</span>
<span class="Comment">    -isFile,</span>
<span class="Comment">    -isBoolean,</span>
<span class="Comment">    -trim,</span>
<span class="Comment">    -isElement,</span>
<span class="Comment">    -makeMap,</span>
<span class="Comment">    -map,</span>
<span class="Comment">    -size,</span>
<span class="Comment">    -includes,</span>
<span class="Comment">    -indexOf,</span>
<span class="Comment">    -arrayRemove,</span>
<span class="Comment">    -isLeafNode,</span>
<span class="Comment">    -copy,</span>
<span class="Comment">    -shallowCopy,</span>
<span class="Comment">    -equals,</span>
<span class="Comment">    -csp,</span>
<span class="Comment">    -concat,</span>
<span class="Comment">    -sliceArgs,</span>
<span class="Comment">    -bind,</span>
<span class="Comment">    -toJsonReplacer,</span>
<span class="Comment">    -toJson,</span>
<span class="Comment">    -fromJson,</span>
<span class="Comment">    -toBoolean,</span>
<span class="Comment">    -startingTag,</span>
<span class="Comment">    -tryDecodeURIComponent,</span>
<span class="Comment">    -parseKeyValue,</span>
<span class="Comment">    -toKeyValue,</span>
<span class="Comment">    -encodeUriSegment,</span>
<span class="Comment">    -encodeUriQuery,</span>
<span class="Comment">    -angularInit,</span>
<span class="Comment">    -bootstrap,</span>
<span class="Comment">    -snake_case,</span>
<span class="Comment">    -bindJQuery,</span>
<span class="Comment">    -assertArg,</span>
<span class="Comment">    -assertArgFn,</span>
<span class="Comment">    -assertNotHasOwnProperty,</span>
<span class="Comment">    -getter,</span>
<span class="Comment">    -getBlockElements,</span>

<span class="Comment">*/</span>

<span class="Comment">////////////////////////////////////</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.lowercase</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description Converts the specified string to lowercase.</span>
<span class="Comment"> * @param {string} string String to be converted to lowercase.</span>
<span class="Comment"> * @returns {string} Lowercased string.</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> lowercase = <span class="Identifier">function</span>(string)<span class="Identifier">{</span><span class="Statement">return</span> isString(string) ? string.toLowerCase() : string;<span class="Identifier">}</span>;


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.uppercase</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description Converts the specified string to uppercase.</span>
<span class="Comment"> * @param {string} string String to be converted to uppercase.</span>
<span class="Comment"> * @returns {string} Uppercased string.</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> uppercase = <span class="Identifier">function</span>(string)<span class="Identifier">{</span><span class="Statement">return</span> isString(string) ? string.toUpperCase() : string;<span class="Identifier">}</span>;


<span class="Identifier">var</span> manualLowercase = <span class="Identifier">function</span>(s) <span class="Identifier">{</span>
  <span class="Comment">/* jshint bitwise: false */</span>
  <span class="Statement">return</span> isString(s)
      ? s.replace(<span class="Constant">/[A-Z]/g</span>, <span class="Identifier">function</span>(ch) <span class="Identifier">{</span><span class="Statement">return</span> <span class="Type">String</span>.fromCharCode(ch.charCodeAt(0) | 32);<span class="Identifier">}</span>)
      : s;
<span class="Identifier">}</span>;
<span class="Identifier">var</span> manualUppercase = <span class="Identifier">function</span>(s) <span class="Identifier">{</span>
  <span class="Comment">/* jshint bitwise: false */</span>
  <span class="Statement">return</span> isString(s)
      ? s.replace(<span class="Constant">/[a-z]/g</span>, <span class="Identifier">function</span>(ch) <span class="Identifier">{</span><span class="Statement">return</span> <span class="Type">String</span>.fromCharCode(ch.charCodeAt(0) &amp; ~32);<span class="Identifier">}</span>)
      : s;
<span class="Identifier">}</span>;


<span class="Comment">// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish</span>
<span class="Comment">// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods</span>
<span class="Comment">// with correct but slower alternatives.</span>
<span class="Statement">if</span> (<span class="Constant">'i'</span> !== <span class="Constant">'I'</span>.toLowerCase()) <span class="Identifier">{</span>
  lowercase = manualLowercase;
  uppercase = manualUppercase;
<span class="Identifier">}</span>


<span class="Identifier">var</span> <span class="Comment">/** holds major version number for IE or NaN for real browsers */</span>
    msie,
    jqLite,           <span class="Comment">// delay binding since jQuery could be loaded after us.</span>
    jQuery,           <span class="Comment">// delay binding</span>
    slice             = <span class="Identifier">[]</span>.slice,
    push              = <span class="Identifier">[]</span>.push,
    toString          = <span class="Type">Object</span>.prototype.toString,
    ngMinErr          = minErr(<span class="Constant">'ng'</span>),


    _angular          = <span class="Statement">window</span>.angular,
    <span class="Comment">/** @name angular */</span>
    angular           = <span class="Statement">window</span>.angular || (<span class="Statement">window</span>.angular = <span class="Identifier">{}</span>),
    angularModule,
    nodeName_,
    uid               = <span class="Identifier">[</span><span class="Constant">'0'</span>, <span class="Constant">'0'</span>, <span class="Constant">'0'</span><span class="Identifier">]</span>;

<span class="Comment">/**</span>
<span class="Comment"> * IE 11 changed the format of the UserAgent string.</span>
<span class="Comment"> * See <a href="http://msdn.microsoft.com/en-us/library/ms537503.aspx">http://msdn.microsoft.com/en-us/library/ms537503.aspx</a></span>
<span class="Comment"> */</span>
msie = <span class="Statement">int</span>((<span class="Constant">/msie (\d+)/</span>.exec(lowercase(navigator.userAgent)) || <span class="Identifier">[]</span>)<span class="Identifier">[</span>1<span class="Identifier">]</span>);
<span class="Statement">if</span> (isNaN(msie)) <span class="Identifier">{</span>
  msie = <span class="Statement">int</span>((<span class="Constant">/trident\/.*; rv:(\d+)/</span>.exec(lowercase(navigator.userAgent)) || <span class="Identifier">[]</span>)<span class="Identifier">[</span>1<span class="Identifier">]</span>);
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @private</span>
<span class="Comment"> * @param {*} obj</span>
<span class="Comment"> * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,</span>
<span class="Comment"> *                   String ...)</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> isArrayLike(obj) <span class="Identifier">{</span>
  <span class="Statement">if</span> (obj == <span class="Statement">null</span> || isWindow(obj)) <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Constant">false</span>;
  <span class="Identifier">}</span>

  <span class="Identifier">var</span> length = obj.length;

  <span class="Statement">if</span> (obj.nodeType === 1 &amp;&amp; length) <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Constant">true</span>;
  <span class="Identifier">}</span>

  <span class="Statement">return</span> isString(obj) || isArray(obj) || length === 0 ||
         <span class="Statement">typeof</span> length === <span class="Constant">'number'</span> &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) <span class="Statement">in</span> obj;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.forEach</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Invokes the `iterator` function once for each item in `obj` collection, which can be either an</span>
<span class="Comment"> * object or an array. The `iterator` function is invoked with `iterator(value, key)`, where `value`</span>
<span class="Comment"> * is the value of an object property or an array element and `key` is the object property key or</span>
<span class="Comment"> * array element index. Specifying a `context` for the function is optional.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Note: this function was previously known as `angular.foreach`.</span>
<span class="Comment"> *</span>
<span class="Comment">   &lt;pre&gt;</span>
<span class="Comment">     var values = {name: 'misko', gender: 'male'};</span>
<span class="Comment">     var log = [];</span>
<span class="Comment">     angular.forEach(values, function(value, key){</span>
<span class="Comment">       this.push(key + ': ' + value);</span>
<span class="Comment">     }, log);</span>
<span class="Comment">     expect(log).toEqual(['name: misko', 'gender:male']);</span>
<span class="Comment">   &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {Object|Array} obj Object to iterate over.</span>
<span class="Comment"> * @param {Function} iterator Iterator function.</span>
<span class="Comment"> * @param {Object=} context Object to become context (`this`) for the iterator function.</span>
<span class="Comment"> * @returns {Object|Array} Reference to `obj`.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> forEach(obj, iterator, context) <span class="Identifier">{</span>
  <span class="Identifier">var</span> key;
  <span class="Statement">if</span> (obj) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isFunction(obj))<span class="Identifier">{</span>
      <span class="Statement">for</span> (key <span class="Statement">in</span> obj) <span class="Identifier">{</span>
        <span class="Statement">if</span> (key != <span class="Constant">'prototype'</span> &amp;&amp; key != <span class="Constant">'length'</span> &amp;&amp; key != <span class="Constant">'name'</span> &amp;&amp; obj.hasOwnProperty(key)) <span class="Identifier">{</span>
          iterator.call(context, obj<span class="Identifier">[</span>key<span class="Identifier">]</span>, key);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (obj.forEach &amp;&amp; obj.forEach !== forEach) <span class="Identifier">{</span>
      obj.forEach(iterator, context);
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isArrayLike(obj)) <span class="Identifier">{</span>
      <span class="Statement">for</span> (key = 0; key &lt; obj.length; key++)
        iterator.call(context, obj<span class="Identifier">[</span>key<span class="Identifier">]</span>, key);
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">for</span> (key <span class="Statement">in</span> obj) <span class="Identifier">{</span>
        <span class="Statement">if</span> (obj.hasOwnProperty(key)) <span class="Identifier">{</span>
          iterator.call(context, obj<span class="Identifier">[</span>key<span class="Identifier">]</span>, key);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>
  <span class="Statement">return</span> obj;
<span class="Identifier">}</span>

<span class="Identifier">function</span> sortedKeys(obj) <span class="Identifier">{</span>
  <span class="Identifier">var</span> keys = <span class="Identifier">[]</span>;
  <span class="Statement">for</span> (<span class="Identifier">var</span> key <span class="Statement">in</span> obj) <span class="Identifier">{</span>
    <span class="Statement">if</span> (obj.hasOwnProperty(key)) <span class="Identifier">{</span>
      keys.push(key);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>
  <span class="Statement">return</span> keys.sort();
<span class="Identifier">}</span>

<span class="Identifier">function</span> forEachSorted(obj, iterator, context) <span class="Identifier">{</span>
  <span class="Identifier">var</span> keys = sortedKeys(obj);
  <span class="Statement">for</span> ( <span class="Identifier">var</span> i = 0; i &lt; keys.length; i++) <span class="Identifier">{</span>
    iterator.call(context, obj<span class="Identifier">[</span>keys<span class="Identifier">[</span>i<span class="Identifier">]]</span>, keys<span class="Identifier">[</span>i<span class="Identifier">]</span>);
  <span class="Identifier">}</span>
  <span class="Statement">return</span> keys;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * when using forEach the params are value, key, but it is often useful to have key, value.</span>
<span class="Comment"> * @param {function(string, *)} iteratorFn</span>
<span class="Comment"> * @returns {function(*, string)}</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> reverseParams(iteratorFn) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">function</span>(value, key) <span class="Identifier">{</span> iteratorFn(key, value); <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric</span>
<span class="Comment"> * characters such as '012ABC'. The reason why we are not using simply a number counter is that</span>
<span class="Comment"> * the number string gets longer over time, and it can also overflow, where as the nextId</span>
<span class="Comment"> * will grow much slower, it is a string, and it will never overflow.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @returns an unique alpha-numeric string</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> nextUid() <span class="Identifier">{</span>
  <span class="Identifier">var</span> index = uid.length;
  <span class="Identifier">var</span> digit;

  <span class="Statement">while</span>(index) <span class="Identifier">{</span>
    index--;
    digit = uid<span class="Identifier">[</span>index<span class="Identifier">]</span>.charCodeAt(0);
    <span class="Statement">if</span> (digit == 57 <span class="Comment">/*'9'*/</span>) <span class="Identifier">{</span>
      uid<span class="Identifier">[</span>index<span class="Identifier">]</span> = <span class="Constant">'A'</span>;
      <span class="Statement">return</span> uid.join(<span class="Constant">''</span>);
    <span class="Identifier">}</span>
    <span class="Statement">if</span> (digit == 90  <span class="Comment">/*'Z'*/</span>) <span class="Identifier">{</span>
      uid<span class="Identifier">[</span>index<span class="Identifier">]</span> = <span class="Constant">'0'</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      uid<span class="Identifier">[</span>index<span class="Identifier">]</span> = <span class="Type">String</span>.fromCharCode(digit + 1);
      <span class="Statement">return</span> uid.join(<span class="Constant">''</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>
  uid.unshift(<span class="Constant">'0'</span>);
  <span class="Statement">return</span> uid.join(<span class="Constant">''</span>);
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * Set or clear the hashkey for an object.</span>
<span class="Comment"> * @param obj object</span>
<span class="Comment"> * @param h the hashkey (!truthy to delete the hashkey)</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> setHashKey(obj, h) <span class="Identifier">{</span>
  <span class="Statement">if</span> (h) <span class="Identifier">{</span>
    obj.$$hashKey = h;
  <span class="Identifier">}</span>
  <span class="Statement">else</span> <span class="Identifier">{</span>
    <span class="Statement">delete</span> obj.$$hashKey;
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.extend</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Extends the destination object `dst` by copying all of the properties from the `src` object(s)</span>
<span class="Comment"> * to `dst`. You can specify multiple `src` objects.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {Object} dst Destination object.</span>
<span class="Comment"> * @param {...Object} src Source object(s).</span>
<span class="Comment"> * @returns {Object} Reference to `dst`.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> extend(dst) <span class="Identifier">{</span>
  <span class="Identifier">var</span> h = dst.$$hashKey;
  forEach(<span class="Identifier">arguments</span>, <span class="Identifier">function</span>(obj)<span class="Identifier">{</span>
    <span class="Statement">if</span> (obj !== dst) <span class="Identifier">{</span>
      forEach(obj, <span class="Identifier">function</span>(value, key)<span class="Identifier">{</span>
        dst<span class="Identifier">[</span>key<span class="Identifier">]</span> = value;
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>);

  setHashKey(dst,h);
  <span class="Statement">return</span> dst;
<span class="Identifier">}</span>

<span class="Identifier">function</span> <span class="Statement">int</span>(str) <span class="Identifier">{</span>
  <span class="Statement">return</span> parseInt(str, 10);
<span class="Identifier">}</span>


<span class="Identifier">function</span> inherit(<span class="Statement">parent</span>, extra) <span class="Identifier">{</span>
  <span class="Statement">return</span> extend(<span class="Statement">new</span> (extend(<span class="Identifier">function</span>() <span class="Identifier">{}</span>, <span class="Identifier">{</span>prototype:<span class="Statement">parent</span><span class="Identifier">}</span>))(), extra);
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.noop</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * A function that performs no operations. This function can be useful when writing code in the</span>
<span class="Comment"> * functional style.</span>
<span class="Comment">   &lt;pre&gt;</span>
<span class="Comment">     function foo(callback) {</span>
<span class="Comment">       var result = calculateResult();</span>
<span class="Comment">       (callback || angular.noop)(result);</span>
<span class="Comment">     }</span>
<span class="Comment">   &lt;/pre&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> noop() <span class="Identifier">{}</span>
noop.$inject = <span class="Identifier">[]</span>;


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.identity</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * A function that returns its first argument. This function is useful when writing code in the</span>
<span class="Comment"> * functional style.</span>
<span class="Comment"> *</span>
<span class="Comment">   &lt;pre&gt;</span>
<span class="Comment">     function transformer(transformationFn, value) {</span>
<span class="Comment">       return (transformationFn || angular.identity)(value);</span>
<span class="Comment">     };</span>
<span class="Comment">   &lt;/pre&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> identity($) <span class="Identifier">{</span><span class="Statement">return</span> $;<span class="Identifier">}</span>
identity.$inject = <span class="Identifier">[]</span>;


<span class="Identifier">function</span> valueFn(value) <span class="Identifier">{</span><span class="Statement">return</span> <span class="Identifier">function</span>() <span class="Identifier">{</span><span class="Statement">return</span> value;<span class="Identifier">}</span>;<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.isUndefined</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Determines if a reference is undefined.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {*} value Reference to check.</span>
<span class="Comment"> * @returns {boolean} True if `value` is undefined.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> isUndefined(value)<span class="Identifier">{</span><span class="Statement">return</span> <span class="Statement">typeof</span> value == <span class="Constant">'undefined'</span>;<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.isDefined</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Determines if a reference is defined.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {*} value Reference to check.</span>
<span class="Comment"> * @returns {boolean} True if `value` is defined.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> isDefined(value)<span class="Identifier">{</span><span class="Statement">return</span> <span class="Statement">typeof</span> value != <span class="Constant">'undefined'</span>;<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.isObject</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not</span>
<span class="Comment"> * considered to be objects.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {*} value Reference to check.</span>
<span class="Comment"> * @returns {boolean} True if `value` is an `Object` but not `null`.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> isObject(value)<span class="Identifier">{</span><span class="Statement">return</span> value != <span class="Statement">null</span> &amp;&amp; <span class="Statement">typeof</span> value == <span class="Constant">'object'</span>;<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.isString</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Determines if a reference is a `String`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {*} value Reference to check.</span>
<span class="Comment"> * @returns {boolean} True if `value` is a `String`.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> isString(value)<span class="Identifier">{</span><span class="Statement">return</span> <span class="Statement">typeof</span> value == <span class="Constant">'string'</span>;<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.isNumber</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Determines if a reference is a `Number`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {*} value Reference to check.</span>
<span class="Comment"> * @returns {boolean} True if `value` is a `Number`.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> isNumber(value)<span class="Identifier">{</span><span class="Statement">return</span> <span class="Statement">typeof</span> value == <span class="Constant">'number'</span>;<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.isDate</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Determines if a value is a date.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {*} value Reference to check.</span>
<span class="Comment"> * @returns {boolean} True if `value` is a `Date`.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> isDate(value)<span class="Identifier">{</span>
  <span class="Statement">return</span> toString.apply(value) == <span class="Constant">'[object Date]'</span>;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.isArray</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Determines if a reference is an `Array`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {*} value Reference to check.</span>
<span class="Comment"> * @returns {boolean} True if `value` is an `Array`.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> isArray(value) <span class="Identifier">{</span>
  <span class="Statement">return</span> toString.apply(value) == <span class="Constant">'[object Array]'</span>;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.isFunction</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Determines if a reference is a `Function`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {*} value Reference to check.</span>
<span class="Comment"> * @returns {boolean} True if `value` is a `Function`.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> isFunction(value)<span class="Identifier">{</span><span class="Statement">return</span> <span class="Statement">typeof</span> value == <span class="Constant">'function'</span>;<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * Determines if a value is a regular expression object.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @private</span>
<span class="Comment"> * @param {*} value Reference to check.</span>
<span class="Comment"> * @returns {boolean} True if `value` is a `RegExp`.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> isRegExp(value) <span class="Identifier">{</span>
  <span class="Statement">return</span> toString.apply(value) == <span class="Constant">'[object RegExp]'</span>;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * Checks if `obj` is a window object.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @private</span>
<span class="Comment"> * @param {*} obj Object to check</span>
<span class="Comment"> * @returns {boolean} True if `obj` is a window obj.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> isWindow(obj) <span class="Identifier">{</span>
  <span class="Statement">return</span> obj &amp;&amp; obj.<span class="Statement">document</span> &amp;&amp; obj.<span class="Statement">location</span> &amp;&amp; obj.<span class="Statement">alert</span> &amp;&amp; obj.setInterval;
<span class="Identifier">}</span>


<span class="Identifier">function</span> isScope(obj) <span class="Identifier">{</span>
  <span class="Statement">return</span> obj &amp;&amp; obj.$evalAsync &amp;&amp; obj.$watch;
<span class="Identifier">}</span>


<span class="Identifier">function</span> isFile(obj) <span class="Identifier">{</span>
  <span class="Statement">return</span> toString.apply(obj) === <span class="Constant">'[object File]'</span>;
<span class="Identifier">}</span>


<span class="Identifier">function</span> isBoolean(value) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Statement">typeof</span> value == <span class="Constant">'boolean'</span>;
<span class="Identifier">}</span>


<span class="Identifier">var</span> trim = (<span class="Identifier">function</span>() <span class="Identifier">{</span>
  <span class="Comment">// native trim is way faster: <a href="http://jsperf.com/angular-trim-test">http://jsperf.com/angular-trim-test</a></span>
  <span class="Comment">// but IE doesn't have it... :-(</span>
  <span class="Comment">// </span><span class="Todo">TODO</span><span class="Comment">: we should move this into IE/ES5 polyfill</span>
  <span class="Statement">if</span> (!<span class="Type">String</span>.prototype.trim) <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
      <span class="Statement">return</span> isString(value) ? value.replace(<span class="Constant">/^\s\s*/</span>, <span class="Constant">''</span>).replace(<span class="Constant">/\s\s*$/</span>, <span class="Constant">''</span>) : value;
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>
  <span class="Statement">return</span> <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Statement">return</span> isString(value) ? value.trim() : value;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>)();


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.isElement</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Determines if a reference is a DOM element (or wrapped jQuery element).</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {*} value Reference to check.</span>
<span class="Comment"> * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> isElement(node) <span class="Identifier">{</span>
  <span class="Statement">return</span> !!(node &amp;&amp;
    (node.nodeName  <span class="Comment">// we are a direct element</span>
    || (node.on &amp;&amp; node.find)));  <span class="Comment">// we have an on and find method part of jQuery API</span>
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @param str 'key1,key2,...'</span>
<span class="Comment"> * @returns {object} in the form of {key1:true, key2:true, ...}</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> makeMap(str)<span class="Identifier">{</span>
  <span class="Identifier">var</span> obj = <span class="Identifier">{}</span>, items = str.split(<span class="Constant">&quot;,&quot;</span>), i;
  <span class="Statement">for</span> ( i = 0; i &lt; items.length; i++ )
    obj<span class="Identifier">[</span> items<span class="Identifier">[</span>i<span class="Identifier">]</span> <span class="Identifier">]</span> = <span class="Constant">true</span>;
  <span class="Statement">return</span> obj;
<span class="Identifier">}</span>


<span class="Statement">if</span> (msie &lt; 9) <span class="Identifier">{</span>
  nodeName_ = <span class="Identifier">function</span>(element) <span class="Identifier">{</span>
    element = element.nodeName ? element : element<span class="Identifier">[</span>0<span class="Identifier">]</span>;
    <span class="Statement">return</span> (element.scopeName &amp;&amp; element.scopeName != <span class="Constant">'HTML'</span>)
      ? uppercase(element.scopeName + <span class="Constant">':'</span> + element.nodeName) : element.nodeName;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
  nodeName_ = <span class="Identifier">function</span>(element) <span class="Identifier">{</span>
    <span class="Statement">return</span> element.nodeName ? element.nodeName : element<span class="Identifier">[</span>0<span class="Identifier">]</span>.nodeName;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>


<span class="Identifier">function</span> map(obj, iterator, context) <span class="Identifier">{</span>
  <span class="Identifier">var</span> results = <span class="Identifier">[]</span>;
  forEach(obj, <span class="Identifier">function</span>(value, index, list) <span class="Identifier">{</span>
    results.push(iterator.call(context, value, index, list));
  <span class="Identifier">}</span>);
  <span class="Statement">return</span> results;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Determines the number of elements in an array, the number of properties an object has, or</span>
<span class="Comment"> * the length of a string.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Note: This function is used to augment the Object type in Angular expressions. See</span>
<span class="Comment"> * {@link angular.Object} for more information about Angular arrays.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {Object|Array|string} obj Object, array, or string to inspect.</span>
<span class="Comment"> * @param {boolean} [ownPropsOnly=false] Count only &quot;own&quot; properties in an object</span>
<span class="Comment"> * @returns {number} The size of `obj` or `0` if `obj` is neither an object nor an array.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> size(obj, ownPropsOnly) <span class="Identifier">{</span>
  <span class="Identifier">var</span> count = 0, key;

  <span class="Statement">if</span> (isArray(obj) || isString(obj)) <span class="Identifier">{</span>
    <span class="Statement">return</span> obj.length;
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isObject(obj))<span class="Identifier">{</span>
    <span class="Statement">for</span> (key <span class="Statement">in</span> obj)
      <span class="Statement">if</span> (!ownPropsOnly || obj.hasOwnProperty(key))
        count++;
  <span class="Identifier">}</span>

  <span class="Statement">return</span> count;
<span class="Identifier">}</span>


<span class="Identifier">function</span> includes(array, obj) <span class="Identifier">{</span>
  <span class="Statement">return</span> indexOf(array, obj) != -1;
<span class="Identifier">}</span>

<span class="Identifier">function</span> indexOf(array, obj) <span class="Identifier">{</span>
  <span class="Statement">if</span> (array.indexOf) <span class="Statement">return</span> array.indexOf(obj);

  <span class="Statement">for</span> ( <span class="Identifier">var</span> i = 0; i &lt; array.length; i++) <span class="Identifier">{</span>
    <span class="Statement">if</span> (obj === array<span class="Identifier">[</span>i<span class="Identifier">]</span>) <span class="Statement">return</span> i;
  <span class="Identifier">}</span>
  <span class="Statement">return</span> -1;
<span class="Identifier">}</span>

<span class="Identifier">function</span> arrayRemove(array, value) <span class="Identifier">{</span>
  <span class="Identifier">var</span> index = indexOf(array, value);
  <span class="Statement">if</span> (index &gt;=0)
    array.splice(index, 1);
  <span class="Statement">return</span> value;
<span class="Identifier">}</span>

<span class="Identifier">function</span> isLeafNode (node) <span class="Identifier">{</span>
  <span class="Statement">if</span> (node) <span class="Identifier">{</span>
    <span class="Statement">switch</span> (node.nodeName) <span class="Identifier">{</span>
    <span class="Statement">case</span> <span class="Constant">&quot;OPTION&quot;</span>:
    <span class="Statement">case</span> <span class="Constant">&quot;PRE&quot;</span>:
    <span class="Statement">case</span> <span class="Constant">&quot;TITLE&quot;</span>:
      <span class="Statement">return</span> <span class="Constant">true</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>
  <span class="Statement">return</span> <span class="Constant">false</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.copy</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Creates a deep copy of `source`, which should be an object or an array.</span>
<span class="Comment"> *</span>
<span class="Comment"> * * If no destination is supplied, a copy of the object or array is created.</span>
<span class="Comment"> * * If a destination is provided, all of its elements (for array) or properties (for objects)</span>
<span class="Comment"> *   are deleted and then all elements/properties from the source are copied to it.</span>
<span class="Comment"> * * If `source` is not an object or array (inc. `null` and `undefined`), `source` is returned.</span>
<span class="Comment"> * * If `source` is identical to 'destination' an exception will be thrown.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {*} source The source that will be used to make a copy.</span>
<span class="Comment"> *                   Can be any type, including primitives, `null`, and `undefined`.</span>
<span class="Comment"> * @param {(Object|Array)=} destination Destination into which the source is copied. If</span>
<span class="Comment"> *     provided, must be of the same type as `source`.</span>
<span class="Comment"> * @returns {*} The copy or updated `destination`, if `destination` was specified.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> &lt;doc:example&gt;</span>
<span class="Comment"> &lt;doc:source&gt;</span>
<span class="Comment"> &lt;div ng-controller=&quot;Controller&quot;&gt;</span>
<span class="Comment"> &lt;form novalidate class=&quot;simple-form&quot;&gt;</span>
<span class="Comment"> Name: &lt;input type=&quot;text&quot; ng-model=&quot;user.name&quot; /&gt;&lt;br /&gt;</span>
<span class="Comment"> E-mail: &lt;input type=&quot;email&quot; ng-model=&quot;user.email&quot; /&gt;&lt;br /&gt;</span>
<span class="Comment"> Gender: &lt;input type=&quot;radio&quot; ng-model=&quot;user.gender&quot; value=&quot;male&quot; /&gt;male</span>
<span class="Comment"> &lt;input type=&quot;radio&quot; ng-model=&quot;user.gender&quot; value=&quot;female&quot; /&gt;female&lt;br /&gt;</span>
<span class="Comment"> &lt;button ng-click=&quot;reset()&quot;&gt;RESET&lt;/button&gt;</span>
<span class="Comment"> &lt;button ng-click=&quot;update(user)&quot;&gt;SAVE&lt;/button&gt;</span>
<span class="Comment"> &lt;/form&gt;</span>
<span class="Comment"> &lt;pre&gt;form = {{user | json}}&lt;/pre&gt;</span>
<span class="Comment"> &lt;pre&gt;master = {{master | json}}&lt;/pre&gt;</span>
<span class="Comment"> &lt;/div&gt;</span>

<span class="Comment"> &lt;script&gt;</span>
<span class="Comment"> function Controller($scope) {</span>
<span class="Comment">    $scope.master= {};</span>

<span class="Comment">    $scope.update = function(user) {</span>
<span class="Comment">      // Example with 1 argument</span>
<span class="Comment">      $scope.master= angular.copy(user);</span>
<span class="Comment">    };</span>

<span class="Comment">    $scope.reset = function() {</span>
<span class="Comment">      // Example with 2 arguments</span>
<span class="Comment">      angular.copy($scope.master, $scope.user);</span>
<span class="Comment">    };</span>

<span class="Comment">    $scope.reset();</span>
<span class="Comment">  }</span>
<span class="Comment"> &lt;/script&gt;</span>
<span class="Comment"> &lt;/doc:source&gt;</span>
<span class="Comment"> &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> copy(source, destination)<span class="Identifier">{</span>
  <span class="Statement">if</span> (isWindow(source) || isScope(source)) <span class="Identifier">{</span>
    <span class="Statement">throw</span> ngMinErr(<span class="Constant">'cpws'</span>,
      <span class="Constant">&quot;Can't copy! Making copies of Window or Scope instances is not supported.&quot;</span>);
  <span class="Identifier">}</span>

  <span class="Statement">if</span> (!destination) <span class="Identifier">{</span>
    destination = source;
    <span class="Statement">if</span> (source) <span class="Identifier">{</span>
      <span class="Statement">if</span> (isArray(source)) <span class="Identifier">{</span>
        destination = copy(source, <span class="Identifier">[]</span>);
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isDate(source)) <span class="Identifier">{</span>
        destination = <span class="Statement">new</span> <span class="Type">Date</span>(source.getTime());
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isRegExp(source)) <span class="Identifier">{</span>
        destination = <span class="Statement">new</span> <span class="Type">RegExp</span>(source.source);
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isObject(source)) <span class="Identifier">{</span>
        destination = copy(source, <span class="Identifier">{}</span>);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
    <span class="Statement">if</span> (source === destination) <span class="Statement">throw</span> ngMinErr(<span class="Constant">'cpi'</span>,
      <span class="Constant">&quot;Can't copy! Source and destination are identical.&quot;</span>);
    <span class="Statement">if</span> (isArray(source)) <span class="Identifier">{</span>
      destination.length = 0;
      <span class="Statement">for</span> ( <span class="Identifier">var</span> i = 0; i &lt; source.length; i++) <span class="Identifier">{</span>
        destination.push(copy(source<span class="Identifier">[</span>i<span class="Identifier">]</span>));
      <span class="Identifier">}</span>
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Identifier">var</span> h = destination.$$hashKey;
      forEach(destination, <span class="Identifier">function</span>(value, key)<span class="Identifier">{</span>
        <span class="Statement">delete</span> destination<span class="Identifier">[</span>key<span class="Identifier">]</span>;
      <span class="Identifier">}</span>);
      <span class="Statement">for</span> ( <span class="Identifier">var</span> key <span class="Statement">in</span> source) <span class="Identifier">{</span>
        destination<span class="Identifier">[</span>key<span class="Identifier">]</span> = copy(source<span class="Identifier">[</span>key<span class="Identifier">]</span>);
      <span class="Identifier">}</span>
      setHashKey(destination,h);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>
  <span class="Statement">return</span> destination;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * Create a shallow copy of an object</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> shallowCopy(src, dst) <span class="Identifier">{</span>
  dst = dst || <span class="Identifier">{}</span>;

  <span class="Statement">for</span>(<span class="Identifier">var</span> key <span class="Statement">in</span> src) <span class="Identifier">{</span>
    <span class="Comment">// shallowCopy is only ever called by $compile nodeLinkFn, which has control over src</span>
    <span class="Comment">// so we don't need to worry about using our custom hasOwnProperty here</span>
    <span class="Statement">if</span> (src.hasOwnProperty(key) &amp;&amp; key.substr(0, 2) !== <span class="Constant">'$$'</span>) <span class="Identifier">{</span>
      dst<span class="Identifier">[</span>key<span class="Identifier">]</span> = src<span class="Identifier">[</span>key<span class="Identifier">]</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>

  <span class="Statement">return</span> dst;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.equals</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Determines if two objects or two values are equivalent. Supports value types, regular</span>
<span class="Comment"> * expressions, arrays and objects.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Two objects or values are considered equivalent if at least one of the following is true:</span>
<span class="Comment"> *</span>
<span class="Comment"> * * Both objects or values pass `===` comparison.</span>
<span class="Comment"> * * Both objects or values are of the same type and all of their properties are equal by</span>
<span class="Comment"> *   comparing them with `angular.equals`.</span>
<span class="Comment"> * * Both values are NaN. (In JavaScript, NaN == NaN =&gt; false. But we consider two NaN as equal)</span>
<span class="Comment"> * * Both values represent the same regular expression (In JavasScript,</span>
<span class="Comment"> *   /abc/ == /abc/ =&gt; false. But we consider two regular expressions as equal when their textual</span>
<span class="Comment"> *   representation matches).</span>
<span class="Comment"> *</span>
<span class="Comment"> * During a property comparison, properties of `function` type and properties with names</span>
<span class="Comment"> * that begin with `$` are ignored.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Scope and DOMWindow objects are being compared only by identify (`===`).</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {*} o1 Object or value to compare.</span>
<span class="Comment"> * @param {*} o2 Object or value to compare.</span>
<span class="Comment"> * @returns {boolean} True if arguments are equal.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> equals(o1, o2) <span class="Identifier">{</span>
  <span class="Statement">if</span> (o1 === o2) <span class="Statement">return</span> <span class="Constant">true</span>;
  <span class="Statement">if</span> (o1 === <span class="Statement">null</span> || o2 === <span class="Statement">null</span>) <span class="Statement">return</span> <span class="Constant">false</span>;
  <span class="Statement">if</span> (o1 !== o1 &amp;&amp; o2 !== o2) <span class="Statement">return</span> <span class="Constant">true</span>; <span class="Comment">// NaN === NaN</span>
  <span class="Identifier">var</span> t1 = <span class="Statement">typeof</span> o1, t2 = <span class="Statement">typeof</span> o2, length, key, keySet;
  <span class="Statement">if</span> (t1 == t2) <span class="Identifier">{</span>
    <span class="Statement">if</span> (t1 == <span class="Constant">'object'</span>) <span class="Identifier">{</span>
      <span class="Statement">if</span> (isArray(o1)) <span class="Identifier">{</span>
        <span class="Statement">if</span> (!isArray(o2)) <span class="Statement">return</span> <span class="Constant">false</span>;
        <span class="Statement">if</span> ((length = o1.length) == o2.length) <span class="Identifier">{</span>
          <span class="Statement">for</span>(key=0; key&lt;length; key++) <span class="Identifier">{</span>
            <span class="Statement">if</span> (!equals(o1<span class="Identifier">[</span>key<span class="Identifier">]</span>, o2<span class="Identifier">[</span>key<span class="Identifier">]</span>)) <span class="Statement">return</span> <span class="Constant">false</span>;
          <span class="Identifier">}</span>
          <span class="Statement">return</span> <span class="Constant">true</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isDate(o1)) <span class="Identifier">{</span>
        <span class="Statement">return</span> isDate(o2) &amp;&amp; o1.getTime() == o2.getTime();
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isRegExp(o1) &amp;&amp; isRegExp(o2)) <span class="Identifier">{</span>
        <span class="Statement">return</span> o1.toString() == o2.toString();
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">if</span> (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) <span class="Statement">return</span> <span class="Constant">false</span>;
        keySet = <span class="Identifier">{}</span>;
        <span class="Statement">for</span>(key <span class="Statement">in</span> o1) <span class="Identifier">{</span>
          <span class="Statement">if</span> (key.charAt(0) === <span class="Constant">'$'</span> || isFunction(o1<span class="Identifier">[</span>key<span class="Identifier">]</span>)) <span class="Statement">continue</span>;
          <span class="Statement">if</span> (!equals(o1<span class="Identifier">[</span>key<span class="Identifier">]</span>, o2<span class="Identifier">[</span>key<span class="Identifier">]</span>)) <span class="Statement">return</span> <span class="Constant">false</span>;
          keySet<span class="Identifier">[</span>key<span class="Identifier">]</span> = <span class="Constant">true</span>;
        <span class="Identifier">}</span>
        <span class="Statement">for</span>(key <span class="Statement">in</span> o2) <span class="Identifier">{</span>
          <span class="Statement">if</span> (!keySet.hasOwnProperty(key) &amp;&amp;
              key.charAt(0) !== <span class="Constant">'$'</span> &amp;&amp;
              o2<span class="Identifier">[</span>key<span class="Identifier">]</span> !== <span class="Statement">undefined</span> &amp;&amp;
              !isFunction(o2<span class="Identifier">[</span>key<span class="Identifier">]</span>)) <span class="Statement">return</span> <span class="Constant">false</span>;
        <span class="Identifier">}</span>
        <span class="Statement">return</span> <span class="Constant">true</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>
  <span class="Statement">return</span> <span class="Constant">false</span>;
<span class="Identifier">}</span>


<span class="Identifier">function</span> csp() <span class="Identifier">{</span>
  <span class="Statement">return</span> (<span class="Statement">document</span>.securityPolicy &amp;&amp; <span class="Statement">document</span>.securityPolicy.isActive) ||
      (<span class="Statement">document</span>.querySelector &amp;&amp;
      !!(<span class="Statement">document</span>.querySelector(<span class="Constant">'[ng-csp]'</span>) || <span class="Statement">document</span>.querySelector(<span class="Constant">'[data-ng-csp]'</span>)));
<span class="Identifier">}</span>


<span class="Identifier">function</span> concat(array1, array2, index) <span class="Identifier">{</span>
  <span class="Statement">return</span> array1.concat(slice.call(array2, index));
<span class="Identifier">}</span>

<span class="Identifier">function</span> sliceArgs(args, startIndex) <span class="Identifier">{</span>
  <span class="Statement">return</span> slice.call(args, startIndex || 0);
<span class="Identifier">}</span>


<span class="Comment">/* jshint -W101 */</span>
<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.bind</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for</span>
<span class="Comment"> * `fn`). You can supply optional `args` that are prebound to the function. This feature is also</span>
<span class="Comment"> * known as [partial application](<a href="http://en.wikipedia.org/wiki/Partial_application)">http://en.wikipedia.org/wiki/Partial_application)</a>, as</span>
<span class="Comment"> * distinguished from [function currying](<a href="http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).">http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).</a></span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {Object} self Context which `fn` should be evaluated in.</span>
<span class="Comment"> * @param {function()} fn Function to be bound.</span>
<span class="Comment"> * @param {...*} args Optional arguments to be prebound to the `fn` function call.</span>
<span class="Comment"> * @returns {function()} Function that wraps the `fn` with all the specified bindings.</span>
<span class="Comment"> */</span>
<span class="Comment">/* jshint +W101 */</span>
<span class="Identifier">function</span> bind(<span class="Statement">self</span>, fn) <span class="Identifier">{</span>
  <span class="Identifier">var</span> curryArgs = <span class="Identifier">arguments</span>.length &gt; 2 ? sliceArgs(<span class="Identifier">arguments</span>, 2) : <span class="Identifier">[]</span>;
  <span class="Statement">if</span> (isFunction(fn) &amp;&amp; !(fn <span class="Statement">instanceof</span> <span class="Type">RegExp</span>)) <span class="Identifier">{</span>
    <span class="Statement">return</span> curryArgs.length
      ? <span class="Identifier">function</span>() <span class="Identifier">{</span>
          <span class="Statement">return</span> <span class="Identifier">arguments</span>.length
            ? fn.apply(<span class="Statement">self</span>, curryArgs.concat(slice.call(<span class="Identifier">arguments</span>, 0)))
            : fn.apply(<span class="Statement">self</span>, curryArgs);
        <span class="Identifier">}</span>
      : <span class="Identifier">function</span>() <span class="Identifier">{</span>
          <span class="Statement">return</span> <span class="Identifier">arguments</span>.length
            ? fn.apply(<span class="Statement">self</span>, <span class="Identifier">arguments</span>)
            : fn.call(<span class="Statement">self</span>);
        <span class="Identifier">}</span>;
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
    <span class="Comment">// in IE, native methods are not functions so they cannot be bound (note: they don't need to be)</span>
    <span class="Statement">return</span> fn;
  <span class="Identifier">}</span>
<span class="Identifier">}</span>


<span class="Identifier">function</span> toJsonReplacer(key, value) <span class="Identifier">{</span>
  <span class="Identifier">var</span> val = value;

  <span class="Statement">if</span> (<span class="Statement">typeof</span> key === <span class="Constant">'string'</span> &amp;&amp; key.charAt(0) === <span class="Constant">'$'</span>) <span class="Identifier">{</span>
    val = <span class="Statement">undefined</span>;
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isWindow(value)) <span class="Identifier">{</span>
    val = <span class="Constant">'$WINDOW'</span>;
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (value &amp;&amp;  <span class="Statement">document</span> === value) <span class="Identifier">{</span>
    val = <span class="Constant">'$DOCUMENT'</span>;
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isScope(value)) <span class="Identifier">{</span>
    val = <span class="Constant">'$SCOPE'</span>;
  <span class="Identifier">}</span>

  <span class="Statement">return</span> val;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.toJson</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Serializes input into a JSON-formatted string. Properties with leading $ characters will be</span>
<span class="Comment"> * stripped since angular uses this notation internally.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.</span>
<span class="Comment"> * @param {boolean=} pretty If set to true, the JSON output will contain newlines and whitespace.</span>
<span class="Comment"> * @returns {string|undefined} JSON-ified string representing `obj`.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> toJson(obj, pretty) <span class="Identifier">{</span>
  <span class="Statement">if</span> (<span class="Statement">typeof</span> obj === <span class="Constant">'undefined'</span>) <span class="Statement">return</span> <span class="Statement">undefined</span>;
  <span class="Statement">return</span> JSON.stringify(obj, toJsonReplacer, pretty ? <span class="Constant">'  '</span> : <span class="Statement">null</span>);
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.fromJson</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Deserializes a JSON string.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} json JSON string to deserialize.</span>
<span class="Comment"> * @returns {Object|Array|Date|string|number} Deserialized thingy.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> fromJson(json) <span class="Identifier">{</span>
  <span class="Statement">return</span> isString(json)
      ? JSON.parse(json)
      : json;
<span class="Identifier">}</span>


<span class="Identifier">function</span> toBoolean(value) <span class="Identifier">{</span>
  <span class="Statement">if</span> (value &amp;&amp; value.length !== 0) <span class="Identifier">{</span>
    <span class="Identifier">var</span> v = lowercase(<span class="Constant">&quot;&quot;</span> + value);
    value = !(v == <span class="Constant">'f'</span> || v == <span class="Constant">'0'</span> || v == <span class="Constant">'false'</span> || v == <span class="Constant">'no'</span> || v == <span class="Constant">'n'</span> || v == <span class="Constant">'[]'</span>);
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
    value = <span class="Constant">false</span>;
  <span class="Identifier">}</span>
  <span class="Statement">return</span> value;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @returns {string} Returns the string representation of the element.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> startingTag(element) <span class="Identifier">{</span>
  element = jqLite(element).clone();
  <span class="Statement">try</span> <span class="Identifier">{</span>
    <span class="Comment">// turns out IE does not let you set .html() on elements which</span>
    <span class="Comment">// are not allowed to have children. So we just ignore it.</span>
    element.html(<span class="Constant">''</span>);
  <span class="Identifier">}</span> <span class="Statement">catch</span>(e) <span class="Identifier">{}</span>
  <span class="Comment">// As Per DOM Standards</span>
  <span class="Identifier">var</span> TEXT_NODE = 3;
  <span class="Identifier">var</span> elemHtml = jqLite(<span class="Constant">'&lt;div&gt;'</span>).append(element).html();
  <span class="Statement">try</span> <span class="Identifier">{</span>
    <span class="Statement">return</span> element<span class="Identifier">[</span>0<span class="Identifier">]</span>.nodeType === TEXT_NODE ? lowercase(elemHtml) :
        elemHtml.
          match(<span class="Constant">/^(&lt;[^&gt;]+&gt;)/</span>)<span class="Identifier">[</span>1<span class="Identifier">]</span>.
          replace(<span class="Constant">/^&lt;([\w\-]+)/</span>, <span class="Identifier">function</span>(match, nodeName) <span class="Identifier">{</span> <span class="Statement">return</span> <span class="Constant">'&lt;'</span> + lowercase(nodeName); <span class="Identifier">}</span>);
  <span class="Identifier">}</span> <span class="Statement">catch</span>(e) <span class="Identifier">{</span>
    <span class="Statement">return</span> lowercase(elemHtml);
  <span class="Identifier">}</span>

<span class="Identifier">}</span>


<span class="Comment">/////////////////////////////////////////////////</span>

<span class="Comment">/**</span>
<span class="Comment"> * Tries to decode the URI component without throwing an exception.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @private</span>
<span class="Comment"> * @param str value potential URI component to check.</span>
<span class="Comment"> * @returns {boolean} True if `value` can be decoded</span>
<span class="Comment"> * with the decodeURIComponent function.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> tryDecodeURIComponent(value) <span class="Identifier">{</span>
  <span class="Statement">try</span> <span class="Identifier">{</span>
    <span class="Statement">return</span> decodeURIComponent(value);
  <span class="Identifier">}</span> <span class="Statement">catch</span>(e) <span class="Identifier">{</span>
    <span class="Comment">// Ignore any invalid uri component</span>
  <span class="Identifier">}</span>
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * Parses an escaped url query string into key-value pairs.</span>
<span class="Comment"> * @returns Object.&lt;(string|boolean)&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> parseKeyValue(<span class="Comment">/**string*/</span>keyValue) <span class="Identifier">{</span>
  <span class="Identifier">var</span> obj = <span class="Identifier">{}</span>, key_value, key;
  forEach((keyValue || <span class="Constant">&quot;&quot;</span>).split(<span class="Constant">'&amp;'</span>), <span class="Identifier">function</span>(keyValue)<span class="Identifier">{</span>
    <span class="Statement">if</span> ( keyValue ) <span class="Identifier">{</span>
      key_value = keyValue.split(<span class="Constant">'='</span>);
      key = tryDecodeURIComponent(key_value<span class="Identifier">[</span>0<span class="Identifier">]</span>);
      <span class="Statement">if</span> ( isDefined(key) ) <span class="Identifier">{</span>
        <span class="Identifier">var</span> val = isDefined(key_value<span class="Identifier">[</span>1<span class="Identifier">]</span>) ? tryDecodeURIComponent(key_value<span class="Identifier">[</span>1<span class="Identifier">]</span>) : <span class="Constant">true</span>;
        <span class="Statement">if</span> (!obj<span class="Identifier">[</span>key<span class="Identifier">]</span>) <span class="Identifier">{</span>
          obj<span class="Identifier">[</span>key<span class="Identifier">]</span> = val;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span>(isArray(obj<span class="Identifier">[</span>key<span class="Identifier">]</span>)) <span class="Identifier">{</span>
          obj<span class="Identifier">[</span>key<span class="Identifier">]</span>.push(val);
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          obj<span class="Identifier">[</span>key<span class="Identifier">]</span> = <span class="Identifier">[</span>obj<span class="Identifier">[</span>key<span class="Identifier">]</span>,val<span class="Identifier">]</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>);
  <span class="Statement">return</span> obj;
<span class="Identifier">}</span>

<span class="Identifier">function</span> toKeyValue(obj) <span class="Identifier">{</span>
  <span class="Identifier">var</span> parts = <span class="Identifier">[]</span>;
  forEach(obj, <span class="Identifier">function</span>(value, key) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isArray(value)) <span class="Identifier">{</span>
      forEach(value, <span class="Identifier">function</span>(arrayValue) <span class="Identifier">{</span>
        parts.push(encodeUriQuery(key, <span class="Constant">true</span>) +
                   (arrayValue === <span class="Constant">true</span> ? <span class="Constant">''</span> : <span class="Constant">'='</span> + encodeUriQuery(arrayValue, <span class="Constant">true</span>)));
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
    parts.push(encodeUriQuery(key, <span class="Constant">true</span>) +
               (value === <span class="Constant">true</span> ? <span class="Constant">''</span> : <span class="Constant">'='</span> + encodeUriQuery(value, <span class="Constant">true</span>)));
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>);
  <span class="Statement">return</span> parts.length ? parts.join(<span class="Constant">'&amp;'</span>) : <span class="Constant">''</span>;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * We need our custom method because encodeURIComponent is too aggressive and doesn't follow</span>
<span class="Comment"> * <a href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a> with regards to the character set (pchar) allowed in path</span>
<span class="Comment"> * segments:</span>
<span class="Comment"> *    segment       = *pchar</span>
<span class="Comment"> *    pchar         = unreserved / pct-encoded / sub-delims / &quot;:&quot; / &quot;@&quot;</span>
<span class="Comment"> *    pct-encoded   = &quot;%&quot; HEXDIG HEXDIG</span>
<span class="Comment"> *    unreserved    = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;</span>
<span class="Comment"> *    sub-delims    = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;'&quot; / &quot;(&quot; / &quot;)&quot;</span>
<span class="Comment"> *                     / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> encodeUriSegment(val) <span class="Identifier">{</span>
  <span class="Statement">return</span> encodeUriQuery(val, <span class="Constant">true</span>).
             replace(<span class="Constant">/%26/gi</span>, <span class="Constant">'&amp;'</span>).
             replace(<span class="Constant">/%3D/gi</span>, <span class="Constant">'='</span>).
             replace(<span class="Constant">/%2B/gi</span>, <span class="Constant">'+'</span>);
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * This method is intended for encoding *key* or *value* parts of query component. We need a custom</span>
<span class="Comment"> * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be</span>
<span class="Comment"> * encoded per <a href="http://tools.ietf.org/html/rfc3986:">http://tools.ietf.org/html/rfc3986:</a></span>
<span class="Comment"> *    query       = *( pchar / &quot;/&quot; / &quot;?&quot; )</span>
<span class="Comment"> *    pchar         = unreserved / pct-encoded / sub-delims / &quot;:&quot; / &quot;@&quot;</span>
<span class="Comment"> *    unreserved    = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;</span>
<span class="Comment"> *    pct-encoded   = &quot;%&quot; HEXDIG HEXDIG</span>
<span class="Comment"> *    sub-delims    = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;'&quot; / &quot;(&quot; / &quot;)&quot;</span>
<span class="Comment"> *                     / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> encodeUriQuery(val, pctEncodeSpaces) <span class="Identifier">{</span>
  <span class="Statement">return</span> encodeURIComponent(val).
             replace(<span class="Constant">/%40/gi</span>, <span class="Constant">'@'</span>).
             replace(<span class="Constant">/%3A/gi</span>, <span class="Constant">':'</span>).
             replace(<span class="Constant">/%24/g</span>, <span class="Constant">'$'</span>).
             replace(<span class="Constant">/%2C/gi</span>, <span class="Constant">','</span>).
             replace(<span class="Constant">/%20/g</span>, (pctEncodeSpaces ? <span class="Constant">'%20'</span> : <span class="Constant">'+'</span>));
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngApp</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {angular.Module} ngApp an optional application</span>
<span class="Comment"> *   {@link angular.module module} name to load.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Use this directive to **auto-bootstrap** an AngularJS application. The `ngApp` directive</span>
<span class="Comment"> * designates the **root element** of the application and is typically placed near the root element</span>
<span class="Comment"> * of the page - e.g. on the `&lt;body&gt;` or `&lt;html&gt;` tags.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Only one AngularJS application can be auto-bootstrapped per HTML document. The first `ngApp`</span>
<span class="Comment"> * found in the document will be used to define the root element to auto-bootstrap as an</span>
<span class="Comment"> * application. To run multiple applications in an HTML document you must manually bootstrap them using</span>
<span class="Comment"> * {@link angular.bootstrap} instead. AngularJS applications cannot be nested within each other.</span>
<span class="Comment"> *</span>
<span class="Comment"> * You can specify an **AngularJS module** to be used as the root module for the application.  This</span>
<span class="Comment"> * module will be loaded into the {@link AUTO.$injector} when the application is bootstrapped and</span>
<span class="Comment"> * should contain the application code needed or have dependencies on other modules that will</span>
<span class="Comment"> * contain the code. See {@link angular.module} for more information.</span>
<span class="Comment"> *</span>
<span class="Comment"> * In the example below if the `ngApp` directive were not placed on the `html` element then the</span>
<span class="Comment"> * document would not be compiled, the `AppController` would not be instantiated and the `{{ a+b }}`</span>
<span class="Comment"> * would not be resolved to `3`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * `ngApp` is the easiest, and most common, way to bootstrap an application.</span>
<span class="Comment"> *</span>
<span class="Comment"> &lt;example module=&quot;ngAppDemo&quot;&gt;</span>
<span class="Comment">   &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">   &lt;div ng-controller=&quot;ngAppDemoController&quot;&gt;</span>
<span class="Comment">     I can add: {{a}} + {{b}} =  {{ a+b }}</span>
<span class="Comment">   &lt;/file&gt;</span>
<span class="Comment">   &lt;file name=&quot;script.js&quot;&gt;</span>
<span class="Comment">   angular.module('ngAppDemo', []).controller('ngAppDemoController', function($scope) {</span>
<span class="Comment">     $scope.a = 1;</span>
<span class="Comment">     $scope.b = 2;</span>
<span class="Comment">   });</span>
<span class="Comment">   &lt;/file&gt;</span>
<span class="Comment"> &lt;/example&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> angularInit(element, bootstrap) <span class="Identifier">{</span>
  <span class="Identifier">var</span> elements = <span class="Identifier">[</span>element<span class="Identifier">]</span>,
      appElement,
      module,
      names = <span class="Identifier">[</span><span class="Constant">'ng:app'</span>, <span class="Constant">'ng-app'</span>, <span class="Constant">'x-ng-app'</span>, <span class="Constant">'data-ng-app'</span><span class="Identifier">]</span>,
      NG_APP_CLASS_REGEXP = <span class="Constant">/\sng[:\-]app(:\s*([\w\d_]+);?)?\s/</span>;

  <span class="Identifier">function</span> append(element) <span class="Identifier">{</span>
    element &amp;&amp; elements.push(element);
  <span class="Identifier">}</span>

  forEach(names, <span class="Identifier">function</span>(name) <span class="Identifier">{</span>
    names<span class="Identifier">[</span>name<span class="Identifier">]</span> = <span class="Constant">true</span>;
    append(<span class="Statement">document</span>.getElementById(name));
    name = name.replace(<span class="Constant">':'</span>, <span class="Constant">'</span><span class="Special">\\</span><span class="Constant">:'</span>);
    <span class="Statement">if</span> (element.querySelectorAll) <span class="Identifier">{</span>
      forEach(element.querySelectorAll(<span class="Constant">'.'</span> + name), append);
      forEach(element.querySelectorAll(<span class="Constant">'.'</span> + name + <span class="Constant">'</span><span class="Special">\\</span><span class="Constant">:'</span>), append);
      forEach(element.querySelectorAll(<span class="Constant">'['</span> + name + <span class="Constant">']'</span>), append);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>);

  forEach(elements, <span class="Identifier">function</span>(element) <span class="Identifier">{</span>
    <span class="Statement">if</span> (!appElement) <span class="Identifier">{</span>
      <span class="Identifier">var</span> className = <span class="Constant">' '</span> + element.className + <span class="Constant">' '</span>;
      <span class="Identifier">var</span> match = NG_APP_CLASS_REGEXP.exec(className);
      <span class="Statement">if</span> (match) <span class="Identifier">{</span>
        appElement = element;
        module = (match<span class="Identifier">[</span>2<span class="Identifier">]</span> || <span class="Constant">''</span>).replace(<span class="Constant">/\s+/g</span>, <span class="Constant">','</span>);
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        forEach(element.attributes, <span class="Identifier">function</span>(attr) <span class="Identifier">{</span>
          <span class="Statement">if</span> (!appElement &amp;&amp; names<span class="Identifier">[</span>attr.name<span class="Identifier">]</span>) <span class="Identifier">{</span>
            appElement = element;
            module = attr.value;
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>);
  <span class="Statement">if</span> (appElement) <span class="Identifier">{</span>
    bootstrap(appElement, module ? <span class="Identifier">[</span>module<span class="Identifier">]</span> : <span class="Identifier">[]</span>);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.bootstrap</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Use this function to manually start up angular application.</span>
<span class="Comment"> *</span>
<span class="Comment"> * See: {@link guide/bootstrap Bootstrap}</span>
<span class="Comment"> *</span>
<span class="Comment"> * Note that ngScenario-based end-to-end tests cannot use this function to bootstrap manually.</span>
<span class="Comment"> * They must use {@link api/ng.directive:ngApp ngApp}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {Element} element DOM element which is the root of angular application.</span>
<span class="Comment"> * @param {Array&lt;String|Function|Array&gt;=} modules an array of modules to load into the application.</span>
<span class="Comment"> *     Each item in the array should be the name of a predefined module or a (DI annotated)</span>
<span class="Comment"> *     function that will be invoked by the injector as a run block.</span>
<span class="Comment"> *     See: {@link angular.module modules}</span>
<span class="Comment"> * @returns {AUTO.$injector} Returns the newly created injector for this app.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> bootstrap(element, modules) <span class="Identifier">{</span>
  <span class="Identifier">var</span> doBootstrap = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    element = jqLite(element);

    <span class="Statement">if</span> (element.injector()) <span class="Identifier">{</span>
      <span class="Identifier">var</span> tag = (element<span class="Identifier">[</span>0<span class="Identifier">]</span> === <span class="Statement">document</span>) ? <span class="Constant">'document'</span> : startingTag(element);
      <span class="Statement">throw</span> ngMinErr(<span class="Constant">'btstrpd'</span>, <span class="Constant">&quot;App Already Bootstrapped with this Element '{0}'&quot;</span>, tag);
    <span class="Identifier">}</span>

    modules = modules || <span class="Identifier">[]</span>;
    modules.unshift(<span class="Identifier">[</span><span class="Constant">'$provide'</span>, <span class="Identifier">function</span>($provide) <span class="Identifier">{</span>
      $provide.value(<span class="Constant">'$rootElement'</span>, element);
    <span class="Identifier">}]</span>);
    modules.unshift(<span class="Constant">'ng'</span>);
    <span class="Identifier">var</span> injector = createInjector(modules);
    injector.invoke(<span class="Identifier">[</span><span class="Constant">'$rootScope'</span>, <span class="Constant">'$rootElement'</span>, <span class="Constant">'$compile'</span>, <span class="Constant">'$injector'</span>, <span class="Constant">'$animate'</span>,
       <span class="Identifier">function</span>(scope, element, compile, injector, animate) <span class="Identifier">{</span>
        scope.$apply(<span class="Identifier">function</span>() <span class="Identifier">{</span>
          element.data(<span class="Constant">'$injector'</span>, injector);
          compile(element)(scope);
        <span class="Identifier">}</span>);
      <span class="Identifier">}]</span>
    );
    <span class="Statement">return</span> injector;
  <span class="Identifier">}</span>;

  <span class="Identifier">var</span> NG_DEFER_BOOTSTRAP = <span class="Constant">/^NG_DEFER_BOOTSTRAP!/</span>;

  <span class="Statement">if</span> (<span class="Statement">window</span> &amp;&amp; !NG_DEFER_BOOTSTRAP.test(<span class="Statement">window</span>.name)) <span class="Identifier">{</span>
    <span class="Statement">return</span> doBootstrap();
  <span class="Identifier">}</span>

  <span class="Statement">window</span>.name = <span class="Statement">window</span>.name.replace(NG_DEFER_BOOTSTRAP, <span class="Constant">''</span>);
  angular.resumeBootstrap = <span class="Identifier">function</span>(extraModules) <span class="Identifier">{</span>
    forEach(extraModules, <span class="Identifier">function</span>(module) <span class="Identifier">{</span>
      modules.push(module);
    <span class="Identifier">}</span>);
    doBootstrap();
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Identifier">var</span> SNAKE_CASE_REGEXP = <span class="Constant">/[A-Z]/g</span>;
<span class="Identifier">function</span> snake_case(name, separator)<span class="Identifier">{</span>
  separator = separator || <span class="Constant">'_'</span>;
  <span class="Statement">return</span> name.replace(SNAKE_CASE_REGEXP, <span class="Identifier">function</span>(letter, pos) <span class="Identifier">{</span>
    <span class="Statement">return</span> (pos ? separator : <span class="Constant">''</span>) + letter.toLowerCase();
  <span class="Identifier">}</span>);
<span class="Identifier">}</span>

<span class="Identifier">function</span> bindJQuery() <span class="Identifier">{</span>
  <span class="Comment">// bind to jQuery if present;</span>
  jQuery = <span class="Statement">window</span>.jQuery;
  <span class="Comment">// reset to jQuery or default to us.</span>
  <span class="Statement">if</span> (jQuery) <span class="Identifier">{</span>
    jqLite = jQuery;
    extend(jQuery.fn, <span class="Identifier">{</span>
      scope: JQLitePrototype.scope,
      isolateScope: JQLitePrototype.isolateScope,
      controller: JQLitePrototype.controller,
      injector: JQLitePrototype.injector,
      inheritedData: JQLitePrototype.inheritedData
    <span class="Identifier">}</span>);
    <span class="Comment">// Method signature:</span>
    <span class="Comment">//     jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments)</span>
    jqLitePatchJQueryRemove(<span class="Constant">'remove'</span>, <span class="Constant">true</span>, <span class="Constant">true</span>, <span class="Constant">false</span>);
    jqLitePatchJQueryRemove(<span class="Constant">'empty'</span>, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>);
    jqLitePatchJQueryRemove(<span class="Constant">'html'</span>, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">true</span>);
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
    jqLite = JQLite;
  <span class="Identifier">}</span>
  angular.element = jqLite;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * throw error if the argument is falsy.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> assertArg(arg, name, reason) <span class="Identifier">{</span>
  <span class="Statement">if</span> (!arg) <span class="Identifier">{</span>
    <span class="Statement">throw</span> ngMinErr(<span class="Constant">'areq'</span>, <span class="Constant">&quot;Argument '{0}' is {1}&quot;</span>, (name || <span class="Constant">'?'</span>), (reason || <span class="Constant">&quot;required&quot;</span>));
  <span class="Identifier">}</span>
  <span class="Statement">return</span> arg;
<span class="Identifier">}</span>

<span class="Identifier">function</span> assertArgFn(arg, name, acceptArrayAnnotation) <span class="Identifier">{</span>
  <span class="Statement">if</span> (acceptArrayAnnotation &amp;&amp; isArray(arg)) <span class="Identifier">{</span>
      arg = arg<span class="Identifier">[</span>arg.length - 1<span class="Identifier">]</span>;
  <span class="Identifier">}</span>

  assertArg(isFunction(arg), name, <span class="Constant">'not a function, got '</span> +
      (arg &amp;&amp; <span class="Statement">typeof</span> arg == <span class="Constant">'object'</span> ? arg.constructor.name || <span class="Constant">'Object'</span> : <span class="Statement">typeof</span> arg));
  <span class="Statement">return</span> arg;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * throw error if the name given is hasOwnProperty</span>
<span class="Comment"> * @param  {String} name    the name to test</span>
<span class="Comment"> * @param  {String} context the context in which the name is used, such as module or directive</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> assertNotHasOwnProperty(name, context) <span class="Identifier">{</span>
  <span class="Statement">if</span> (name === <span class="Constant">'hasOwnProperty'</span>) <span class="Identifier">{</span>
    <span class="Statement">throw</span> ngMinErr(<span class="Constant">'badname'</span>, <span class="Constant">&quot;hasOwnProperty is not a valid {0} name&quot;</span>, context);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * Return the value accessible from the object by path. Any undefined traversals are ignored</span>
<span class="Comment"> * @param {Object} obj starting object</span>
<span class="Comment"> * @param {string} path path to traverse</span>
<span class="Comment"> * @param {boolean=true} bindFnToScope</span>
<span class="Comment"> * @returns value as accessible by path</span>
<span class="Comment"> */</span>
<span class="Comment">//</span><span class="Todo">TODO</span><span class="Comment">(misko): this function needs to be removed</span>
<span class="Identifier">function</span> getter(obj, path, bindFnToScope) <span class="Identifier">{</span>
  <span class="Statement">if</span> (!path) <span class="Statement">return</span> obj;
  <span class="Identifier">var</span> keys = path.split(<span class="Constant">'.'</span>);
  <span class="Identifier">var</span> key;
  <span class="Identifier">var</span> lastInstance = obj;
  <span class="Identifier">var</span> len = keys.length;

  <span class="Statement">for</span> (<span class="Identifier">var</span> i = 0; i &lt; len; i++) <span class="Identifier">{</span>
    key = keys<span class="Identifier">[</span>i<span class="Identifier">]</span>;
    <span class="Statement">if</span> (obj) <span class="Identifier">{</span>
      obj = (lastInstance = obj)<span class="Identifier">[</span>key<span class="Identifier">]</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>
  <span class="Statement">if</span> (!bindFnToScope &amp;&amp; isFunction(obj)) <span class="Identifier">{</span>
    <span class="Statement">return</span> bind(lastInstance, obj);
  <span class="Identifier">}</span>
  <span class="Statement">return</span> obj;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * Return the DOM siblings between the first and last node in the given array.</span>
<span class="Comment"> * @param {Array} array like object</span>
<span class="Comment"> * @returns jQlite object containing the elements</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> getBlockElements(nodes) <span class="Identifier">{</span>
  <span class="Identifier">var</span> startNode = nodes<span class="Identifier">[</span>0<span class="Identifier">]</span>,
      endNode = nodes<span class="Identifier">[</span>nodes.length - 1<span class="Identifier">]</span>;
  <span class="Statement">if</span> (startNode === endNode) <span class="Identifier">{</span>
    <span class="Statement">return</span> jqLite(startNode);
  <span class="Identifier">}</span>

  <span class="Identifier">var</span> element = startNode;
  <span class="Identifier">var</span> elements = <span class="Identifier">[</span>element<span class="Identifier">]</span>;

  <span class="Statement">do</span> <span class="Identifier">{</span>
    element = element.nextSibling;
    <span class="Statement">if</span> (!element) <span class="Statement">break</span>;
    elements.push(element);
  <span class="Identifier">}</span> <span class="Statement">while</span> (element !== endNode);

  <span class="Statement">return</span> jqLite(elements);
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc interface</span>
<span class="Comment"> * @name angular.Module</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Interface for configuring angular {@link angular.module modules}.</span>
<span class="Comment"> */</span>

<span class="Identifier">function</span> setupModuleLoader(<span class="Statement">window</span>) <span class="Identifier">{</span>

  <span class="Identifier">var</span> $injectorMinErr = minErr(<span class="Constant">'$injector'</span>);
  <span class="Identifier">var</span> ngMinErr = minErr(<span class="Constant">'ng'</span>);

  <span class="Identifier">function</span> ensure(obj, name, factory) <span class="Identifier">{</span>
    <span class="Statement">return</span> obj<span class="Identifier">[</span>name<span class="Identifier">]</span> || (obj<span class="Identifier">[</span>name<span class="Identifier">]</span> = factory());
  <span class="Identifier">}</span>

  <span class="Identifier">var</span> angular = ensure(<span class="Statement">window</span>, <span class="Constant">'angular'</span>, <span class="Type">Object</span>);

  <span class="Comment">// We need to expose `angular.$$minErr` to modules such as `ngResource` that reference it during bootstrap</span>
  angular.$$minErr = angular.$$minErr || minErr;

  <span class="Statement">return</span> ensure(angular, <span class="Constant">'module'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Comment">/** @type {Object.&lt;string, angular.Module&gt;} */</span>
    <span class="Identifier">var</span> modules = <span class="Identifier">{}</span>;

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc function</span>
<span class="Comment">     * @name angular.module</span>
<span class="Comment">     * @description</span>
<span class="Comment">     *</span>
<span class="Comment">     * The `angular.module` is a global place for creating, registering and retrieving Angular</span>
<span class="Comment">     * modules.</span>
<span class="Comment">     * All modules (angular core or 3rd party) that should be available to an application must be</span>
<span class="Comment">     * registered using this mechanism.</span>
<span class="Comment">     *</span>
<span class="Comment">     * When passed two or more arguments, a new module is created.  If passed only one argument, an</span>
<span class="Comment">     * existing module (the name passed as the first argument to `module`) is retrieved.</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     * # Module</span>
<span class="Comment">     *</span>
<span class="Comment">     * A module is a collection of services, directives, filters, and configuration information.</span>
<span class="Comment">     * `angular.module` is used to configure the {@link AUTO.$injector $injector}.</span>
<span class="Comment">     *</span>
<span class="Comment">     * &lt;pre&gt;</span>
<span class="Comment">     * // Create a new module</span>
<span class="Comment">     * var myModule = angular.module('myModule', []);</span>
<span class="Comment">     *</span>
<span class="Comment">     * // register a new service</span>
<span class="Comment">     * myModule.value('appName', 'MyCoolApp');</span>
<span class="Comment">     *</span>
<span class="Comment">     * // configure existing services inside initialization blocks.</span>
<span class="Comment">     * myModule.config(function($locationProvider) {</span>
<span class="Comment">     *   // Configure existing providers</span>
<span class="Comment">     *   $locationProvider.hashPrefix('!');</span>
<span class="Comment">     * });</span>
<span class="Comment">     * &lt;/pre&gt;</span>
<span class="Comment">     *</span>
<span class="Comment">     * Then you can create an injector and load your modules like this:</span>
<span class="Comment">     *</span>
<span class="Comment">     * &lt;pre&gt;</span>
<span class="Comment">     * var injector = angular.injector(['ng', 'MyModule'])</span>
<span class="Comment">     * &lt;/pre&gt;</span>
<span class="Comment">     *</span>
<span class="Comment">     * However it's more likely that you'll just use</span>
<span class="Comment">     * {@link ng.directive:ngApp ngApp} or</span>
<span class="Comment">     * {@link angular.bootstrap} to simplify this process for you.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {!string} name The name of the module to create or retrieve.</span>
<span class="Comment">     * @param {Array.&lt;string&gt;=} requires If specified then new module is being created. If</span>
<span class="Comment">     *        unspecified then the the module is being retrieved for further configuration.</span>
<span class="Comment">     * @param {Function} configFn Optional configuration function for the module. Same as</span>
<span class="Comment">     *        {@link angular.Module#methods_config Module#config()}.</span>
<span class="Comment">     * @returns {module} new module with the {@link angular.Module} api.</span>
<span class="Comment">     */</span>
    <span class="Statement">return</span> <span class="Identifier">function</span> module(name, requires, configFn) <span class="Identifier">{</span>
      <span class="Identifier">var</span> assertNotHasOwnProperty = <span class="Identifier">function</span>(name, context) <span class="Identifier">{</span>
        <span class="Statement">if</span> (name === <span class="Constant">'hasOwnProperty'</span>) <span class="Identifier">{</span>
          <span class="Statement">throw</span> ngMinErr(<span class="Constant">'badname'</span>, <span class="Constant">'hasOwnProperty is not a valid {0} name'</span>, context);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>;

      assertNotHasOwnProperty(name, <span class="Constant">'module'</span>);
      <span class="Statement">if</span> (requires &amp;&amp; modules.hasOwnProperty(name)) <span class="Identifier">{</span>
        modules<span class="Identifier">[</span>name<span class="Identifier">]</span> = <span class="Statement">null</span>;
      <span class="Identifier">}</span>
      <span class="Statement">return</span> ensure(modules, name, <span class="Identifier">function</span>() <span class="Identifier">{</span>
        <span class="Statement">if</span> (!requires) <span class="Identifier">{</span>
          <span class="Statement">throw</span> $injectorMinErr(<span class="Constant">'nomod'</span>, <span class="Constant">&quot;Module '{0}' is not available! You either misspelled &quot;</span> +
             <span class="Constant">&quot;the module name or forgot to load it. If registering a module ensure that you &quot;</span> +
             <span class="Constant">&quot;specify the dependencies as the second argument.&quot;</span>, name);
        <span class="Identifier">}</span>

        <span class="Comment">/** @type {!Array.&lt;Array.&lt;*&gt;&gt;} */</span>
        <span class="Identifier">var</span> invokeQueue = <span class="Identifier">[]</span>;

        <span class="Comment">/** @type {!Array.&lt;Function&gt;} */</span>
        <span class="Identifier">var</span> runBlocks = <span class="Identifier">[]</span>;

        <span class="Identifier">var</span> config = invokeLater(<span class="Constant">'$injector'</span>, <span class="Constant">'invoke'</span>);

        <span class="Comment">/** @type {angular.Module} */</span>
        <span class="Identifier">var</span> moduleInstance = <span class="Identifier">{</span>
          <span class="Comment">// Private state</span>
          _invokeQueue: invokeQueue,
          _runBlocks: runBlocks,

          <span class="Comment">/**</span>
<span class="Comment">           * @ngdoc property</span>
<span class="Comment">           * @name angular.Module#requires</span>
<span class="Comment">           * @propertyOf angular.Module</span>
<span class="Comment">           * @returns {Array.&lt;string&gt;} List of module names which must be loaded before this module.</span>
<span class="Comment">           * @description</span>
<span class="Comment">           * Holds the list of modules which the injector will load before the current module is</span>
<span class="Comment">           * loaded.</span>
<span class="Comment">           */</span>
          requires: requires,

          <span class="Comment">/**</span>
<span class="Comment">           * @ngdoc property</span>
<span class="Comment">           * @name angular.Module#name</span>
<span class="Comment">           * @propertyOf angular.Module</span>
<span class="Comment">           * @returns {string} Name of the module.</span>
<span class="Comment">           * @description</span>
<span class="Comment">           */</span>
          name: name,


          <span class="Comment">/**</span>
<span class="Comment">           * @ngdoc method</span>
<span class="Comment">           * @name angular.Module#provider</span>
<span class="Comment">           * @methodOf angular.Module</span>
<span class="Comment">           * @param {string} name service name</span>
<span class="Comment">           * @param {Function} providerType Construction function for creating new instance of the</span>
<span class="Comment">           *                                service.</span>
<span class="Comment">           * @description</span>
<span class="Comment">           * See {@link AUTO.$provide#provider $provide.provider()}.</span>
<span class="Comment">           */</span>
          provider: invokeLater(<span class="Constant">'$provide'</span>, <span class="Constant">'provider'</span>),

          <span class="Comment">/**</span>
<span class="Comment">           * @ngdoc method</span>
<span class="Comment">           * @name angular.Module#factory</span>
<span class="Comment">           * @methodOf angular.Module</span>
<span class="Comment">           * @param {string} name service name</span>
<span class="Comment">           * @param {Function} providerFunction Function for creating new instance of the service.</span>
<span class="Comment">           * @description</span>
<span class="Comment">           * See {@link AUTO.$provide#factory $provide.factory()}.</span>
<span class="Comment">           */</span>
          factory: invokeLater(<span class="Constant">'$provide'</span>, <span class="Constant">'factory'</span>),

          <span class="Comment">/**</span>
<span class="Comment">           * @ngdoc method</span>
<span class="Comment">           * @name angular.Module#service</span>
<span class="Comment">           * @methodOf angular.Module</span>
<span class="Comment">           * @param {string} name service name</span>
<span class="Comment">           * @param {Function} constructor A constructor function that will be instantiated.</span>
<span class="Comment">           * @description</span>
<span class="Comment">           * See {@link AUTO.$provide#service $provide.service()}.</span>
<span class="Comment">           */</span>
          service: invokeLater(<span class="Constant">'$provide'</span>, <span class="Constant">'service'</span>),

          <span class="Comment">/**</span>
<span class="Comment">           * @ngdoc method</span>
<span class="Comment">           * @name angular.Module#value</span>
<span class="Comment">           * @methodOf angular.Module</span>
<span class="Comment">           * @param {string} name service name</span>
<span class="Comment">           * @param {*} object Service instance object.</span>
<span class="Comment">           * @description</span>
<span class="Comment">           * See {@link AUTO.$provide#value $provide.value()}.</span>
<span class="Comment">           */</span>
          value: invokeLater(<span class="Constant">'$provide'</span>, <span class="Constant">'value'</span>),

          <span class="Comment">/**</span>
<span class="Comment">           * @ngdoc method</span>
<span class="Comment">           * @name angular.Module#constant</span>
<span class="Comment">           * @methodOf angular.Module</span>
<span class="Comment">           * @param {string} name constant name</span>
<span class="Comment">           * @param {*} object Constant value.</span>
<span class="Comment">           * @description</span>
<span class="Comment">           * Because the constant are fixed, they get applied before other provide methods.</span>
<span class="Comment">           * See {@link AUTO.$provide#constant $provide.constant()}.</span>
<span class="Comment">           */</span>
          constant: invokeLater(<span class="Constant">'$provide'</span>, <span class="Constant">'constant'</span>, <span class="Constant">'unshift'</span>),

          <span class="Comment">/**</span>
<span class="Comment">           * @ngdoc method</span>
<span class="Comment">           * @name angular.Module#animation</span>
<span class="Comment">           * @methodOf angular.Module</span>
<span class="Comment">           * @param {string} name animation name</span>
<span class="Comment">           * @param {Function} animationFactory Factory function for creating new instance of an</span>
<span class="Comment">           *                                    animation.</span>
<span class="Comment">           * @description</span>
<span class="Comment">           *</span>
<span class="Comment">           * **NOTE**: animations take effect only if the **ngAnimate** module is loaded.</span>
<span class="Comment">           *</span>
<span class="Comment">           *</span>
<span class="Comment">           * Defines an animation hook that can be later used with</span>
<span class="Comment">           * {@link ngAnimate.$animate $animate} service and directives that use this service.</span>
<span class="Comment">           *</span>
<span class="Comment">           * &lt;pre&gt;</span>
<span class="Comment">           * module.animation('.animation-name', function($inject1, $inject2) {</span>
<span class="Comment">           *   return {</span>
<span class="Comment">           *     eventName : function(element, done) {</span>
<span class="Comment">           *       //code to run the animation</span>
<span class="Comment">           *       //once complete, then run done()</span>
<span class="Comment">           *       return function cancellationFunction(element) {</span>
<span class="Comment">           *         //code to cancel the animation</span>
<span class="Comment">           *       }</span>
<span class="Comment">           *     }</span>
<span class="Comment">           *   }</span>
<span class="Comment">           * })</span>
<span class="Comment">           * &lt;/pre&gt;</span>
<span class="Comment">           *</span>
<span class="Comment">           * See {@link ngAnimate.$animateProvider#register $animateProvider.register()} and</span>
<span class="Comment">           * {@link ngAnimate ngAnimate module} for more information.</span>
<span class="Comment">           */</span>
          animation: invokeLater(<span class="Constant">'$animateProvider'</span>, <span class="Constant">'register'</span>),

          <span class="Comment">/**</span>
<span class="Comment">           * @ngdoc method</span>
<span class="Comment">           * @name angular.Module#filter</span>
<span class="Comment">           * @methodOf angular.Module</span>
<span class="Comment">           * @param {string} name Filter name.</span>
<span class="Comment">           * @param {Function} filterFactory Factory function for creating new instance of filter.</span>
<span class="Comment">           * @description</span>
<span class="Comment">           * See {@link ng.$filterProvider#register $filterProvider.register()}.</span>
<span class="Comment">           */</span>
          filter: invokeLater(<span class="Constant">'$filterProvider'</span>, <span class="Constant">'register'</span>),

          <span class="Comment">/**</span>
<span class="Comment">           * @ngdoc method</span>
<span class="Comment">           * @name angular.Module#controller</span>
<span class="Comment">           * @methodOf angular.Module</span>
<span class="Comment">           * @param {string|Object} name Controller name, or an object map of controllers where the</span>
<span class="Comment">           *    keys are the names and the values are the constructors.</span>
<span class="Comment">           * @param {Function} constructor Controller constructor function.</span>
<span class="Comment">           * @description</span>
<span class="Comment">           * See {@link ng.$controllerProvider#register $controllerProvider.register()}.</span>
<span class="Comment">           */</span>
          controller: invokeLater(<span class="Constant">'$controllerProvider'</span>, <span class="Constant">'register'</span>),

          <span class="Comment">/**</span>
<span class="Comment">           * @ngdoc method</span>
<span class="Comment">           * @name angular.Module#directive</span>
<span class="Comment">           * @methodOf angular.Module</span>
<span class="Comment">           * @param {string|Object} name Directive name, or an object map of directives where the</span>
<span class="Comment">           *    keys are the names and the values are the factories.</span>
<span class="Comment">           * @param {Function} directiveFactory Factory function for creating new instance of</span>
<span class="Comment">           * directives.</span>
<span class="Comment">           * @description</span>
<span class="Comment">           * See {@link ng.$compileProvider#methods_directive $compileProvider.directive()}.</span>
<span class="Comment">           */</span>
          directive: invokeLater(<span class="Constant">'$compileProvider'</span>, <span class="Constant">'directive'</span>),

          <span class="Comment">/**</span>
<span class="Comment">           * @ngdoc method</span>
<span class="Comment">           * @name angular.Module#config</span>
<span class="Comment">           * @methodOf angular.Module</span>
<span class="Comment">           * @param {Function} configFn Execute this function on module load. Useful for service</span>
<span class="Comment">           *    configuration.</span>
<span class="Comment">           * @description</span>
<span class="Comment">           * Use this method to register work which needs to be performed on module loading.</span>
<span class="Comment">           */</span>
          config: config,

          <span class="Comment">/**</span>
<span class="Comment">           * @ngdoc method</span>
<span class="Comment">           * @name angular.Module#run</span>
<span class="Comment">           * @methodOf angular.Module</span>
<span class="Comment">           * @param {Function} initializationFn Execute this function after injector creation.</span>
<span class="Comment">           *    Useful for application initialization.</span>
<span class="Comment">           * @description</span>
<span class="Comment">           * Use this method to register work which should be performed when the injector is done</span>
<span class="Comment">           * loading all modules.</span>
<span class="Comment">           */</span>
          run: <span class="Identifier">function</span>(block) <span class="Identifier">{</span>
            runBlocks.push(block);
            <span class="Statement">return</span> <span class="Identifier">this</span>;
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>;

        <span class="Statement">if</span> (configFn) <span class="Identifier">{</span>
          config(configFn);
        <span class="Identifier">}</span>

        <span class="Statement">return</span>  moduleInstance;

        <span class="Comment">/**</span>
<span class="Comment">         * @param {string} provider</span>
<span class="Comment">         * @param {string} method</span>
<span class="Comment">         * @param {String=} insertMethod</span>
<span class="Comment">         * @returns {angular.Module}</span>
<span class="Comment">         */</span>
        <span class="Identifier">function</span> invokeLater(provider, method, insertMethod) <span class="Identifier">{</span>
          <span class="Statement">return</span> <span class="Identifier">function</span>() <span class="Identifier">{</span>
            invokeQueue<span class="Identifier">[</span>insertMethod || <span class="Constant">'push'</span><span class="Identifier">]</span>(<span class="Identifier">[</span>provider, method, <span class="Identifier">arguments</span><span class="Identifier">]</span>);
            <span class="Statement">return</span> moduleInstance;
          <span class="Identifier">}</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>);

<span class="Identifier">}</span>

<span class="Comment">/* global</span>
<span class="Comment">    angularModule: true,</span>
<span class="Comment">    version: true,</span>
<span class="Comment">    </span>
<span class="Comment">    $LocaleProvider,</span>
<span class="Comment">    $CompileProvider,</span>
<span class="Comment">    </span>
<span class="Comment">    htmlAnchorDirective,</span>
<span class="Comment">    inputDirective,</span>
<span class="Comment">    inputDirective,</span>
<span class="Comment">    formDirective,</span>
<span class="Comment">    scriptDirective,</span>
<span class="Comment">    selectDirective,</span>
<span class="Comment">    styleDirective,</span>
<span class="Comment">    optionDirective,</span>
<span class="Comment">    ngBindDirective,</span>
<span class="Comment">    ngBindHtmlDirective,</span>
<span class="Comment">    ngBindTemplateDirective,</span>
<span class="Comment">    ngClassDirective,</span>
<span class="Comment">    ngClassEvenDirective,</span>
<span class="Comment">    ngClassOddDirective,</span>
<span class="Comment">    ngCspDirective,</span>
<span class="Comment">    ngCloakDirective,</span>
<span class="Comment">    ngControllerDirective,</span>
<span class="Comment">    ngFormDirective,</span>
<span class="Comment">    ngHideDirective,</span>
<span class="Comment">    ngIfDirective,</span>
<span class="Comment">    ngIncludeDirective,</span>
<span class="Comment">    ngInitDirective,</span>
<span class="Comment">    ngNonBindableDirective,</span>
<span class="Comment">    ngPluralizeDirective,</span>
<span class="Comment">    ngRepeatDirective,</span>
<span class="Comment">    ngShowDirective,</span>
<span class="Comment">    ngStyleDirective,</span>
<span class="Comment">    ngSwitchDirective,</span>
<span class="Comment">    ngSwitchWhenDirective,</span>
<span class="Comment">    ngSwitchDefaultDirective,</span>
<span class="Comment">    ngOptionsDirective,</span>
<span class="Comment">    ngTranscludeDirective,</span>
<span class="Comment">    ngModelDirective,</span>
<span class="Comment">    ngListDirective,</span>
<span class="Comment">    ngChangeDirective,</span>
<span class="Comment">    requiredDirective,</span>
<span class="Comment">    requiredDirective,</span>
<span class="Comment">    ngValueDirective,</span>
<span class="Comment">    ngAttributeAliasDirectives,</span>
<span class="Comment">    ngEventDirectives,</span>

<span class="Comment">    $AnchorScrollProvider,</span>
<span class="Comment">    $AnimateProvider,</span>
<span class="Comment">    $BrowserProvider,</span>
<span class="Comment">    $CacheFactoryProvider,</span>
<span class="Comment">    $ControllerProvider,</span>
<span class="Comment">    $DocumentProvider,</span>
<span class="Comment">    $ExceptionHandlerProvider,</span>
<span class="Comment">    $FilterProvider,</span>
<span class="Comment">    $InterpolateProvider,</span>
<span class="Comment">    $IntervalProvider,</span>
<span class="Comment">    $HttpProvider,</span>
<span class="Comment">    $HttpBackendProvider,</span>
<span class="Comment">    $LocationProvider,</span>
<span class="Comment">    $LogProvider,</span>
<span class="Comment">    $ParseProvider,</span>
<span class="Comment">    $RootScopeProvider,</span>
<span class="Comment">    $QProvider,</span>
<span class="Comment">    $$SanitizeUriProvider,</span>
<span class="Comment">    $SceProvider,</span>
<span class="Comment">    $SceDelegateProvider,</span>
<span class="Comment">    $SnifferProvider,</span>
<span class="Comment">    $TemplateCacheProvider,</span>
<span class="Comment">    $TimeoutProvider,</span>
<span class="Comment">    $WindowProvider</span>
<span class="Comment">*/</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc property</span>
<span class="Comment"> * @name angular.version</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * An object that contains information about the current AngularJS version. This object has the</span>
<span class="Comment"> * following properties:</span>
<span class="Comment"> *</span>
<span class="Comment"> * - `full` – `{string}` – Full version string, such as &quot;0.9.18&quot;.</span>
<span class="Comment"> * - `major` – `{number}` – Major version number, such as &quot;0&quot;.</span>
<span class="Comment"> * - `minor` – `{number}` – Minor version number, such as &quot;9&quot;.</span>
<span class="Comment"> * - `dot` – `{number}` – Dot version number, such as &quot;18&quot;.</span>
<span class="Comment"> * - `codeName` – `{string}` – Code name of the release, such as &quot;jiggling-armfat&quot;.</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> version = <span class="Identifier">{</span>
  full: <span class="Constant">'1.2.4'</span>,    <span class="Comment">// all of these placeholder strings will be replaced by grunt's</span>
  major: 1,    <span class="Comment">// package task</span>
  minor: 2,
  dot: 4,
  codeName: <span class="Constant">'wormhole-baster'</span>
<span class="Identifier">}</span>;


<span class="Identifier">function</span> publishExternalAPI(angular)<span class="Identifier">{</span>
  extend(angular, <span class="Identifier">{</span>
    <span class="Constant">'bootstrap'</span>: bootstrap,
    <span class="Constant">'copy'</span>: copy,
    <span class="Constant">'extend'</span>: extend,
    <span class="Constant">'equals'</span>: equals,
    <span class="Constant">'element'</span>: jqLite,
    <span class="Constant">'forEach'</span>: forEach,
    <span class="Constant">'injector'</span>: createInjector,
    <span class="Constant">'noop'</span>:noop,
    <span class="Constant">'bind'</span>:bind,
    <span class="Constant">'toJson'</span>: toJson,
    <span class="Constant">'fromJson'</span>: fromJson,
    <span class="Constant">'identity'</span>:identity,
    <span class="Constant">'isUndefined'</span>: isUndefined,
    <span class="Constant">'isDefined'</span>: isDefined,
    <span class="Constant">'isString'</span>: isString,
    <span class="Constant">'isFunction'</span>: isFunction,
    <span class="Constant">'isObject'</span>: isObject,
    <span class="Constant">'isNumber'</span>: isNumber,
    <span class="Constant">'isElement'</span>: isElement,
    <span class="Constant">'isArray'</span>: isArray,
    <span class="Constant">'version'</span>: version,
    <span class="Constant">'isDate'</span>: isDate,
    <span class="Constant">'lowercase'</span>: lowercase,
    <span class="Constant">'uppercase'</span>: uppercase,
    <span class="Constant">'callbacks'</span>: <span class="Identifier">{</span>counter: 0<span class="Identifier">}</span>,
    <span class="Constant">'$$minErr'</span>: minErr,
    <span class="Constant">'$$csp'</span>: csp
  <span class="Identifier">}</span>);

  angularModule = setupModuleLoader(<span class="Statement">window</span>);
  <span class="Statement">try</span> <span class="Identifier">{</span>
    angularModule(<span class="Constant">'ngLocale'</span>);
  <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
    angularModule(<span class="Constant">'ngLocale'</span>, <span class="Identifier">[]</span>).provider(<span class="Constant">'$locale'</span>, $LocaleProvider);
  <span class="Identifier">}</span>

  angularModule(<span class="Constant">'ng'</span>, <span class="Identifier">[</span><span class="Constant">'ngLocale'</span><span class="Identifier">]</span>, <span class="Identifier">[</span><span class="Constant">'$provide'</span>,
    <span class="Identifier">function</span> ngModule($provide) <span class="Identifier">{</span>
      <span class="Comment">// $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.</span>
      $provide.provider(<span class="Identifier">{</span>
        $$sanitizeUri: $$SanitizeUriProvider
      <span class="Identifier">}</span>);
      $provide.provider(<span class="Constant">'$compile'</span>, $CompileProvider).
        directive(<span class="Identifier">{</span>
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            ngValue: ngValueDirective
        <span class="Identifier">}</span>).
        directive(ngAttributeAliasDirectives).
        directive(ngEventDirectives);
      $provide.provider(<span class="Identifier">{</span>
        $anchorScroll: $AnchorScrollProvider,
        $animate: $AnimateProvider,
        $browser: $BrowserProvider,
        $cacheFactory: $CacheFactoryProvider,
        $controller: $ControllerProvider,
        $<span class="Statement">document</span>: $DocumentProvider,
        $exceptionHandler: $ExceptionHandlerProvider,
        $filter: $FilterProvider,
        $interpolate: $InterpolateProvider,
        $interval: $IntervalProvider,
        $http: $HttpProvider,
        $httpBackend: $HttpBackendProvider,
        $<span class="Statement">location</span>: $LocationProvider,
        $log: $LogProvider,
        $parse: $ParseProvider,
        $rootScope: $RootScopeProvider,
        $q: $QProvider,
        $sce: $SceProvider,
        $sceDelegate: $SceDelegateProvider,
        $sniffer: $SnifferProvider,
        $templateCache: $TemplateCacheProvider,
        $timeout: $TimeoutProvider,
        $<span class="Statement">window</span>: $WindowProvider
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">]</span>);
<span class="Identifier">}</span>

<span class="Comment">/* global</span>

<span class="Comment">  -JQLitePrototype,</span>
<span class="Comment">  -addEventListenerFn,</span>
<span class="Comment">  -removeEventListenerFn,</span>
<span class="Comment">  -BOOLEAN_ATTR</span>
<span class="Comment">*/</span>

<span class="Comment">//////////////////////////////////</span>
<span class="Comment">//JQLite</span>
<span class="Comment">//////////////////////////////////</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.element</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Wraps a raw DOM element or HTML string as a [jQuery](<a href="http://jquery.com)">http://jquery.com)</a> element.</span>
<span class="Comment"> *</span>
<span class="Comment"> * If jQuery is available, `angular.element` is an alias for the</span>
<span class="Comment"> * [jQuery](<a href="http://api.jquery.com/jQuery/)">http://api.jquery.com/jQuery/)</a> function. If jQuery is not available, `angular.element`</span>
<span class="Comment"> * delegates to Angular's built-in subset of jQuery, called &quot;jQuery lite&quot; or &quot;jqLite.&quot;</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;div class=&quot;alert alert-success&quot;&gt;jqLite is a tiny, API-compatible subset of jQuery that allows</span>
<span class="Comment"> * Angular to manipulate the DOM in a cross-browser compatible way. **jqLite** implements only the most</span>
<span class="Comment"> * commonly needed functionality with the goal of having a very small footprint.&lt;/div&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * To use jQuery, simply load it before `DOMContentLoaded` event fired.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;div class=&quot;alert&quot;&gt;**Note:** all element references in Angular are always wrapped with jQuery or</span>
<span class="Comment"> * jqLite; they are never raw DOM references.&lt;/div&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## Angular's jqLite</span>
<span class="Comment"> * jqLite provides only the following jQuery methods:</span>
<span class="Comment"> *</span>
<span class="Comment"> * - [`addClass()`](<a href="http://api.jquery.com/addClass/)">http://api.jquery.com/addClass/)</a></span>
<span class="Comment"> * - [`after()`](<a href="http://api.jquery.com/after/)">http://api.jquery.com/after/)</a></span>
<span class="Comment"> * - [`append()`](<a href="http://api.jquery.com/append/)">http://api.jquery.com/append/)</a></span>
<span class="Comment"> * - [`attr()`](<a href="http://api.jquery.com/attr/)">http://api.jquery.com/attr/)</a></span>
<span class="Comment"> * - [`bind()`](<a href="http://api.jquery.com/on/)">http://api.jquery.com/on/)</a> - Does not support namespaces, selectors or eventData</span>
<span class="Comment"> * - [`children()`](<a href="http://api.jquery.com/children/)">http://api.jquery.com/children/)</a> - Does not support selectors</span>
<span class="Comment"> * - [`clone()`](<a href="http://api.jquery.com/clone/)">http://api.jquery.com/clone/)</a></span>
<span class="Comment"> * - [`contents()`](<a href="http://api.jquery.com/contents/)">http://api.jquery.com/contents/)</a></span>
<span class="Comment"> * - [`css()`](<a href="http://api.jquery.com/css/)">http://api.jquery.com/css/)</a></span>
<span class="Comment"> * - [`data()`](<a href="http://api.jquery.com/data/)">http://api.jquery.com/data/)</a></span>
<span class="Comment"> * - [`eq()`](<a href="http://api.jquery.com/eq/)">http://api.jquery.com/eq/)</a></span>
<span class="Comment"> * - [`find()`](<a href="http://api.jquery.com/find/)">http://api.jquery.com/find/)</a> - Limited to lookups by tag name</span>
<span class="Comment"> * - [`hasClass()`](<a href="http://api.jquery.com/hasClass/)">http://api.jquery.com/hasClass/)</a></span>
<span class="Comment"> * - [`html()`](<a href="http://api.jquery.com/html/)">http://api.jquery.com/html/)</a></span>
<span class="Comment"> * - [`next()`](<a href="http://api.jquery.com/next/)">http://api.jquery.com/next/)</a> - Does not support selectors</span>
<span class="Comment"> * - [`on()`](<a href="http://api.jquery.com/on/)">http://api.jquery.com/on/)</a> - Does not support namespaces, selectors or eventData</span>
<span class="Comment"> * - [`off()`](<a href="http://api.jquery.com/off/)">http://api.jquery.com/off/)</a> - Does not support namespaces or selectors</span>
<span class="Comment"> * - [`parent()`](<a href="http://api.jquery.com/parent/)">http://api.jquery.com/parent/)</a> - Does not support selectors</span>
<span class="Comment"> * - [`prepend()`](<a href="http://api.jquery.com/prepend/)">http://api.jquery.com/prepend/)</a></span>
<span class="Comment"> * - [`prop()`](<a href="http://api.jquery.com/prop/)">http://api.jquery.com/prop/)</a></span>
<span class="Comment"> * - [`ready()`](<a href="http://api.jquery.com/ready/)">http://api.jquery.com/ready/)</a></span>
<span class="Comment"> * - [`remove()`](<a href="http://api.jquery.com/remove/)">http://api.jquery.com/remove/)</a></span>
<span class="Comment"> * - [`removeAttr()`](<a href="http://api.jquery.com/removeAttr/)">http://api.jquery.com/removeAttr/)</a></span>
<span class="Comment"> * - [`removeClass()`](<a href="http://api.jquery.com/removeClass/)">http://api.jquery.com/removeClass/)</a></span>
<span class="Comment"> * - [`removeData()`](<a href="http://api.jquery.com/removeData/)">http://api.jquery.com/removeData/)</a></span>
<span class="Comment"> * - [`replaceWith()`](<a href="http://api.jquery.com/replaceWith/)">http://api.jquery.com/replaceWith/)</a></span>
<span class="Comment"> * - [`text()`](<a href="http://api.jquery.com/text/)">http://api.jquery.com/text/)</a></span>
<span class="Comment"> * - [`toggleClass()`](<a href="http://api.jquery.com/toggleClass/)">http://api.jquery.com/toggleClass/)</a></span>
<span class="Comment"> * - [`triggerHandler()`](<a href="http://api.jquery.com/triggerHandler/)">http://api.jquery.com/triggerHandler/)</a> - Passes a dummy event object to handlers.</span>
<span class="Comment"> * - [`unbind()`](<a href="http://api.jquery.com/off/)">http://api.jquery.com/off/)</a> - Does not support namespaces</span>
<span class="Comment"> * - [`val()`](<a href="http://api.jquery.com/val/)">http://api.jquery.com/val/)</a></span>
<span class="Comment"> * - [`wrap()`](<a href="http://api.jquery.com/wrap/)">http://api.jquery.com/wrap/)</a></span>
<span class="Comment"> *</span>
<span class="Comment"> * ## jQuery/jqLite Extras</span>
<span class="Comment"> * Angular also provides the following additional methods and events to both jQuery and jqLite:</span>
<span class="Comment"> *</span>
<span class="Comment"> * ### Events</span>
<span class="Comment"> * - `$destroy` - AngularJS intercepts all jqLite/jQuery's DOM destruction apis and fires this event</span>
<span class="Comment"> *    on all DOM nodes being removed.  This can be used to clean up any 3rd party bindings to the DOM</span>
<span class="Comment"> *    element before it is removed.</span>
<span class="Comment"> *</span>
<span class="Comment"> * ### Methods</span>
<span class="Comment"> * - `controller(name)` - retrieves the controller of the current element or its parent. By default</span>
<span class="Comment"> *   retrieves controller associated with the `ngController` directive. If `name` is provided as</span>
<span class="Comment"> *   camelCase directive name, then the controller for this directive will be retrieved (e.g.</span>
<span class="Comment"> *   `'ngModel'`).</span>
<span class="Comment"> * - `injector()` - retrieves the injector of the current element or its parent.</span>
<span class="Comment"> * - `scope()` - retrieves the {@link api/ng.$rootScope.Scope scope} of the current</span>
<span class="Comment"> *   element or its parent.</span>
<span class="Comment"> * - `isolateScope()` - retrieves an isolate {@link api/ng.$rootScope.Scope scope} if one is attached directly to the</span>
<span class="Comment"> *   current element. This getter should be used only on elements that contain a directive which starts a new isolate</span>
<span class="Comment"> *   scope. Calling `scope()` on this element always returns the original non-isolate scope.</span>
<span class="Comment"> * - `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top</span>
<span class="Comment"> *   parent element is reached.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string|DOMElement} element HTML string or DOMElement to be wrapped into jQuery.</span>
<span class="Comment"> * @returns {Object} jQuery object.</span>
<span class="Comment"> */</span>

<span class="Identifier">var</span> jqCache = JQLite.cache = <span class="Identifier">{}</span>,
    jqName = JQLite.expando = <span class="Constant">'ng-'</span> + <span class="Statement">new</span> <span class="Type">Date</span>().getTime(),
    jqId = 1,
    addEventListenerFn = (<span class="Statement">window</span>.<span class="Statement">document</span>.addEventListener
      ? <span class="Identifier">function</span>(element, type, fn) <span class="Identifier">{</span>element.addEventListener(type, fn, <span class="Constant">false</span>);<span class="Identifier">}</span>
      : <span class="Identifier">function</span>(element, type, fn) <span class="Identifier">{</span>element.attachEvent(<span class="Constant">'on'</span> + type, fn);<span class="Identifier">}</span>),
    removeEventListenerFn = (<span class="Statement">window</span>.<span class="Statement">document</span>.removeEventListener
      ? <span class="Identifier">function</span>(element, type, fn) <span class="Identifier">{</span>element.removeEventListener(type, fn, <span class="Constant">false</span>); <span class="Identifier">}</span>
      : <span class="Identifier">function</span>(element, type, fn) <span class="Identifier">{</span>element.detachEvent(<span class="Constant">'on'</span> + type, fn); <span class="Identifier">}</span>);

<span class="Identifier">function</span> jqNextId() <span class="Identifier">{</span> <span class="Statement">return</span> ++jqId; <span class="Identifier">}</span>


<span class="Identifier">var</span> SPECIAL_CHARS_REGEXP = <span class="Constant">/([\:\-\_]+(.))/g</span>;
<span class="Identifier">var</span> MOZ_HACK_REGEXP = <span class="Constant">/^moz([A-Z])/</span>;
<span class="Identifier">var</span> jqLiteMinErr = minErr(<span class="Constant">'jqLite'</span>);

<span class="Comment">/**</span>
<span class="Comment"> * Converts snake_case to camelCase.</span>
<span class="Comment"> * Also there is special case for Moz prefix starting with upper case letter.</span>
<span class="Comment"> * @param name Name to normalize</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> camelCase(name) <span class="Identifier">{</span>
  <span class="Statement">return</span> name.
    replace(SPECIAL_CHARS_REGEXP, <span class="Identifier">function</span>(_, separator, letter, offset) <span class="Identifier">{</span>
      <span class="Statement">return</span> offset ? letter.toUpperCase() : letter;
    <span class="Identifier">}</span>).
    replace(MOZ_HACK_REGEXP, <span class="Constant">'Moz$1'</span>);
<span class="Identifier">}</span>

<span class="Comment">/////////////////////////////////////////////</span>
<span class="Comment">// jQuery mutation patch</span>
<span class="Comment">//</span>
<span class="Comment">// In conjunction with bindJQuery intercepts all jQuery's DOM destruction apis and fires a</span>
<span class="Comment">// $destroy event on all DOM nodes being removed.</span>
<span class="Comment">//</span>
<span class="Comment">/////////////////////////////////////////////</span>

<span class="Identifier">function</span> jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) <span class="Identifier">{</span>
  <span class="Identifier">var</span> originalJqFn = jQuery.fn<span class="Identifier">[</span>name<span class="Identifier">]</span>;
  originalJqFn = originalJqFn.$original || originalJqFn;
  removePatch.$original = originalJqFn;
  jQuery.fn<span class="Identifier">[</span>name<span class="Identifier">]</span> = removePatch;

  <span class="Identifier">function</span> removePatch(param) <span class="Identifier">{</span>
    <span class="Comment">// jshint -W040</span>
    <span class="Identifier">var</span> list = filterElems &amp;&amp; param ? <span class="Identifier">[</span><span class="Identifier">this</span>.filter(param)<span class="Identifier">]</span> : <span class="Identifier">[</span><span class="Identifier">this</span><span class="Identifier">]</span>,
        fireEvent = dispatchThis,
        set, setIndex, setLength,
        element, childIndex, childLength, children;

    <span class="Statement">if</span> (!getterIfNoArguments || param != <span class="Statement">null</span>) <span class="Identifier">{</span>
      <span class="Statement">while</span>(list.length) <span class="Identifier">{</span>
        set = list.shift();
        <span class="Statement">for</span>(setIndex = 0, setLength = set.length; setIndex &lt; setLength; setIndex++) <span class="Identifier">{</span>
          element = jqLite(set<span class="Identifier">[</span>setIndex<span class="Identifier">]</span>);
          <span class="Statement">if</span> (fireEvent) <span class="Identifier">{</span>
            element.triggerHandler(<span class="Constant">'$destroy'</span>);
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            fireEvent = !fireEvent;
          <span class="Identifier">}</span>
          <span class="Statement">for</span>(childIndex = 0, childLength = (children = element.children()).length;
              childIndex &lt; childLength;
              childIndex++) <span class="Identifier">{</span>
            list.push(jQuery(children<span class="Identifier">[</span>childIndex<span class="Identifier">]</span>));
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
    <span class="Statement">return</span> originalJqFn.apply(<span class="Identifier">this</span>, <span class="Identifier">arguments</span>);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Comment">/////////////////////////////////////////////</span>
<span class="Identifier">function</span> JQLite(element) <span class="Identifier">{</span>
  <span class="Statement">if</span> (element <span class="Statement">instanceof</span> JQLite) <span class="Identifier">{</span>
    <span class="Statement">return</span> element;
  <span class="Identifier">}</span>
  <span class="Statement">if</span> (!(<span class="Identifier">this</span> <span class="Statement">instanceof</span> JQLite)) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isString(element) &amp;&amp; element.charAt(0) != <span class="Constant">'&lt;'</span>) <span class="Identifier">{</span>
      <span class="Statement">throw</span> jqLiteMinErr(<span class="Constant">'nosel'</span>, <span class="Constant">'Looking up elements via selectors is not supported by jqLite! See: <a href="http://docs.angularjs.org/api/angular.element">http://docs.angularjs.org/api/angular.element</a>'</span>);
    <span class="Identifier">}</span>
    <span class="Statement">return</span> <span class="Statement">new</span> JQLite(element);
  <span class="Identifier">}</span>

  <span class="Statement">if</span> (isString(element)) <span class="Identifier">{</span>
    <span class="Identifier">var</span> div = <span class="Statement">document</span>.createElement(<span class="Constant">'div'</span>);
    <span class="Comment">// Read about the NoScope elements here:</span>
    <span class="Comment">// <a href="http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx">http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx</a></span>
    div.innerHTML = <span class="Constant">'&lt;div&gt;&amp;#160;&lt;/div&gt;'</span> + element; <span class="Comment">// IE insanity to make NoScope elements work!</span>
    div.removeChild(div.firstChild); <span class="Comment">// remove the superfluous div</span>
    jqLiteAddNodes(<span class="Identifier">this</span>, div.childNodes);
    <span class="Identifier">var</span> fragment = jqLite(<span class="Statement">document</span>.createDocumentFragment());
    fragment.append(<span class="Identifier">this</span>); <span class="Comment">// detach the elements from the temporary DOM div.</span>
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
    jqLiteAddNodes(<span class="Identifier">this</span>, element);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Identifier">function</span> jqLiteClone(element) <span class="Identifier">{</span>
  <span class="Statement">return</span> element.cloneNode(<span class="Constant">true</span>);
<span class="Identifier">}</span>

<span class="Identifier">function</span> jqLiteDealoc(element)<span class="Identifier">{</span>
  jqLiteRemoveData(element);
  <span class="Statement">for</span> ( <span class="Identifier">var</span> i = 0, children = element.childNodes || <span class="Identifier">[]</span>; i &lt; children.length; i++) <span class="Identifier">{</span>
    jqLiteDealoc(children<span class="Identifier">[</span>i<span class="Identifier">]</span>);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Identifier">function</span> jqLiteOff(element, type, fn, unsupported) <span class="Identifier">{</span>
  <span class="Statement">if</span> (isDefined(unsupported)) <span class="Statement">throw</span> jqLiteMinErr(<span class="Constant">'offargs'</span>, <span class="Constant">'jqLite#off() does not support the `selector` argument'</span>);

  <span class="Identifier">var</span> events = jqLiteExpandoStore(element, <span class="Constant">'events'</span>),
      handle = jqLiteExpandoStore(element, <span class="Constant">'handle'</span>);

  <span class="Statement">if</span> (!handle) <span class="Statement">return</span>; <span class="Comment">//no listeners registered</span>

  <span class="Statement">if</span> (isUndefined(type)) <span class="Identifier">{</span>
    forEach(events, <span class="Identifier">function</span>(eventHandler, type) <span class="Identifier">{</span>
      removeEventListenerFn(element, type, eventHandler);
      <span class="Statement">delete</span> events<span class="Identifier">[</span>type<span class="Identifier">]</span>;
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
    forEach(type.split(<span class="Constant">' '</span>), <span class="Identifier">function</span>(type) <span class="Identifier">{</span>
      <span class="Statement">if</span> (isUndefined(fn)) <span class="Identifier">{</span>
        removeEventListenerFn(element, type, events<span class="Identifier">[</span>type<span class="Identifier">]</span>);
        <span class="Statement">delete</span> events<span class="Identifier">[</span>type<span class="Identifier">]</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        arrayRemove(events<span class="Identifier">[</span>type<span class="Identifier">]</span> || <span class="Identifier">[]</span>, fn);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Identifier">function</span> jqLiteRemoveData(element, name) <span class="Identifier">{</span>
  <span class="Identifier">var</span> expandoId = element<span class="Identifier">[</span>jqName<span class="Identifier">]</span>,
      expandoStore = jqCache<span class="Identifier">[</span>expandoId<span class="Identifier">]</span>;

  <span class="Statement">if</span> (expandoStore) <span class="Identifier">{</span>
    <span class="Statement">if</span> (name) <span class="Identifier">{</span>
      <span class="Statement">delete</span> jqCache<span class="Identifier">[</span>expandoId<span class="Identifier">]</span>.data<span class="Identifier">[</span>name<span class="Identifier">]</span>;
      <span class="Statement">return</span>;
    <span class="Identifier">}</span>

    <span class="Statement">if</span> (expandoStore.handle) <span class="Identifier">{</span>
      expandoStore.events.$destroy &amp;&amp; expandoStore.handle(<span class="Identifier">{}</span>, <span class="Constant">'$destroy'</span>);
      jqLiteOff(element);
    <span class="Identifier">}</span>
    <span class="Statement">delete</span> jqCache<span class="Identifier">[</span>expandoId<span class="Identifier">]</span>;
    element<span class="Identifier">[</span>jqName<span class="Identifier">]</span> = <span class="Statement">undefined</span>; <span class="Comment">// ie does not allow deletion of attributes on elements.</span>
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Identifier">function</span> jqLiteExpandoStore(element, key, value) <span class="Identifier">{</span>
  <span class="Identifier">var</span> expandoId = element<span class="Identifier">[</span>jqName<span class="Identifier">]</span>,
      expandoStore = jqCache<span class="Identifier">[</span>expandoId || -1<span class="Identifier">]</span>;

  <span class="Statement">if</span> (isDefined(value)) <span class="Identifier">{</span>
    <span class="Statement">if</span> (!expandoStore) <span class="Identifier">{</span>
      element<span class="Identifier">[</span>jqName<span class="Identifier">]</span> = expandoId = jqNextId();
      expandoStore = jqCache<span class="Identifier">[</span>expandoId<span class="Identifier">]</span> = <span class="Identifier">{}</span>;
    <span class="Identifier">}</span>
    expandoStore<span class="Identifier">[</span>key<span class="Identifier">]</span> = value;
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
    <span class="Statement">return</span> expandoStore &amp;&amp; expandoStore<span class="Identifier">[</span>key<span class="Identifier">]</span>;
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Identifier">function</span> jqLiteData(element, key, value) <span class="Identifier">{</span>
  <span class="Identifier">var</span> data = jqLiteExpandoStore(element, <span class="Constant">'data'</span>),
      isSetter = isDefined(value),
      keyDefined = !isSetter &amp;&amp; isDefined(key),
      isSimpleGetter = keyDefined &amp;&amp; !isObject(key);

  <span class="Statement">if</span> (!data &amp;&amp; !isSimpleGetter) <span class="Identifier">{</span>
    jqLiteExpandoStore(element, <span class="Constant">'data'</span>, data = <span class="Identifier">{}</span>);
  <span class="Identifier">}</span>

  <span class="Statement">if</span> (isSetter) <span class="Identifier">{</span>
    data<span class="Identifier">[</span>key<span class="Identifier">]</span> = value;
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
    <span class="Statement">if</span> (keyDefined) <span class="Identifier">{</span>
      <span class="Statement">if</span> (isSimpleGetter) <span class="Identifier">{</span>
        <span class="Comment">// don't create data in this case.</span>
        <span class="Statement">return</span> data &amp;&amp; data<span class="Identifier">[</span>key<span class="Identifier">]</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        extend(data, key);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> data;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Identifier">function</span> jqLiteHasClass(element, selector) <span class="Identifier">{</span>
  <span class="Statement">if</span> (!element.getAttribute) <span class="Statement">return</span> <span class="Constant">false</span>;
  <span class="Statement">return</span> ((<span class="Constant">&quot; &quot;</span> + (element.getAttribute(<span class="Constant">'class'</span>) || <span class="Constant">''</span>) + <span class="Constant">&quot; &quot;</span>).replace(<span class="Constant">/[\n\t]/g</span>, <span class="Constant">&quot; &quot;</span>).
      indexOf( <span class="Constant">&quot; &quot;</span> + selector + <span class="Constant">&quot; &quot;</span> ) &gt; -1);
<span class="Identifier">}</span>

<span class="Identifier">function</span> jqLiteRemoveClass(element, cssClasses) <span class="Identifier">{</span>
  <span class="Statement">if</span> (cssClasses &amp;&amp; element.setAttribute) <span class="Identifier">{</span>
    forEach(cssClasses.split(<span class="Constant">' '</span>), <span class="Identifier">function</span>(cssClass) <span class="Identifier">{</span>
      element.setAttribute(<span class="Constant">'class'</span>, trim(
          (<span class="Constant">&quot; &quot;</span> + (element.getAttribute(<span class="Constant">'class'</span>) || <span class="Constant">''</span>) + <span class="Constant">&quot; &quot;</span>)
          .replace(<span class="Constant">/[\n\t]/g</span>, <span class="Constant">&quot; &quot;</span>)
          .replace(<span class="Constant">&quot; &quot;</span> + trim(cssClass) + <span class="Constant">&quot; &quot;</span>, <span class="Constant">&quot; &quot;</span>))
      );
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Identifier">function</span> jqLiteAddClass(element, cssClasses) <span class="Identifier">{</span>
  <span class="Statement">if</span> (cssClasses &amp;&amp; element.setAttribute) <span class="Identifier">{</span>
    <span class="Identifier">var</span> existingClasses = (<span class="Constant">' '</span> + (element.getAttribute(<span class="Constant">'class'</span>) || <span class="Constant">''</span>) + <span class="Constant">' '</span>)
                            .replace(<span class="Constant">/[\n\t]/g</span>, <span class="Constant">&quot; &quot;</span>);

    forEach(cssClasses.split(<span class="Constant">' '</span>), <span class="Identifier">function</span>(cssClass) <span class="Identifier">{</span>
      cssClass = trim(cssClass);
      <span class="Statement">if</span> (existingClasses.indexOf(<span class="Constant">' '</span> + cssClass + <span class="Constant">' '</span>) === -1) <span class="Identifier">{</span>
        existingClasses += cssClass + <span class="Constant">' '</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>);

    element.setAttribute(<span class="Constant">'class'</span>, trim(existingClasses));
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Identifier">function</span> jqLiteAddNodes(root, elements) <span class="Identifier">{</span>
  <span class="Statement">if</span> (elements) <span class="Identifier">{</span>
    elements = (!elements.nodeName &amp;&amp; isDefined(elements.length) &amp;&amp; !isWindow(elements))
      ? elements
      : <span class="Identifier">[</span> elements <span class="Identifier">]</span>;
    <span class="Statement">for</span>(<span class="Identifier">var</span> i=0; i &lt; elements.length; i++) <span class="Identifier">{</span>
      root.push(elements<span class="Identifier">[</span>i<span class="Identifier">]</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Identifier">function</span> jqLiteController(element, name) <span class="Identifier">{</span>
  <span class="Statement">return</span> jqLiteInheritedData(element, <span class="Constant">'$'</span> + (name || <span class="Constant">'ngController'</span> ) + <span class="Constant">'Controller'</span>);
<span class="Identifier">}</span>

<span class="Identifier">function</span> jqLiteInheritedData(element, name, value) <span class="Identifier">{</span>
  element = jqLite(element);

  <span class="Comment">// if element is the document object work with the html element instead</span>
  <span class="Comment">// this makes $(document).scope() possible</span>
  <span class="Statement">if</span>(element<span class="Identifier">[</span>0<span class="Identifier">]</span>.nodeType == 9) <span class="Identifier">{</span>
    element = element.find(<span class="Constant">'html'</span>);
  <span class="Identifier">}</span>
  <span class="Identifier">var</span> names = isArray(name) ? name : <span class="Identifier">[</span>name<span class="Identifier">]</span>;

  <span class="Statement">while</span> (element.length) <span class="Identifier">{</span>

    <span class="Statement">for</span> (<span class="Identifier">var</span> i = 0, ii = names.length; i &lt; ii; i++) <span class="Identifier">{</span>
      <span class="Statement">if</span> ((value = element.data(names<span class="Identifier">[</span>i<span class="Identifier">]</span>)) !== <span class="Statement">undefined</span>) <span class="Statement">return</span> value;
    <span class="Identifier">}</span>
    element = element.<span class="Statement">parent</span>();
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Comment">//////////////////////////////////////////</span>
<span class="Comment">// Functions which are declared directly.</span>
<span class="Comment">//////////////////////////////////////////</span>
<span class="Identifier">var</span> JQLitePrototype = JQLite.prototype = <span class="Identifier">{</span>
  ready: <span class="Identifier">function</span>(fn) <span class="Identifier">{</span>
    <span class="Identifier">var</span> fired = <span class="Constant">false</span>;

    <span class="Identifier">function</span> trigger() <span class="Identifier">{</span>
      <span class="Statement">if</span> (fired) <span class="Statement">return</span>;
      fired = <span class="Constant">true</span>;
      fn();
    <span class="Identifier">}</span>

    <span class="Comment">// check if document already is loaded</span>
    <span class="Statement">if</span> (<span class="Statement">document</span>.readyState === <span class="Constant">'complete'</span>)<span class="Identifier">{</span>
      setTimeout(trigger);
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Identifier">this</span>.on(<span class="Constant">'DOMContentLoaded'</span>, trigger); <span class="Comment">// works for modern browsers and IE9</span>
      <span class="Comment">// we can not use jqLite since we are not done loading and jQuery could be loaded later.</span>
      <span class="Comment">// jshint -W064</span>
      JQLite(<span class="Statement">window</span>).on(<span class="Constant">'load'</span>, trigger); <span class="Comment">// fallback to window.onload for others</span>
      <span class="Comment">// jshint +W064</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>,
  toString: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> value = <span class="Identifier">[]</span>;
    forEach(<span class="Identifier">this</span>, <span class="Identifier">function</span>(e)<span class="Identifier">{</span> value.push(<span class="Constant">''</span> + e);<span class="Identifier">}</span>);
    <span class="Statement">return</span> <span class="Constant">'['</span> + value.join(<span class="Constant">', '</span>) + <span class="Constant">']'</span>;
  <span class="Identifier">}</span>,

  eq: <span class="Identifier">function</span>(index) <span class="Identifier">{</span>
      <span class="Statement">return</span> (index &gt;= 0) ? jqLite(<span class="Identifier">this</span><span class="Identifier">[</span>index<span class="Identifier">]</span>) : jqLite(<span class="Identifier">this</span><span class="Identifier">[</span><span class="Identifier">this</span>.length + index<span class="Identifier">]</span>);
  <span class="Identifier">}</span>,

  length: 0,
  push: push,
  sort: <span class="Identifier">[]</span>.sort,
  splice: <span class="Identifier">[]</span>.splice
<span class="Identifier">}</span>;

<span class="Comment">//////////////////////////////////////////</span>
<span class="Comment">// Functions iterating getter/setters.</span>
<span class="Comment">// these functions return self on setter and</span>
<span class="Comment">// value on get.</span>
<span class="Comment">//////////////////////////////////////////</span>
<span class="Identifier">var</span> BOOLEAN_ATTR = <span class="Identifier">{}</span>;
forEach(<span class="Constant">'multiple,selected,checked,disabled,readOnly,required,open'</span>.split(<span class="Constant">','</span>), <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
  BOOLEAN_ATTR<span class="Identifier">[</span>lowercase(value)<span class="Identifier">]</span> = value;
<span class="Identifier">}</span>);
<span class="Identifier">var</span> BOOLEAN_ELEMENTS = <span class="Identifier">{}</span>;
forEach(<span class="Constant">'input,select,option,textarea,button,form,details'</span>.split(<span class="Constant">','</span>), <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
  BOOLEAN_ELEMENTS<span class="Identifier">[</span>uppercase(value)<span class="Identifier">]</span> = <span class="Constant">true</span>;
<span class="Identifier">}</span>);

<span class="Identifier">function</span> getBooleanAttrName(element, name) <span class="Identifier">{</span>
  <span class="Comment">// check dom last since we will most likely fail on name</span>
  <span class="Identifier">var</span> booleanAttr = BOOLEAN_ATTR<span class="Identifier">[</span>name.toLowerCase()<span class="Identifier">]</span>;

  <span class="Comment">// booleanAttr is here twice to minimize DOM access</span>
  <span class="Statement">return</span> booleanAttr &amp;&amp; BOOLEAN_ELEMENTS<span class="Identifier">[</span>element.nodeName<span class="Identifier">]</span> &amp;&amp; booleanAttr;
<span class="Identifier">}</span>

forEach(<span class="Identifier">{</span>
  data: jqLiteData,
  inheritedData: jqLiteInheritedData,

  scope: <span class="Identifier">function</span>(element) <span class="Identifier">{</span>
    <span class="Comment">// Can't use jqLiteData here directly so we stay compatible with jQuery!</span>
    <span class="Statement">return</span> jqLite(element).data(<span class="Constant">'$scope'</span>) || jqLiteInheritedData(element.parentNode || element, <span class="Identifier">[</span><span class="Constant">'$isolateScope'</span>, <span class="Constant">'$scope'</span><span class="Identifier">]</span>);
  <span class="Identifier">}</span>,

  isolateScope: <span class="Identifier">function</span>(element) <span class="Identifier">{</span>
    <span class="Comment">// Can't use jqLiteData here directly so we stay compatible with jQuery!</span>
    <span class="Statement">return</span> jqLite(element).data(<span class="Constant">'$isolateScope'</span>) || jqLite(element).data(<span class="Constant">'$isolateScopeNoTemplate'</span>);
  <span class="Identifier">}</span>,

  controller: jqLiteController ,

  injector: <span class="Identifier">function</span>(element) <span class="Identifier">{</span>
    <span class="Statement">return</span> jqLiteInheritedData(element, <span class="Constant">'$injector'</span>);
  <span class="Identifier">}</span>,

  removeAttr: <span class="Identifier">function</span>(element,name) <span class="Identifier">{</span>
    element.removeAttribute(name);
  <span class="Identifier">}</span>,

  hasClass: jqLiteHasClass,

  css: <span class="Identifier">function</span>(element, name, value) <span class="Identifier">{</span>
    name = camelCase(name);

    <span class="Statement">if</span> (isDefined(value)) <span class="Identifier">{</span>
      element.style<span class="Identifier">[</span>name<span class="Identifier">]</span> = value;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Identifier">var</span> val;

      <span class="Statement">if</span> (msie &lt;= 8) <span class="Identifier">{</span>
        <span class="Comment">// this is some IE specific weirdness that jQuery 1.6.4 does not sure why</span>
        val = element.currentStyle &amp;&amp; element.currentStyle<span class="Identifier">[</span>name<span class="Identifier">]</span>;
        <span class="Statement">if</span> (val === <span class="Constant">''</span>) val = <span class="Constant">'auto'</span>;
      <span class="Identifier">}</span>

      val = val || element.style<span class="Identifier">[</span>name<span class="Identifier">]</span>;

      <span class="Statement">if</span> (msie &lt;= 8) <span class="Identifier">{</span>
        <span class="Comment">// jquery weirdness :-/</span>
        val = (val === <span class="Constant">''</span>) ? <span class="Statement">undefined</span> : val;
      <span class="Identifier">}</span>

      <span class="Statement">return</span>  val;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>,

  attr: <span class="Identifier">function</span>(element, name, value)<span class="Identifier">{</span>
    <span class="Identifier">var</span> lowercasedName = lowercase(name);
    <span class="Statement">if</span> (BOOLEAN_ATTR<span class="Identifier">[</span>lowercasedName<span class="Identifier">]</span>) <span class="Identifier">{</span>
      <span class="Statement">if</span> (isDefined(value)) <span class="Identifier">{</span>
        <span class="Statement">if</span> (!!value) <span class="Identifier">{</span>
          element<span class="Identifier">[</span>name<span class="Identifier">]</span> = <span class="Constant">true</span>;
          element.setAttribute(name, lowercasedName);
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          element<span class="Identifier">[</span>name<span class="Identifier">]</span> = <span class="Constant">false</span>;
          element.removeAttribute(lowercasedName);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">return</span> (element<span class="Identifier">[</span>name<span class="Identifier">]</span> ||
                 (element.attributes.getNamedItem(name)|| noop).specified)
               ? lowercasedName
               : <span class="Statement">undefined</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isDefined(value)) <span class="Identifier">{</span>
      element.setAttribute(name, value);
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (element.getAttribute) <span class="Identifier">{</span>
      <span class="Comment">// the extra argument &quot;2&quot; is to get the right thing for a.href in IE, see jQuery code</span>
      <span class="Comment">// some elements (e.g. Document) don't have get attribute, so return undefined</span>
      <span class="Identifier">var</span> ret = element.getAttribute(name, 2);
      <span class="Comment">// normalize non-existing attributes to undefined (as jQuery)</span>
      <span class="Statement">return</span> ret === <span class="Statement">null</span> ? <span class="Statement">undefined</span> : ret;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>,

  prop: <span class="Identifier">function</span>(element, name, value) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isDefined(value)) <span class="Identifier">{</span>
      element<span class="Identifier">[</span>name<span class="Identifier">]</span> = value;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> element<span class="Identifier">[</span>name<span class="Identifier">]</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>,

  text: (<span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> NODE_TYPE_TEXT_PROPERTY = <span class="Identifier">[]</span>;
    <span class="Statement">if</span> (msie &lt; 9) <span class="Identifier">{</span>
      NODE_TYPE_TEXT_PROPERTY<span class="Identifier">[</span>1<span class="Identifier">]</span> = <span class="Constant">'innerText'</span>;    <span class="Comment">/** Element **/</span>
      NODE_TYPE_TEXT_PROPERTY<span class="Identifier">[</span>3<span class="Identifier">]</span> = <span class="Constant">'nodeValue'</span>;    <span class="Comment">/** Text **/</span>
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      NODE_TYPE_TEXT_PROPERTY<span class="Identifier">[</span>1<span class="Identifier">]</span> =                 <span class="Comment">/** Element **/</span>
      NODE_TYPE_TEXT_PROPERTY<span class="Identifier">[</span>3<span class="Identifier">]</span> = <span class="Constant">'textContent'</span>;  <span class="Comment">/** Text **/</span>
    <span class="Identifier">}</span>
    getText.$dv = <span class="Constant">''</span>;
    <span class="Statement">return</span> getText;

    <span class="Identifier">function</span> getText(element, value) <span class="Identifier">{</span>
      <span class="Identifier">var</span> textProp = NODE_TYPE_TEXT_PROPERTY<span class="Identifier">[</span>element.nodeType<span class="Identifier">]</span>;
      <span class="Statement">if</span> (isUndefined(value)) <span class="Identifier">{</span>
        <span class="Statement">return</span> textProp ? element<span class="Identifier">[</span>textProp<span class="Identifier">]</span> : <span class="Constant">''</span>;
      <span class="Identifier">}</span>
      element<span class="Identifier">[</span>textProp<span class="Identifier">]</span> = value;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>)(),

  val: <span class="Identifier">function</span>(element, value) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isUndefined(value)) <span class="Identifier">{</span>
      <span class="Statement">if</span> (nodeName_(element) === <span class="Constant">'SELECT'</span> &amp;&amp; element.multiple) <span class="Identifier">{</span>
        <span class="Identifier">var</span> result = <span class="Identifier">[]</span>;
        forEach(element.options, <span class="Identifier">function</span> (option) <span class="Identifier">{</span>
          <span class="Statement">if</span> (option.selected) <span class="Identifier">{</span>
            result.push(option.value || option.text);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>);
        <span class="Statement">return</span> result.length === 0 ? <span class="Statement">null</span> : result;
      <span class="Identifier">}</span>
      <span class="Statement">return</span> element.value;
    <span class="Identifier">}</span>
    element.value = value;
  <span class="Identifier">}</span>,

  html: <span class="Identifier">function</span>(element, value) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isUndefined(value)) <span class="Identifier">{</span>
      <span class="Statement">return</span> element.innerHTML;
    <span class="Identifier">}</span>
    <span class="Statement">for</span> (<span class="Identifier">var</span> i = 0, childNodes = element.childNodes; i &lt; childNodes.length; i++) <span class="Identifier">{</span>
      jqLiteDealoc(childNodes<span class="Identifier">[</span>i<span class="Identifier">]</span>);
    <span class="Identifier">}</span>
    element.innerHTML = value;
  <span class="Identifier">}</span>
<span class="Identifier">}</span>, <span class="Identifier">function</span>(fn, name)<span class="Identifier">{</span>
  <span class="Comment">/**</span>
<span class="Comment">   * Properties: writes return selection, reads return first value</span>
<span class="Comment">   */</span>
  JQLite.prototype<span class="Identifier">[</span>name<span class="Identifier">]</span> = <span class="Identifier">function</span>(arg1, arg2) <span class="Identifier">{</span>
    <span class="Identifier">var</span> i, key;

    <span class="Comment">// jqLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it</span>
    <span class="Comment">// in a way that survives minification.</span>
    <span class="Statement">if</span> (((fn.length == 2 &amp;&amp; (fn !== jqLiteHasClass &amp;&amp; fn !== jqLiteController)) ? arg1 : arg2) === <span class="Statement">undefined</span>) <span class="Identifier">{</span>
      <span class="Statement">if</span> (isObject(arg1)) <span class="Identifier">{</span>

        <span class="Comment">// we are a write, but the object properties are the key/values</span>
        <span class="Statement">for</span>(i=0; i &lt; <span class="Identifier">this</span>.length; i++) <span class="Identifier">{</span>
          <span class="Statement">if</span> (fn === jqLiteData) <span class="Identifier">{</span>
            <span class="Comment">// data() takes the whole object in jQuery</span>
            fn(<span class="Identifier">this</span><span class="Identifier">[</span>i<span class="Identifier">]</span>, arg1);
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            <span class="Statement">for</span> (key <span class="Statement">in</span> arg1) <span class="Identifier">{</span>
              fn(<span class="Identifier">this</span><span class="Identifier">[</span>i<span class="Identifier">]</span>, key, arg1<span class="Identifier">[</span>key<span class="Identifier">]</span>);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
        <span class="Comment">// return self for chaining</span>
        <span class="Statement">return</span> <span class="Identifier">this</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Comment">// we are a read, so read the first child.</span>
        <span class="Identifier">var</span> value = fn.$dv;
        <span class="Comment">// Only if we have $dv do we iterate over all, otherwise it is just the first element.</span>
        <span class="Identifier">var</span> jj = (value === <span class="Statement">undefined</span>) ? Math.min(<span class="Identifier">this</span>.length, 1) : <span class="Identifier">this</span>.length;
        <span class="Statement">for</span> (<span class="Identifier">var</span> j = 0; j &lt; jj; j++) <span class="Identifier">{</span>
          <span class="Identifier">var</span> nodeValue = fn(<span class="Identifier">this</span><span class="Identifier">[</span>j<span class="Identifier">]</span>, arg1, arg2);
          value = value ? value + nodeValue : nodeValue;
        <span class="Identifier">}</span>
        <span class="Statement">return</span> value;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Comment">// we are a write, so apply to all children</span>
      <span class="Statement">for</span>(i=0; i &lt; <span class="Identifier">this</span>.length; i++) <span class="Identifier">{</span>
        fn(<span class="Identifier">this</span><span class="Identifier">[</span>i<span class="Identifier">]</span>, arg1, arg2);
      <span class="Identifier">}</span>
      <span class="Comment">// return self for chaining</span>
      <span class="Statement">return</span> <span class="Identifier">this</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>);

<span class="Identifier">function</span> createEventHandler(element, events) <span class="Identifier">{</span>
  <span class="Identifier">var</span> eventHandler = <span class="Identifier">function</span> (<span class="Statement">event</span>, type) <span class="Identifier">{</span>
    <span class="Statement">if</span> (!<span class="Statement">event</span>.preventDefault) <span class="Identifier">{</span>
      <span class="Statement">event</span>.preventDefault = <span class="Identifier">function</span>() <span class="Identifier">{</span>
        <span class="Statement">event</span>.returnValue = <span class="Constant">false</span>; <span class="Comment">//ie</span>
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>

    <span class="Statement">if</span> (!<span class="Statement">event</span>.stopPropagation) <span class="Identifier">{</span>
      <span class="Statement">event</span>.stopPropagation = <span class="Identifier">function</span>() <span class="Identifier">{</span>
        <span class="Statement">event</span>.cancelBubble = <span class="Constant">true</span>; <span class="Comment">//ie</span>
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>

    <span class="Statement">if</span> (!<span class="Statement">event</span>.target) <span class="Identifier">{</span>
      <span class="Statement">event</span>.target = <span class="Statement">event</span>.srcElement || <span class="Statement">document</span>;
    <span class="Identifier">}</span>

    <span class="Statement">if</span> (isUndefined(<span class="Statement">event</span>.defaultPrevented)) <span class="Identifier">{</span>
      <span class="Identifier">var</span> prevent = <span class="Statement">event</span>.preventDefault;
      <span class="Statement">event</span>.preventDefault = <span class="Identifier">function</span>() <span class="Identifier">{</span>
        <span class="Statement">event</span>.defaultPrevented = <span class="Constant">true</span>;
        prevent.call(<span class="Statement">event</span>);
      <span class="Identifier">}</span>;
      <span class="Statement">event</span>.defaultPrevented = <span class="Constant">false</span>;
    <span class="Identifier">}</span>

    <span class="Statement">event</span>.isDefaultPrevented = <span class="Identifier">function</span>() <span class="Identifier">{</span>
      <span class="Statement">return</span> <span class="Statement">event</span>.defaultPrevented || <span class="Statement">event</span>.returnValue === <span class="Constant">false</span>;
    <span class="Identifier">}</span>;

    forEach(events<span class="Identifier">[</span>type || <span class="Statement">event</span>.type<span class="Identifier">]</span>, <span class="Identifier">function</span>(fn) <span class="Identifier">{</span>
      fn.call(element, <span class="Statement">event</span>);
    <span class="Identifier">}</span>);

    <span class="Comment">// Remove monkey-patched methods (IE),</span>
    <span class="Comment">// as they would cause memory leaks in IE8.</span>
    <span class="Statement">if</span> (msie &lt;= 8) <span class="Identifier">{</span>
      <span class="Comment">// IE7/8 does not allow to delete property on native object</span>
      <span class="Statement">event</span>.preventDefault = <span class="Statement">null</span>;
      <span class="Statement">event</span>.stopPropagation = <span class="Statement">null</span>;
      <span class="Statement">event</span>.isDefaultPrevented = <span class="Statement">null</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Comment">// It shouldn't affect normal browsers (native methods are defined on prototype).</span>
      <span class="Statement">delete</span> <span class="Statement">event</span>.preventDefault;
      <span class="Statement">delete</span> <span class="Statement">event</span>.stopPropagation;
      <span class="Statement">delete</span> <span class="Statement">event</span>.isDefaultPrevented;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
  eventHandler.elem = element;
  <span class="Statement">return</span> eventHandler;
<span class="Identifier">}</span>

<span class="Comment">//////////////////////////////////////////</span>
<span class="Comment">// Functions iterating traversal.</span>
<span class="Comment">// These functions chain results into a single</span>
<span class="Comment">// selector.</span>
<span class="Comment">//////////////////////////////////////////</span>
forEach(<span class="Identifier">{</span>
  removeData: jqLiteRemoveData,

  dealoc: jqLiteDealoc,

  on: <span class="Identifier">function</span> onFn(element, type, fn, unsupported)<span class="Identifier">{</span>
    <span class="Statement">if</span> (isDefined(unsupported)) <span class="Statement">throw</span> jqLiteMinErr(<span class="Constant">'onargs'</span>, <span class="Constant">'jqLite#on() does not support the `selector` or `eventData` parameters'</span>);

    <span class="Identifier">var</span> events = jqLiteExpandoStore(element, <span class="Constant">'events'</span>),
        handle = jqLiteExpandoStore(element, <span class="Constant">'handle'</span>);

    <span class="Statement">if</span> (!events) jqLiteExpandoStore(element, <span class="Constant">'events'</span>, events = <span class="Identifier">{}</span>);
    <span class="Statement">if</span> (!handle) jqLiteExpandoStore(element, <span class="Constant">'handle'</span>, handle = createEventHandler(element, events));

    forEach(type.split(<span class="Constant">' '</span>), <span class="Identifier">function</span>(type)<span class="Identifier">{</span>
      <span class="Identifier">var</span> eventFns = events<span class="Identifier">[</span>type<span class="Identifier">]</span>;

      <span class="Statement">if</span> (!eventFns) <span class="Identifier">{</span>
        <span class="Statement">if</span> (type == <span class="Constant">'mouseenter'</span> || type == <span class="Constant">'mouseleave'</span>) <span class="Identifier">{</span>
          <span class="Identifier">var</span> contains = <span class="Statement">document</span>.body.contains || <span class="Statement">document</span>.body.compareDocumentPosition ?
          <span class="Identifier">function</span>( a, b ) <span class="Identifier">{</span>
            <span class="Comment">// jshint bitwise: false</span>
            <span class="Identifier">var</span> adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b &amp;&amp; b.parentNode;
            <span class="Statement">return</span> a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (
              adown.contains ?
              adown.contains( bup ) :
              a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16
              ));
            <span class="Identifier">}</span> :
            <span class="Identifier">function</span>( a, b ) <span class="Identifier">{</span>
              <span class="Statement">if</span> ( b ) <span class="Identifier">{</span>
                <span class="Statement">while</span> ( (b = b.parentNode) ) <span class="Identifier">{</span>
                  <span class="Statement">if</span> ( b === a ) <span class="Identifier">{</span>
                    <span class="Statement">return</span> <span class="Constant">true</span>;
                  <span class="Identifier">}</span>
                <span class="Identifier">}</span>
              <span class="Identifier">}</span>
              <span class="Statement">return</span> <span class="Constant">false</span>;
            <span class="Identifier">}</span>;

          events<span class="Identifier">[</span>type<span class="Identifier">]</span> = <span class="Identifier">[]</span>;

          <span class="Comment">// Refer to jQuery's implementation of mouseenter &amp; mouseleave</span>
          <span class="Comment">// Read about mouseenter and mouseleave:</span>
          <span class="Comment">// <a href="http://www.quirksmode.org/js/events_mouse.html#link8">http://www.quirksmode.org/js/events_mouse.html#link8</a></span>
          <span class="Identifier">var</span> eventmap = <span class="Identifier">{</span> mouseleave : <span class="Constant">&quot;mouseout&quot;</span>, mouseenter : <span class="Constant">&quot;mouseover&quot;</span><span class="Identifier">}</span>;

          onFn(element, eventmap<span class="Identifier">[</span>type<span class="Identifier">]</span>, <span class="Identifier">function</span>(<span class="Statement">event</span>) <span class="Identifier">{</span>
            <span class="Identifier">var</span> target = <span class="Identifier">this</span>, related = <span class="Statement">event</span>.relatedTarget;
            <span class="Comment">// For mousenter/leave call the handler if related is outside the target.</span>
            <span class="Comment">// NB: No relatedTarget if the mouse left/entered the browser window</span>
            <span class="Statement">if</span> ( !related || (related !== target &amp;&amp; !contains(target, related)) )<span class="Identifier">{</span>
              handle(<span class="Statement">event</span>, type);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>);

        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          addEventListenerFn(element, type, handle);
          events<span class="Identifier">[</span>type<span class="Identifier">]</span> = <span class="Identifier">[]</span>;
        <span class="Identifier">}</span>
        eventFns = events<span class="Identifier">[</span>type<span class="Identifier">]</span>;
      <span class="Identifier">}</span>
      eventFns.push(fn);
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>,

  off: jqLiteOff,

  replaceWith: <span class="Identifier">function</span>(element, replaceNode) <span class="Identifier">{</span>
    <span class="Identifier">var</span> index, <span class="Statement">parent</span> = element.parentNode;
    jqLiteDealoc(element);
    forEach(<span class="Statement">new</span> JQLite(replaceNode), <span class="Identifier">function</span>(node)<span class="Identifier">{</span>
      <span class="Statement">if</span> (index) <span class="Identifier">{</span>
        <span class="Statement">parent</span>.insertBefore(node, index.nextSibling);
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">parent</span>.replaceChild(node, element);
      <span class="Identifier">}</span>
      index = node;
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>,

  children: <span class="Identifier">function</span>(element) <span class="Identifier">{</span>
    <span class="Identifier">var</span> children = <span class="Identifier">[]</span>;
    forEach(element.childNodes, <span class="Identifier">function</span>(element)<span class="Identifier">{</span>
      <span class="Statement">if</span> (element.nodeType === 1)
        children.push(element);
    <span class="Identifier">}</span>);
    <span class="Statement">return</span> children;
  <span class="Identifier">}</span>,

  contents: <span class="Identifier">function</span>(element) <span class="Identifier">{</span>
    <span class="Statement">return</span> element.childNodes || <span class="Identifier">[]</span>;
  <span class="Identifier">}</span>,

  append: <span class="Identifier">function</span>(element, node) <span class="Identifier">{</span>
    forEach(<span class="Statement">new</span> JQLite(node), <span class="Identifier">function</span>(child)<span class="Identifier">{</span>
      <span class="Statement">if</span> (element.nodeType === 1 || element.nodeType === 11) <span class="Identifier">{</span>
        element.appendChild(child);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>,

  prepend: <span class="Identifier">function</span>(element, node) <span class="Identifier">{</span>
    <span class="Statement">if</span> (element.nodeType === 1) <span class="Identifier">{</span>
      <span class="Identifier">var</span> index = element.firstChild;
      forEach(<span class="Statement">new</span> JQLite(node), <span class="Identifier">function</span>(child)<span class="Identifier">{</span>
        element.insertBefore(child, index);
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>,

  wrap: <span class="Identifier">function</span>(element, wrapNode) <span class="Identifier">{</span>
    wrapNode = jqLite(wrapNode)<span class="Identifier">[</span>0<span class="Identifier">]</span>;
    <span class="Identifier">var</span> <span class="Statement">parent</span> = element.parentNode;
    <span class="Statement">if</span> (<span class="Statement">parent</span>) <span class="Identifier">{</span>
      <span class="Statement">parent</span>.replaceChild(wrapNode, element);
    <span class="Identifier">}</span>
    wrapNode.appendChild(element);
  <span class="Identifier">}</span>,

  remove: <span class="Identifier">function</span>(element) <span class="Identifier">{</span>
    jqLiteDealoc(element);
    <span class="Identifier">var</span> <span class="Statement">parent</span> = element.parentNode;
    <span class="Statement">if</span> (<span class="Statement">parent</span>) <span class="Statement">parent</span>.removeChild(element);
  <span class="Identifier">}</span>,

  after: <span class="Identifier">function</span>(element, newElement) <span class="Identifier">{</span>
    <span class="Identifier">var</span> index = element, <span class="Statement">parent</span> = element.parentNode;
    forEach(<span class="Statement">new</span> JQLite(newElement), <span class="Identifier">function</span>(node)<span class="Identifier">{</span>
      <span class="Statement">parent</span>.insertBefore(node, index.nextSibling);
      index = node;
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>,

  addClass: jqLiteAddClass,
  removeClass: jqLiteRemoveClass,

  toggleClass: <span class="Identifier">function</span>(element, selector, condition) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isUndefined(condition)) <span class="Identifier">{</span>
      condition = !jqLiteHasClass(element, selector);
    <span class="Identifier">}</span>
    (condition ? jqLiteAddClass : jqLiteRemoveClass)(element, selector);
  <span class="Identifier">}</span>,

  <span class="Statement">parent</span>: <span class="Identifier">function</span>(element) <span class="Identifier">{</span>
    <span class="Identifier">var</span> <span class="Statement">parent</span> = element.parentNode;
    <span class="Statement">return</span> <span class="Statement">parent</span> &amp;&amp; <span class="Statement">parent</span>.nodeType !== 11 ? <span class="Statement">parent</span> : <span class="Statement">null</span>;
  <span class="Identifier">}</span>,

  next: <span class="Identifier">function</span>(element) <span class="Identifier">{</span>
    <span class="Statement">if</span> (element.nextElementSibling) <span class="Identifier">{</span>
      <span class="Statement">return</span> element.nextElementSibling;
    <span class="Identifier">}</span>

    <span class="Comment">// IE8 doesn't have nextElementSibling</span>
    <span class="Identifier">var</span> elm = element.nextSibling;
    <span class="Statement">while</span> (elm != <span class="Statement">null</span> &amp;&amp; elm.nodeType !== 1) <span class="Identifier">{</span>
      elm = elm.nextSibling;
    <span class="Identifier">}</span>
    <span class="Statement">return</span> elm;
  <span class="Identifier">}</span>,

  find: <span class="Identifier">function</span>(element, selector) <span class="Identifier">{</span>
    <span class="Statement">if</span> (element.getElementsByTagName) <span class="Identifier">{</span>
      <span class="Statement">return</span> element.getElementsByTagName(selector);
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> <span class="Identifier">[]</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>,

  clone: jqLiteClone,

  triggerHandler: <span class="Identifier">function</span>(element, eventName, eventData) <span class="Identifier">{</span>
    <span class="Identifier">var</span> eventFns = (jqLiteExpandoStore(element, <span class="Constant">'events'</span>) || <span class="Identifier">{}</span>)<span class="Identifier">[</span>eventName<span class="Identifier">]</span>;

    eventData = eventData || <span class="Identifier">[]</span>;

    <span class="Identifier">var</span> <span class="Statement">event</span> = <span class="Identifier">[{</span>
      preventDefault: noop,
      stopPropagation: noop
    <span class="Identifier">}]</span>;

    forEach(eventFns, <span class="Identifier">function</span>(fn) <span class="Identifier">{</span>
      fn.apply(element, <span class="Statement">event</span>.concat(eventData));
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>, <span class="Identifier">function</span>(fn, name)<span class="Identifier">{</span>
  <span class="Comment">/**</span>
<span class="Comment">   * chaining functions</span>
<span class="Comment">   */</span>
  JQLite.prototype<span class="Identifier">[</span>name<span class="Identifier">]</span> = <span class="Identifier">function</span>(arg1, arg2, arg3) <span class="Identifier">{</span>
    <span class="Identifier">var</span> value;
    <span class="Statement">for</span>(<span class="Identifier">var</span> i=0; i &lt; <span class="Identifier">this</span>.length; i++) <span class="Identifier">{</span>
      <span class="Statement">if</span> (isUndefined(value)) <span class="Identifier">{</span>
        value = fn(<span class="Identifier">this</span><span class="Identifier">[</span>i<span class="Identifier">]</span>, arg1, arg2, arg3);
        <span class="Statement">if</span> (isDefined(value)) <span class="Identifier">{</span>
          <span class="Comment">// any function which returns a value needs to be wrapped</span>
          value = jqLite(value);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        jqLiteAddNodes(value, fn(<span class="Identifier">this</span><span class="Identifier">[</span>i<span class="Identifier">]</span>, arg1, arg2, arg3));
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
    <span class="Statement">return</span> isDefined(value) ? value : <span class="Identifier">this</span>;
  <span class="Identifier">}</span>;

  <span class="Comment">// bind legacy bind/unbind to on/off</span>
  JQLite.prototype.bind = JQLite.prototype.on;
  JQLite.prototype.unbind = JQLite.prototype.off;
<span class="Identifier">}</span>);

<span class="Comment">/**</span>
<span class="Comment"> * Computes a hash of an 'obj'.</span>
<span class="Comment"> * Hash of a:</span>
<span class="Comment"> *  string is string</span>
<span class="Comment"> *  number is number as string</span>
<span class="Comment"> *  object is either result of calling $$hashKey function on the object or uniquely generated id,</span>
<span class="Comment"> *         that is also assigned to the $$hashKey property of the object.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param obj</span>
<span class="Comment"> * @returns {string} hash string such that the same input will have the same hash string.</span>
<span class="Comment"> *         The resulting string key is in 'type:hashKey' format.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> hashKey(obj) <span class="Identifier">{</span>
  <span class="Identifier">var</span> objType = <span class="Statement">typeof</span> obj,
      key;

  <span class="Statement">if</span> (objType == <span class="Constant">'object'</span> &amp;&amp; obj !== <span class="Statement">null</span>) <span class="Identifier">{</span>
    <span class="Statement">if</span> (<span class="Statement">typeof</span> (key = obj.$$hashKey) == <span class="Constant">'function'</span>) <span class="Identifier">{</span>
      <span class="Comment">// must invoke on object to keep the right this</span>
      key = obj.$$hashKey();
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (key === <span class="Statement">undefined</span>) <span class="Identifier">{</span>
      key = obj.$$hashKey = nextUid();
    <span class="Identifier">}</span>
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
    key = obj;
  <span class="Identifier">}</span>

  <span class="Statement">return</span> objType + <span class="Constant">':'</span> + key;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * HashMap which can use objects as keys</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> HashMap(array)<span class="Identifier">{</span>
  forEach(array, <span class="Identifier">this</span>.put, <span class="Identifier">this</span>);
<span class="Identifier">}</span>
HashMap.prototype = <span class="Identifier">{</span>
  <span class="Comment">/**</span>
<span class="Comment">   * Store key value pair</span>
<span class="Comment">   * @param key key to store can be any type</span>
<span class="Comment">   * @param value value to store can be any type</span>
<span class="Comment">   */</span>
  put: <span class="Identifier">function</span>(key, value) <span class="Identifier">{</span>
    <span class="Identifier">this</span><span class="Identifier">[</span>hashKey(key)<span class="Identifier">]</span> = value;
  <span class="Identifier">}</span>,

  <span class="Comment">/**</span>
<span class="Comment">   * @param key</span>
<span class="Comment">   * @returns the value for the key</span>
<span class="Comment">   */</span>
  get: <span class="Identifier">function</span>(key) <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">this</span><span class="Identifier">[</span>hashKey(key)<span class="Identifier">]</span>;
  <span class="Identifier">}</span>,

  <span class="Comment">/**</span>
<span class="Comment">   * Remove the key/value pair</span>
<span class="Comment">   * @param key</span>
<span class="Comment">   */</span>
  remove: <span class="Identifier">function</span>(key) <span class="Identifier">{</span>
    <span class="Identifier">var</span> value = <span class="Identifier">this</span><span class="Identifier">[</span>key = hashKey(key)<span class="Identifier">]</span>;
    <span class="Statement">delete</span> <span class="Identifier">this</span><span class="Identifier">[</span>key<span class="Identifier">]</span>;
    <span class="Statement">return</span> value;
  <span class="Identifier">}</span>
<span class="Identifier">}</span>;

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name angular.injector</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Creates an injector function that can be used for retrieving services as well as for</span>
<span class="Comment"> * dependency injection (see {@link guide/di dependency injection}).</span>
<span class="Comment"> *</span>

<span class="Comment"> * @param {Array.&lt;string|Function&gt;} modules A list of module functions or their aliases. See</span>
<span class="Comment"> *        {@link angular.module}. The `ng` module must be explicitly added.</span>
<span class="Comment"> * @returns {function()} Injector function. See {@link AUTO.$injector $injector}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * Typical usage</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   // create an injector</span>
<span class="Comment"> *   var $injector = angular.injector(['ng']);</span>
<span class="Comment"> *</span>
<span class="Comment"> *   // use the injector to kick off your application</span>
<span class="Comment"> *   // use the type inference to auto inject arguments, or use implicit injection</span>
<span class="Comment"> *   $injector.invoke(function($rootScope, $compile, $document){</span>
<span class="Comment"> *     $compile($document)($rootScope);</span>
<span class="Comment"> *     $rootScope.$digest();</span>
<span class="Comment"> *   });</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc overview</span>
<span class="Comment"> * @name AUTO</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Implicit module which gets automatically added to each {@link AUTO.$injector $injector}.</span>
<span class="Comment"> */</span>

<span class="Identifier">var</span> FN_ARGS = <span class="Constant">/^function\s*[^\(]*\(\s*([^\)]*)\)/m</span>;
<span class="Identifier">var</span> FN_ARG_SPLIT = <span class="Constant">/,/</span>;
<span class="Identifier">var</span> FN_ARG = <span class="Constant">/^\s*(_?)(\S+?)\1\s*$/</span>;
<span class="Identifier">var</span> STRIP_COMMENTS = <span class="Constant">/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg</span>;
<span class="Identifier">var</span> $injectorMinErr = minErr(<span class="Constant">'$injector'</span>);
<span class="Identifier">function</span> annotate(fn) <span class="Identifier">{</span>
  <span class="Identifier">var</span> $inject,
      fnText,
      argDecl,
      last;

  <span class="Statement">if</span> (<span class="Statement">typeof</span> fn == <span class="Constant">'function'</span>) <span class="Identifier">{</span>
    <span class="Statement">if</span> (!($inject = fn.$inject)) <span class="Identifier">{</span>
      $inject = <span class="Identifier">[]</span>;
      <span class="Statement">if</span> (fn.length) <span class="Identifier">{</span>
        fnText = fn.toString().replace(STRIP_COMMENTS, <span class="Constant">''</span>);
        argDecl = fnText.match(FN_ARGS);
        forEach(argDecl<span class="Identifier">[</span>1<span class="Identifier">]</span>.split(FN_ARG_SPLIT), <span class="Identifier">function</span>(arg)<span class="Identifier">{</span>
          arg.replace(FN_ARG, <span class="Identifier">function</span>(all, underscore, name)<span class="Identifier">{</span>
            $inject.push(name);
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>);
      <span class="Identifier">}</span>
      fn.$inject = $inject;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isArray(fn)) <span class="Identifier">{</span>
    last = fn.length - 1;
    assertArgFn(fn<span class="Identifier">[</span>last<span class="Identifier">]</span>, <span class="Constant">'fn'</span>);
    $inject = fn.slice(0, last);
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
    assertArgFn(fn, <span class="Constant">'fn'</span>, <span class="Constant">true</span>);
  <span class="Identifier">}</span>
  <span class="Statement">return</span> $inject;
<span class="Identifier">}</span>

<span class="Comment">///////////////////////////////////////</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name AUTO.$injector</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * `$injector` is used to retrieve object instances as defined by</span>
<span class="Comment"> * {@link AUTO.$provide provider}, instantiate types, invoke methods,</span>
<span class="Comment"> * and load modules.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The following always holds true:</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   var $injector = angular.injector();</span>
<span class="Comment"> *   expect($injector.get('$injector')).toBe($injector);</span>
<span class="Comment"> *   expect($injector.invoke(function($injector){</span>
<span class="Comment"> *     return $injector;</span>
<span class="Comment"> *   }).toBe($injector);</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * # Injection Function Annotation</span>
<span class="Comment"> *</span>
<span class="Comment"> * JavaScript does not have annotations, and annotations are needed for dependency injection. The</span>
<span class="Comment"> * following are all valid ways of annotating function with injection arguments and are equivalent.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   // inferred (only works if code not minified/obfuscated)</span>
<span class="Comment"> *   $injector.invoke(function(serviceA){});</span>
<span class="Comment"> *</span>
<span class="Comment"> *   // annotated</span>
<span class="Comment"> *   function explicit(serviceA) {};</span>
<span class="Comment"> *   explicit.$inject = ['serviceA'];</span>
<span class="Comment"> *   $injector.invoke(explicit);</span>
<span class="Comment"> *</span>
<span class="Comment"> *   // inline</span>
<span class="Comment"> *   $injector.invoke(['serviceA', function(serviceA){}]);</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## Inference</span>
<span class="Comment"> *</span>
<span class="Comment"> * In JavaScript calling `toString()` on a function returns the function definition. The definition</span>
<span class="Comment"> * can then be parsed and the function arguments can be extracted. *NOTE:* This does not work with</span>
<span class="Comment"> * minification, and obfuscation tools since these tools change the argument names.</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## `$inject` Annotation</span>
<span class="Comment"> * By adding a `$inject` property onto a function the injection parameters can be specified.</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## Inline</span>
<span class="Comment"> * As an array of injection names, where the last item in the array is the function to call.</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc method</span>
<span class="Comment"> * @name AUTO.$injector#get</span>
<span class="Comment"> * @methodOf AUTO.$injector</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Return an instance of the service.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} name The name of the instance to retrieve.</span>
<span class="Comment"> * @return {*} The instance.</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc method</span>
<span class="Comment"> * @name AUTO.$injector#invoke</span>
<span class="Comment"> * @methodOf AUTO.$injector</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Invoke the method and supply the method arguments from the `$injector`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {!function} fn The function to invoke. Function parameters are injected according to the</span>
<span class="Comment"> *   {@link guide/di $inject Annotation} rules.</span>
<span class="Comment"> * @param {Object=} self The `this` for the invoked method.</span>
<span class="Comment"> * @param {Object=} locals Optional object. If preset then any argument names are read from this</span>
<span class="Comment"> *                         object first, before the `$injector` is consulted.</span>
<span class="Comment"> * @returns {*} the value returned by the invoked `fn` function.</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc method</span>
<span class="Comment"> * @name AUTO.$injector#has</span>
<span class="Comment"> * @methodOf AUTO.$injector</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Allows the user to query if the particular service exist.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} Name of the service to query.</span>
<span class="Comment"> * @returns {boolean} returns true if injector has given service.</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc method</span>
<span class="Comment"> * @name AUTO.$injector#instantiate</span>
<span class="Comment"> * @methodOf AUTO.$injector</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Create a new instance of JS type. The method takes a constructor function invokes the new</span>
<span class="Comment"> * operator and supplies all of the arguments to the constructor function as specified by the</span>
<span class="Comment"> * constructor annotation.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {function} Type Annotated constructor function.</span>
<span class="Comment"> * @param {Object=} locals Optional object. If preset then any argument names are read from this</span>
<span class="Comment"> * object first, before the `$injector` is consulted.</span>
<span class="Comment"> * @returns {Object} new instance of `Type`.</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc method</span>
<span class="Comment"> * @name AUTO.$injector#annotate</span>
<span class="Comment"> * @methodOf AUTO.$injector</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Returns an array of service names which the function is requesting for injection. This API is</span>
<span class="Comment"> * used by the injector to determine which services need to be injected into the function when the</span>
<span class="Comment"> * function is invoked. There are three ways in which the function can be annotated with the needed</span>
<span class="Comment"> * dependencies.</span>
<span class="Comment"> *</span>
<span class="Comment"> * # Argument names</span>
<span class="Comment"> *</span>
<span class="Comment"> * The simplest form is to extract the dependencies from the arguments of the function. This is done</span>
<span class="Comment"> * by converting the function into a string using `toString()` method and extracting the argument</span>
<span class="Comment"> * names.</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   // Given</span>
<span class="Comment"> *   function MyController($scope, $route) {</span>
<span class="Comment"> *     // ...</span>
<span class="Comment"> *   }</span>
<span class="Comment"> *</span>
<span class="Comment"> *   // Then</span>
<span class="Comment"> *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * This method does not work with code minification / obfuscation. For this reason the following</span>
<span class="Comment"> * annotation strategies are supported.</span>
<span class="Comment"> *</span>
<span class="Comment"> * # The `$inject` property</span>
<span class="Comment"> *</span>
<span class="Comment"> * If a function has an `$inject` property and its value is an array of strings, then the strings</span>
<span class="Comment"> * represent names of services to be injected into the function.</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   // Given</span>
<span class="Comment"> *   var MyController = function(obfuscatedScope, obfuscatedRoute) {</span>
<span class="Comment"> *     // ...</span>
<span class="Comment"> *   }</span>
<span class="Comment"> *   // Define function dependencies</span>
<span class="Comment"> *   MyController['$inject'] = ['$scope', '$route'];</span>
<span class="Comment"> *</span>
<span class="Comment"> *   // Then</span>
<span class="Comment"> *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * # The array notation</span>
<span class="Comment"> *</span>
<span class="Comment"> * It is often desirable to inline Injected functions and that's when setting the `$inject` property</span>
<span class="Comment"> * is very inconvenient. In these situations using the array notation to specify the dependencies in</span>
<span class="Comment"> * a way that survives minification is a better choice:</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   // We wish to write this (not minification / obfuscation safe)</span>
<span class="Comment"> *   injector.invoke(function($compile, $rootScope) {</span>
<span class="Comment"> *     // ...</span>
<span class="Comment"> *   });</span>
<span class="Comment"> *</span>
<span class="Comment"> *   // We are forced to write break inlining</span>
<span class="Comment"> *   var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {</span>
<span class="Comment"> *     // ...</span>
<span class="Comment"> *   };</span>
<span class="Comment"> *   tmpFn.$inject = ['$compile', '$rootScope'];</span>
<span class="Comment"> *   injector.invoke(tmpFn);</span>
<span class="Comment"> *</span>
<span class="Comment"> *   // To better support inline function the inline annotation is supported</span>
<span class="Comment"> *   injector.invoke(['$compile', '$rootScope', function(obfCompile, obfRootScope) {</span>
<span class="Comment"> *     // ...</span>
<span class="Comment"> *   }]);</span>
<span class="Comment"> *</span>
<span class="Comment"> *   // Therefore</span>
<span class="Comment"> *   expect(injector.annotate(</span>
<span class="Comment"> *      ['$compile', '$rootScope', function(obfus_$compile, obfus_$rootScope) {}])</span>
<span class="Comment"> *    ).toEqual(['$compile', '$rootScope']);</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {function|Array.&lt;string|Function&gt;} fn Function for which dependent service names need to</span>
<span class="Comment"> * be retrieved as described above.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @returns {Array.&lt;string&gt;} The names of the services which the function requires.</span>
<span class="Comment"> */</span>




<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name AUTO.$provide</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * The {@link AUTO.$provide $provide} service has a number of methods for registering components</span>
<span class="Comment"> * with the {@link AUTO.$injector $injector}. Many of these functions are also exposed on</span>
<span class="Comment"> * {@link angular.Module}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * An Angular **service** is a singleton object created by a **service factory**.  These **service</span>
<span class="Comment"> * factories** are functions which, in turn, are created by a **service provider**.</span>
<span class="Comment"> * The **service providers** are constructor functions. When instantiated they must contain a</span>
<span class="Comment"> * property called `$get`, which holds the **service factory** function.</span>
<span class="Comment"> *</span>
<span class="Comment"> * When you request a service, the {@link AUTO.$injector $injector} is responsible for finding the</span>
<span class="Comment"> * correct **service provider**, instantiating it and then calling its `$get` **service factory**</span>
<span class="Comment"> * function to get the instance of the **service**.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Often services have no configuration options and there is no need to add methods to the service</span>
<span class="Comment"> * provider.  The provider will be no more than a constructor function with a `$get` property. For</span>
<span class="Comment"> * these cases the {@link AUTO.$provide $provide} service has additional helper methods to register</span>
<span class="Comment"> * services without specifying a provider.</span>
<span class="Comment"> *</span>
<span class="Comment"> * * {@link AUTO.$provide#methods_provider provider(provider)} - registers a **service provider** with the</span>
<span class="Comment"> *     {@link AUTO.$injector $injector}</span>
<span class="Comment"> * * {@link AUTO.$provide#methods_constant constant(obj)} - registers a value/object that can be accessed by</span>
<span class="Comment"> *     providers and services.</span>
<span class="Comment"> * * {@link AUTO.$provide#methods_value value(obj)} - registers a value/object that can only be accessed by</span>
<span class="Comment"> *     services, not providers.</span>
<span class="Comment"> * * {@link AUTO.$provide#methods_factory factory(fn)} - registers a service **factory function**, `fn`,</span>
<span class="Comment"> *     that will be wrapped in a **service provider** object, whose `$get` property will contain the</span>
<span class="Comment"> *     given factory function.</span>
<span class="Comment"> * * {@link AUTO.$provide#methods_service service(class)} - registers a **constructor function**, `class` that</span>
<span class="Comment"> *     that will be wrapped in a **service provider** object, whose `$get` property will instantiate</span>
<span class="Comment"> *      a new object using the given constructor function.</span>
<span class="Comment"> *</span>
<span class="Comment"> * See the individual methods for more information and examples.</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc method</span>
<span class="Comment"> * @name AUTO.$provide#provider</span>
<span class="Comment"> * @methodOf AUTO.$provide</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Register a **provider function** with the {@link AUTO.$injector $injector}. Provider functions</span>
<span class="Comment"> * are constructor functions, whose instances are responsible for &quot;providing&quot; a factory for a</span>
<span class="Comment"> * service.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Service provider names start with the name of the service they provide followed by `Provider`.</span>
<span class="Comment"> * For example, the {@link ng.$log $log} service has a provider called</span>
<span class="Comment"> * {@link ng.$logProvider $logProvider}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Service provider objects can have additional methods which allow configuration of the provider</span>
<span class="Comment"> * and its service. Importantly, you can configure what kind of service is created by the `$get`</span>
<span class="Comment"> * method, or how that service will act. For example, the {@link ng.$logProvider $logProvider} has a</span>
<span class="Comment"> * method {@link ng.$logProvider#debugEnabled debugEnabled}</span>
<span class="Comment"> * which lets you specify whether the {@link ng.$log $log} service will log debug messages to the</span>
<span class="Comment"> * console or not.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} name The name of the instance. NOTE: the provider will be available under `name +</span>
<span class="Comment">                        'Provider'` key.</span>
<span class="Comment"> * @param {(Object|function())} provider If the provider is:</span>
<span class="Comment"> *</span>
<span class="Comment"> *   - `Object`: then it should have a `$get` method. The `$get` method will be invoked using</span>
<span class="Comment"> *               {@link AUTO.$injector#invoke $injector.invoke()} when an instance needs to be</span>
<span class="Comment"> *               created.</span>
<span class="Comment"> *   - `Constructor`: a new instance of the provider will be created using</span>
<span class="Comment"> *               {@link AUTO.$injector#instantiate $injector.instantiate()}, then treated as</span>
<span class="Comment"> *               `object`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @returns {Object} registered provider instance</span>

<span class="Comment"> * @example</span>
<span class="Comment"> *</span>
<span class="Comment"> * The following example shows how to create a simple event tracking service and register it using</span>
<span class="Comment"> * {@link AUTO.$provide#methods_provider $provide.provider()}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *  // Define the eventTracker provider</span>
<span class="Comment"> *  function EventTrackerProvider() {</span>
<span class="Comment"> *    var trackingUrl = '/track';</span>
<span class="Comment"> *</span>
<span class="Comment"> *    // A provider method for configuring where the tracked events should been saved</span>
<span class="Comment"> *    this.setTrackingUrl = function(url) {</span>
<span class="Comment"> *      trackingUrl = url;</span>
<span class="Comment"> *    };</span>
<span class="Comment"> *</span>
<span class="Comment"> *    // The service factory function</span>
<span class="Comment"> *    this.$get = ['$http', function($http) {</span>
<span class="Comment"> *      var trackedEvents = {};</span>
<span class="Comment"> *      return {</span>
<span class="Comment"> *        // Call this to track an event</span>
<span class="Comment"> *        event: function(event) {</span>
<span class="Comment"> *          var count = trackedEvents[event] || 0;</span>
<span class="Comment"> *          count += 1;</span>
<span class="Comment"> *          trackedEvents[event] = count;</span>
<span class="Comment"> *          return count;</span>
<span class="Comment"> *        },</span>
<span class="Comment"> *        // Call this to save the tracked events to the trackingUrl</span>
<span class="Comment"> *        save: function() {</span>
<span class="Comment"> *          $http.post(trackingUrl, trackedEvents);</span>
<span class="Comment"> *        }</span>
<span class="Comment"> *      };</span>
<span class="Comment"> *    }];</span>
<span class="Comment"> *  }</span>
<span class="Comment"> *</span>
<span class="Comment"> *  describe('eventTracker', function() {</span>
<span class="Comment"> *    var postSpy;</span>
<span class="Comment"> *</span>
<span class="Comment"> *    beforeEach(module(function($provide) {</span>
<span class="Comment"> *      // Register the eventTracker provider</span>
<span class="Comment"> *      $provide.provider('eventTracker', EventTrackerProvider);</span>
<span class="Comment"> *    }));</span>
<span class="Comment"> *</span>
<span class="Comment"> *    beforeEach(module(function(eventTrackerProvider) {</span>
<span class="Comment"> *      // Configure eventTracker provider</span>
<span class="Comment"> *      eventTrackerProvider.setTrackingUrl('/custom-track');</span>
<span class="Comment"> *    }));</span>
<span class="Comment"> *</span>
<span class="Comment"> *    it('tracks events', inject(function(eventTracker) {</span>
<span class="Comment"> *      expect(eventTracker.event('login')).toEqual(1);</span>
<span class="Comment"> *      expect(eventTracker.event('login')).toEqual(2);</span>
<span class="Comment"> *    }));</span>
<span class="Comment"> *</span>
<span class="Comment"> *    it('saves to the tracking url', inject(function(eventTracker, $http) {</span>
<span class="Comment"> *      postSpy = spyOn($http, 'post');</span>
<span class="Comment"> *      eventTracker.event('login');</span>
<span class="Comment"> *      eventTracker.save();</span>
<span class="Comment"> *      expect(postSpy).toHaveBeenCalled();</span>
<span class="Comment"> *      expect(postSpy.mostRecentCall.args[0]).not.toEqual('/track');</span>
<span class="Comment"> *      expect(postSpy.mostRecentCall.args[0]).toEqual('/custom-track');</span>
<span class="Comment"> *      expect(postSpy.mostRecentCall.args[1]).toEqual({ 'login': 1 });</span>
<span class="Comment"> *    }));</span>
<span class="Comment"> *  });</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc method</span>
<span class="Comment"> * @name AUTO.$provide#factory</span>
<span class="Comment"> * @methodOf AUTO.$provide</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Register a **service factory**, which will be called to return the service instance.</span>
<span class="Comment"> * This is short for registering a service where its provider consists of only a `$get` property,</span>
<span class="Comment"> * which is the given service factory function.</span>
<span class="Comment"> * You should use {@link AUTO.$provide#factory $provide.factory(getFn)} if you do not need to</span>
<span class="Comment"> * configure your service in a provider.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} name The name of the instance.</span>
<span class="Comment"> * @param {function()} $getFn The $getFn for the instance creation. Internally this is a short hand</span>
<span class="Comment"> *                            for `$provide.provider(name, {$get: $getFn})`.</span>
<span class="Comment"> * @returns {Object} registered provider instance</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * Here is an example of registering a service</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   $provide.factory('ping', ['$http', function($http) {</span>
<span class="Comment"> *     return function ping() {</span>
<span class="Comment"> *       return $http.send('/ping');</span>
<span class="Comment"> *     };</span>
<span class="Comment"> *   }]);</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> * You would then inject and use this service like this:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   someModule.controller('Ctrl', ['ping', function(ping) {</span>
<span class="Comment"> *     ping();</span>
<span class="Comment"> *   }]);</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc method</span>
<span class="Comment"> * @name AUTO.$provide#service</span>
<span class="Comment"> * @methodOf AUTO.$provide</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Register a **service constructor**, which will be invoked with `new` to create the service</span>
<span class="Comment"> * instance.</span>
<span class="Comment"> * This is short for registering a service where its provider's `$get` property is the service</span>
<span class="Comment"> * constructor function that will be used to instantiate the service instance.</span>
<span class="Comment"> *</span>
<span class="Comment"> * You should use {@link AUTO.$provide#methods_service $provide.service(class)} if you define your service</span>
<span class="Comment"> * as a type/class. This is common when using {@link <a href="http://coffeescript.org">http://coffeescript.org</a> CoffeeScript}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} name The name of the instance.</span>
<span class="Comment"> * @param {Function} constructor A class (constructor function) that will be instantiated.</span>
<span class="Comment"> * @returns {Object} registered provider instance</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * Here is an example of registering a service using</span>
<span class="Comment"> * {@link AUTO.$provide#methods_service $provide.service(class)} that is defined as a CoffeeScript class.</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   class Ping</span>
<span class="Comment"> *     constructor: (@$http)-&gt;</span>
<span class="Comment"> *     send: ()=&gt;</span>
<span class="Comment"> *       @$http.get('/ping')</span>
<span class="Comment"> *</span>
<span class="Comment"> *   $provide.service('ping', ['$http', Ping])</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> * You would then inject and use this service like this:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   someModule.controller 'Ctrl', ['ping', (ping)-&gt;</span>
<span class="Comment"> *     ping.send()</span>
<span class="Comment"> *   ]</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc method</span>
<span class="Comment"> * @name AUTO.$provide#value</span>
<span class="Comment"> * @methodOf AUTO.$provide</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Register a **value service** with the {@link AUTO.$injector $injector}, such as a string, a</span>
<span class="Comment"> * number, an array, an object or a function.  This is short for registering a service where its</span>
<span class="Comment"> * provider's `$get` property is a factory function that takes no arguments and returns the **value</span>
<span class="Comment"> * service**.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Value services are similar to constant services, except that they cannot be injected into a</span>
<span class="Comment"> * module configuration function (see {@link angular.Module#config}) but they can be overridden by</span>
<span class="Comment"> * an Angular</span>
<span class="Comment"> * {@link AUTO.$provide#decorator decorator}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} name The name of the instance.</span>
<span class="Comment"> * @param {*} value The value.</span>
<span class="Comment"> * @returns {Object} registered provider instance</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * Here are some examples of creating value services.</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   $provide.value('ADMIN_USER', 'admin');</span>
<span class="Comment"> *</span>
<span class="Comment"> *   $provide.value('RoleLookup', { admin: 0, writer: 1, reader: 2 });</span>
<span class="Comment"> *</span>
<span class="Comment"> *   $provide.value('halfOf', function(value) {</span>
<span class="Comment"> *     return value / 2;</span>
<span class="Comment"> *   });</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc method</span>
<span class="Comment"> * @name AUTO.$provide#constant</span>
<span class="Comment"> * @methodOf AUTO.$provide</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Register a **constant service**, such as a string, a number, an array, an object or a function,</span>
<span class="Comment"> * with the {@link AUTO.$injector $injector}. Unlike {@link AUTO.$provide#value value} it can be</span>
<span class="Comment"> * injected into a module configuration function (see {@link angular.Module#config}) and it cannot</span>
<span class="Comment"> * be overridden by an Angular {@link AUTO.$provide#decorator decorator}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} name The name of the constant.</span>
<span class="Comment"> * @param {*} value The constant value.</span>
<span class="Comment"> * @returns {Object} registered instance</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * Here a some examples of creating constants:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   $provide.constant('SHARD_HEIGHT', 306);</span>
<span class="Comment"> *</span>
<span class="Comment"> *   $provide.constant('MY_COLOURS', ['red', 'blue', 'grey']);</span>
<span class="Comment"> *</span>
<span class="Comment"> *   $provide.constant('double', function(value) {</span>
<span class="Comment"> *     return value * 2;</span>
<span class="Comment"> *   });</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc method</span>
<span class="Comment"> * @name AUTO.$provide#decorator</span>
<span class="Comment"> * @methodOf AUTO.$provide</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Register a **service decorator** with the {@link AUTO.$injector $injector}. A service decorator</span>
<span class="Comment"> * intercepts the creation of a service, allowing it to override or modify the behaviour of the</span>
<span class="Comment"> * service. The object returned by the decorator may be the original service, or a new service</span>
<span class="Comment"> * object which replaces or wraps and delegates to the original service.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} name The name of the service to decorate.</span>
<span class="Comment"> * @param {function()} decorator This function will be invoked when the service needs to be</span>
<span class="Comment"> *    instantiated and should return the decorated service instance. The function is called using</span>
<span class="Comment"> *    the {@link AUTO.$injector#invoke injector.invoke} method and is therefore fully injectable.</span>
<span class="Comment"> *    Local injection arguments:</span>
<span class="Comment"> *</span>
<span class="Comment"> *    * `$delegate` - The original service instance, which can be monkey patched, configured,</span>
<span class="Comment"> *      decorated or delegated to.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * Here we decorate the {@link ng.$log $log} service to convert warnings to errors by intercepting</span>
<span class="Comment"> * calls to {@link ng.$log#error $log.warn()}.</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   $provider.decorator('$log', ['$delegate', function($delegate) {</span>
<span class="Comment"> *     $delegate.warn = $delegate.error;</span>
<span class="Comment"> *     return $delegate;</span>
<span class="Comment"> *   }]);</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> */</span>


<span class="Identifier">function</span> createInjector(modulesToLoad) <span class="Identifier">{</span>
  <span class="Identifier">var</span> INSTANTIATING = <span class="Identifier">{}</span>,
      providerSuffix = <span class="Constant">'Provider'</span>,
      path = <span class="Identifier">[]</span>,
      loadedModules = <span class="Statement">new</span> HashMap(),
      providerCache = <span class="Identifier">{</span>
        $provide: <span class="Identifier">{</span>
            provider: supportObject(provider),
            factory: supportObject(factory),
            service: supportObject(service),
            value: supportObject(value),
            constant: supportObject(constant),
            decorator: decorator
          <span class="Identifier">}</span>
      <span class="Identifier">}</span>,
      providerInjector = (providerCache.$injector =
          createInternalInjector(providerCache, <span class="Identifier">function</span>() <span class="Identifier">{</span>
            <span class="Statement">throw</span> $injectorMinErr(<span class="Constant">'unpr'</span>, <span class="Constant">&quot;Unknown provider: {0}&quot;</span>, path.join(<span class="Constant">' &lt;- '</span>));
          <span class="Identifier">}</span>)),
      instanceCache = <span class="Identifier">{}</span>,
      instanceInjector = (instanceCache.$injector =
          createInternalInjector(instanceCache, <span class="Identifier">function</span>(servicename) <span class="Identifier">{</span>
            <span class="Identifier">var</span> provider = providerInjector.get(servicename + providerSuffix);
            <span class="Statement">return</span> instanceInjector.invoke(provider.$get, provider);
          <span class="Identifier">}</span>));


  forEach(loadModules(modulesToLoad), <span class="Identifier">function</span>(fn) <span class="Identifier">{</span> instanceInjector.invoke(fn || noop); <span class="Identifier">}</span>);

  <span class="Statement">return</span> instanceInjector;

  <span class="Comment">////////////////////////////////////</span>
  <span class="Comment">// $provider</span>
  <span class="Comment">////////////////////////////////////</span>

  <span class="Identifier">function</span> supportObject(delegate) <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">function</span>(key, value) <span class="Identifier">{</span>
      <span class="Statement">if</span> (isObject(key)) <span class="Identifier">{</span>
        forEach(key, reverseParams(delegate));
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">return</span> delegate(key, value);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>

  <span class="Identifier">function</span> provider(name, provider_) <span class="Identifier">{</span>
    assertNotHasOwnProperty(name, <span class="Constant">'service'</span>);
    <span class="Statement">if</span> (isFunction(provider_) || isArray(provider_)) <span class="Identifier">{</span>
      provider_ = providerInjector.instantiate(provider_);
    <span class="Identifier">}</span>
    <span class="Statement">if</span> (!provider_.$get) <span class="Identifier">{</span>
      <span class="Statement">throw</span> $injectorMinErr(<span class="Constant">'pget'</span>, <span class="Constant">&quot;Provider '{0}' must define $get factory method.&quot;</span>, name);
    <span class="Identifier">}</span>
    <span class="Statement">return</span> providerCache<span class="Identifier">[</span>name + providerSuffix<span class="Identifier">]</span> = provider_;
  <span class="Identifier">}</span>

  <span class="Identifier">function</span> factory(name, factoryFn) <span class="Identifier">{</span> <span class="Statement">return</span> provider(name, <span class="Identifier">{</span> $get: factoryFn <span class="Identifier">}</span>); <span class="Identifier">}</span>

  <span class="Identifier">function</span> service(name, constructor) <span class="Identifier">{</span>
    <span class="Statement">return</span> factory(name, <span class="Identifier">[</span><span class="Constant">'$injector'</span>, <span class="Identifier">function</span>($injector) <span class="Identifier">{</span>
      <span class="Statement">return</span> $injector.instantiate(constructor);
    <span class="Identifier">}]</span>);
  <span class="Identifier">}</span>

  <span class="Identifier">function</span> value(name, val) <span class="Identifier">{</span> <span class="Statement">return</span> factory(name, valueFn(val)); <span class="Identifier">}</span>

  <span class="Identifier">function</span> constant(name, value) <span class="Identifier">{</span>
    assertNotHasOwnProperty(name, <span class="Constant">'constant'</span>);
    providerCache<span class="Identifier">[</span>name<span class="Identifier">]</span> = value;
    instanceCache<span class="Identifier">[</span>name<span class="Identifier">]</span> = value;
  <span class="Identifier">}</span>

  <span class="Identifier">function</span> decorator(serviceName, decorFn) <span class="Identifier">{</span>
    <span class="Identifier">var</span> origProvider = providerInjector.get(serviceName + providerSuffix),
        orig$get = origProvider.$get;

    origProvider.$get = <span class="Identifier">function</span>() <span class="Identifier">{</span>
      <span class="Identifier">var</span> origInstance = instanceInjector.invoke(orig$get, origProvider);
      <span class="Statement">return</span> instanceInjector.invoke(decorFn, <span class="Statement">null</span>, <span class="Identifier">{</span>$delegate: origInstance<span class="Identifier">}</span>);
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>

  <span class="Comment">////////////////////////////////////</span>
  <span class="Comment">// Module Loading</span>
  <span class="Comment">////////////////////////////////////</span>
  <span class="Identifier">function</span> loadModules(modulesToLoad)<span class="Identifier">{</span>
    <span class="Identifier">var</span> runBlocks = <span class="Identifier">[]</span>, moduleFn, invokeQueue, i, ii;
    forEach(modulesToLoad, <span class="Identifier">function</span>(module) <span class="Identifier">{</span>
      <span class="Statement">if</span> (loadedModules.get(module)) <span class="Statement">return</span>;
      loadedModules.put(module, <span class="Constant">true</span>);

      <span class="Statement">try</span> <span class="Identifier">{</span>
        <span class="Statement">if</span> (isString(module)) <span class="Identifier">{</span>
          moduleFn = angularModule(module);
          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);

          <span class="Statement">for</span>(invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i &lt; ii; i++) <span class="Identifier">{</span>
            <span class="Identifier">var</span> invokeArgs = invokeQueue<span class="Identifier">[</span>i<span class="Identifier">]</span>,
                provider = providerInjector.get(invokeArgs<span class="Identifier">[</span>0<span class="Identifier">]</span>);

            provider<span class="Identifier">[</span>invokeArgs<span class="Identifier">[</span>1<span class="Identifier">]]</span>.apply(provider, invokeArgs<span class="Identifier">[</span>2<span class="Identifier">]</span>);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isFunction(module)) <span class="Identifier">{</span>
            runBlocks.push(providerInjector.invoke(module));
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isArray(module)) <span class="Identifier">{</span>
            runBlocks.push(providerInjector.invoke(module));
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          assertArgFn(module, <span class="Constant">'module'</span>);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
        <span class="Statement">if</span> (isArray(module)) <span class="Identifier">{</span>
          module = module<span class="Identifier">[</span>module.length - 1<span class="Identifier">]</span>;
        <span class="Identifier">}</span>
        <span class="Statement">if</span> (e.message &amp;&amp; e.stack &amp;&amp; e.stack.indexOf(e.message) == -1) <span class="Identifier">{</span>
          <span class="Comment">// Safari &amp; FF's stack traces don't contain error.message content</span>
          <span class="Comment">// unlike those of Chrome and IE</span>
          <span class="Comment">// So if stack doesn't contain message, we create a new string that contains both.</span>
          <span class="Comment">// Since error.stack is read-only in Safari, I'm overriding e and not e.stack here.</span>
          <span class="Comment">/* jshint -W022 */</span>
          e = e.message + <span class="Special">'\n'</span> + e.stack;
        <span class="Identifier">}</span>
        <span class="Statement">throw</span> $injectorMinErr(<span class="Constant">'modulerr'</span>, <span class="Constant">&quot;Failed to instantiate module {0} due to:</span><span class="Special">\n</span><span class="Constant">{1}&quot;</span>,
                  module, e.stack || e.message || e);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>);
    <span class="Statement">return</span> runBlocks;
  <span class="Identifier">}</span>

  <span class="Comment">////////////////////////////////////</span>
  <span class="Comment">// internal Injector</span>
  <span class="Comment">////////////////////////////////////</span>

  <span class="Identifier">function</span> createInternalInjector(cache, factory) <span class="Identifier">{</span>

    <span class="Identifier">function</span> getService(serviceName) <span class="Identifier">{</span>
      <span class="Statement">if</span> (cache.hasOwnProperty(serviceName)) <span class="Identifier">{</span>
        <span class="Statement">if</span> (cache<span class="Identifier">[</span>serviceName<span class="Identifier">]</span> === INSTANTIATING) <span class="Identifier">{</span>
          <span class="Statement">throw</span> $injectorMinErr(<span class="Constant">'cdep'</span>, <span class="Constant">'Circular dependency found: {0}'</span>, path.join(<span class="Constant">' &lt;- '</span>));
        <span class="Identifier">}</span>
        <span class="Statement">return</span> cache<span class="Identifier">[</span>serviceName<span class="Identifier">]</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">try</span> <span class="Identifier">{</span>
          path.unshift(serviceName);
          cache<span class="Identifier">[</span>serviceName<span class="Identifier">]</span> = INSTANTIATING;
          <span class="Statement">return</span> cache<span class="Identifier">[</span>serviceName<span class="Identifier">]</span> = factory(serviceName);
        <span class="Identifier">}</span> <span class="Statement">finally</span> <span class="Identifier">{</span>
          path.shift();
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Identifier">function</span> invoke(fn, <span class="Statement">self</span>, locals)<span class="Identifier">{</span>
      <span class="Identifier">var</span> args = <span class="Identifier">[]</span>,
          $inject = annotate(fn),
          length, i,
          key;

      <span class="Statement">for</span>(i = 0, length = $inject.length; i &lt; length; i++) <span class="Identifier">{</span>
        key = $inject<span class="Identifier">[</span>i<span class="Identifier">]</span>;
        <span class="Statement">if</span> (<span class="Statement">typeof</span> key !== <span class="Constant">'string'</span>) <span class="Identifier">{</span>
          <span class="Statement">throw</span> $injectorMinErr(<span class="Constant">'itkn'</span>,
                  <span class="Constant">'Incorrect injection token! Expected service name as string, got {0}'</span>, key);
        <span class="Identifier">}</span>
        args.push(
          locals &amp;&amp; locals.hasOwnProperty(key)
          ? locals<span class="Identifier">[</span>key<span class="Identifier">]</span>
          : getService(key)
        );
      <span class="Identifier">}</span>
      <span class="Statement">if</span> (!fn.$inject) <span class="Identifier">{</span>
        <span class="Comment">// this means that we must be an array.</span>
        fn = fn<span class="Identifier">[</span>length<span class="Identifier">]</span>;
      <span class="Identifier">}</span>


      <span class="Comment">// Performance optimization: <a href="http://jsperf.com/apply-vs-call-vs-invoke">http://jsperf.com/apply-vs-call-vs-invoke</a></span>
      <span class="Statement">switch</span> (<span class="Statement">self</span> ? -1 : args.length) <span class="Identifier">{</span>
        <span class="Statement">case</span>  0: <span class="Statement">return</span> fn();
        <span class="Statement">case</span>  1: <span class="Statement">return</span> fn(args<span class="Identifier">[</span>0<span class="Identifier">]</span>);
        <span class="Statement">case</span>  2: <span class="Statement">return</span> fn(args<span class="Identifier">[</span>0<span class="Identifier">]</span>, args<span class="Identifier">[</span>1<span class="Identifier">]</span>);
        <span class="Statement">case</span>  3: <span class="Statement">return</span> fn(args<span class="Identifier">[</span>0<span class="Identifier">]</span>, args<span class="Identifier">[</span>1<span class="Identifier">]</span>, args<span class="Identifier">[</span>2<span class="Identifier">]</span>);
        <span class="Statement">case</span>  4: <span class="Statement">return</span> fn(args<span class="Identifier">[</span>0<span class="Identifier">]</span>, args<span class="Identifier">[</span>1<span class="Identifier">]</span>, args<span class="Identifier">[</span>2<span class="Identifier">]</span>, args<span class="Identifier">[</span>3<span class="Identifier">]</span>);
        <span class="Statement">case</span>  5: <span class="Statement">return</span> fn(args<span class="Identifier">[</span>0<span class="Identifier">]</span>, args<span class="Identifier">[</span>1<span class="Identifier">]</span>, args<span class="Identifier">[</span>2<span class="Identifier">]</span>, args<span class="Identifier">[</span>3<span class="Identifier">]</span>, args<span class="Identifier">[</span>4<span class="Identifier">]</span>);
        <span class="Statement">case</span>  6: <span class="Statement">return</span> fn(args<span class="Identifier">[</span>0<span class="Identifier">]</span>, args<span class="Identifier">[</span>1<span class="Identifier">]</span>, args<span class="Identifier">[</span>2<span class="Identifier">]</span>, args<span class="Identifier">[</span>3<span class="Identifier">]</span>, args<span class="Identifier">[</span>4<span class="Identifier">]</span>, args<span class="Identifier">[</span>5<span class="Identifier">]</span>);
        <span class="Statement">case</span>  7: <span class="Statement">return</span> fn(args<span class="Identifier">[</span>0<span class="Identifier">]</span>, args<span class="Identifier">[</span>1<span class="Identifier">]</span>, args<span class="Identifier">[</span>2<span class="Identifier">]</span>, args<span class="Identifier">[</span>3<span class="Identifier">]</span>, args<span class="Identifier">[</span>4<span class="Identifier">]</span>, args<span class="Identifier">[</span>5<span class="Identifier">]</span>, args<span class="Identifier">[</span>6<span class="Identifier">]</span>);
        <span class="Statement">case</span>  8: <span class="Statement">return</span> fn(args<span class="Identifier">[</span>0<span class="Identifier">]</span>, args<span class="Identifier">[</span>1<span class="Identifier">]</span>, args<span class="Identifier">[</span>2<span class="Identifier">]</span>, args<span class="Identifier">[</span>3<span class="Identifier">]</span>, args<span class="Identifier">[</span>4<span class="Identifier">]</span>, args<span class="Identifier">[</span>5<span class="Identifier">]</span>, args<span class="Identifier">[</span>6<span class="Identifier">]</span>, args<span class="Identifier">[</span>7<span class="Identifier">]</span>);
        <span class="Statement">case</span>  9: <span class="Statement">return</span> fn(args<span class="Identifier">[</span>0<span class="Identifier">]</span>, args<span class="Identifier">[</span>1<span class="Identifier">]</span>, args<span class="Identifier">[</span>2<span class="Identifier">]</span>, args<span class="Identifier">[</span>3<span class="Identifier">]</span>, args<span class="Identifier">[</span>4<span class="Identifier">]</span>, args<span class="Identifier">[</span>5<span class="Identifier">]</span>, args<span class="Identifier">[</span>6<span class="Identifier">]</span>, args<span class="Identifier">[</span>7<span class="Identifier">]</span>,
          args<span class="Identifier">[</span>8<span class="Identifier">]</span>);
        <span class="Statement">case</span> 10: <span class="Statement">return</span> fn(args<span class="Identifier">[</span>0<span class="Identifier">]</span>, args<span class="Identifier">[</span>1<span class="Identifier">]</span>, args<span class="Identifier">[</span>2<span class="Identifier">]</span>, args<span class="Identifier">[</span>3<span class="Identifier">]</span>, args<span class="Identifier">[</span>4<span class="Identifier">]</span>, args<span class="Identifier">[</span>5<span class="Identifier">]</span>, args<span class="Identifier">[</span>6<span class="Identifier">]</span>, args<span class="Identifier">[</span>7<span class="Identifier">]</span>,
          args<span class="Identifier">[</span>8<span class="Identifier">]</span>, args<span class="Identifier">[</span>9<span class="Identifier">]</span>);
        <span class="Statement">default</span>: <span class="Statement">return</span> fn.apply(<span class="Statement">self</span>, args);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Identifier">function</span> instantiate(Type, locals) <span class="Identifier">{</span>
      <span class="Identifier">var</span> Constructor = <span class="Identifier">function</span>() <span class="Identifier">{}</span>,
          instance, returnedValue;

      <span class="Comment">// Check if Type is annotated and use just the given function at n-1 as parameter</span>
      <span class="Comment">// e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);</span>
      Constructor.prototype = (isArray(Type) ? Type<span class="Identifier">[</span>Type.length - 1<span class="Identifier">]</span> : Type).prototype;
      instance = <span class="Statement">new</span> Constructor();
      returnedValue = invoke(Type, instance, locals);

      <span class="Statement">return</span> isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
    <span class="Identifier">}</span>

    <span class="Statement">return</span> <span class="Identifier">{</span>
      invoke: invoke,
      instantiate: instantiate,
      get: getService,
      annotate: annotate,
      has: <span class="Identifier">function</span>(name) <span class="Identifier">{</span>
        <span class="Statement">return</span> providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name ng.$anchorScroll</span>
<span class="Comment"> * @requires $window</span>
<span class="Comment"> * @requires $location</span>
<span class="Comment"> * @requires $rootScope</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * When called, it checks current value of `$location.hash()` and scroll to related element,</span>
<span class="Comment"> * according to rules specified in</span>
<span class="Comment"> * {@link <a href="http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document">http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document</a> Html5 spec}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * It also watches the `$location.hash()` and scrolls whenever it changes to match any anchor.</span>
<span class="Comment"> * This can be disabled by calling `$anchorScrollProvider.disableAutoScrolling()`.</span>
<span class="Comment"> * </span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;example&gt;</span>
<span class="Comment">     &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">       &lt;div id=&quot;scrollArea&quot; ng-controller=&quot;ScrollCtrl&quot;&gt;</span>
<span class="Comment">         &lt;a ng-click=&quot;gotoBottom()&quot;&gt;Go to bottom&lt;/a&gt;</span>
<span class="Comment">         &lt;a id=&quot;bottom&quot;&gt;&lt;/a&gt; You're at the bottom!</span>
<span class="Comment">       &lt;/div&gt;</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">     &lt;file name=&quot;script.js&quot;&gt;</span>
<span class="Comment">       function ScrollCtrl($scope, $location, $anchorScroll) {</span>
<span class="Comment">         $scope.gotoBottom = function (){</span>
<span class="Comment">           // set the location.hash to the id of</span>
<span class="Comment">           // the element you wish to scroll to.</span>
<span class="Comment">           $location.hash('bottom');</span>
<span class="Comment">           </span>
<span class="Comment">           // call $anchorScroll()</span>
<span class="Comment">           $anchorScroll();</span>
<span class="Comment">         }</span>
<span class="Comment">       }</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">     &lt;file name=&quot;style.css&quot;&gt;</span>
<span class="Comment">       #scrollArea {</span>
<span class="Comment">         height: 350px;</span>
<span class="Comment">         overflow: auto;</span>
<span class="Comment">       }</span>

<span class="Comment">       #bottom {</span>
<span class="Comment">         display: block;</span>
<span class="Comment">         margin-top: 2000px;</span>
<span class="Comment">       }</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">   &lt;/example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $AnchorScrollProvider() <span class="Identifier">{</span>

  <span class="Identifier">var</span> autoScrollingEnabled = <span class="Constant">true</span>;

  <span class="Identifier">this</span>.disableAutoScrolling = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    autoScrollingEnabled = <span class="Constant">false</span>;
  <span class="Identifier">}</span>;

  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$window'</span>, <span class="Constant">'$location'</span>, <span class="Constant">'$rootScope'</span>, <span class="Identifier">function</span>($<span class="Statement">window</span>, $<span class="Statement">location</span>, $rootScope) <span class="Identifier">{</span>
    <span class="Identifier">var</span> <span class="Statement">document</span> = $<span class="Statement">window</span>.<span class="Statement">document</span>;

    <span class="Comment">// helper function to get first anchor from a NodeList</span>
    <span class="Comment">// can't use filter.filter, as it accepts only instances of Array</span>
    <span class="Comment">// and IE can't convert NodeList to an array using [].slice</span>
    <span class="Comment">// </span><span class="Todo">TODO</span><span class="Comment">(vojta): use filter if we change it to accept lists as well</span>
    <span class="Identifier">function</span> getFirstAnchor(list) <span class="Identifier">{</span>
      <span class="Identifier">var</span> result = <span class="Statement">null</span>;
      forEach(list, <span class="Identifier">function</span>(element) <span class="Identifier">{</span>
        <span class="Statement">if</span> (!result &amp;&amp; lowercase(element.nodeName) === <span class="Constant">'a'</span>) result = element;
      <span class="Identifier">}</span>);
      <span class="Statement">return</span> result;
    <span class="Identifier">}</span>

    <span class="Identifier">function</span> scroll() <span class="Identifier">{</span>
      <span class="Identifier">var</span> hash = $<span class="Statement">location</span>.hash(), elm;

      <span class="Comment">// empty hash, scroll to the top of the page</span>
      <span class="Statement">if</span> (!hash) $<span class="Statement">window</span>.scrollTo(0, 0);

      <span class="Comment">// element with given id</span>
      <span class="Statement">else</span> <span class="Statement">if</span> ((elm = <span class="Statement">document</span>.getElementById(hash))) elm.scrollIntoView();

      <span class="Comment">// first anchor with given name :-D</span>
      <span class="Statement">else</span> <span class="Statement">if</span> ((elm = getFirstAnchor(<span class="Statement">document</span>.getElementsByName(hash)))) elm.scrollIntoView();

      <span class="Comment">// no element and hash == 'top', scroll to the top of the page</span>
      <span class="Statement">else</span> <span class="Statement">if</span> (hash === <span class="Constant">'top'</span>) $<span class="Statement">window</span>.scrollTo(0, 0);
    <span class="Identifier">}</span>

    <span class="Comment">// does not scroll when user clicks on anchor link that is currently on</span>
    <span class="Comment">// (no url change, no $location.hash() change), browser native does scroll</span>
    <span class="Statement">if</span> (autoScrollingEnabled) <span class="Identifier">{</span>
      $rootScope.$watch(<span class="Identifier">function</span> autoScrollWatch() <span class="Identifier">{</span><span class="Statement">return</span> $<span class="Statement">location</span>.hash();<span class="Identifier">}</span>,
        <span class="Identifier">function</span> autoScrollWatchAction() <span class="Identifier">{</span>
          $rootScope.$evalAsync(scroll);
        <span class="Identifier">}</span>);
    <span class="Identifier">}</span>

    <span class="Statement">return</span> scroll;
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Identifier">var</span> $animateMinErr = minErr(<span class="Constant">'$animate'</span>);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$animateProvider</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Default implementation of $animate that doesn't perform any animations, instead just</span>
<span class="Comment"> * synchronously performs DOM</span>
<span class="Comment"> * updates and calls done() callbacks.</span>
<span class="Comment"> *</span>
<span class="Comment"> * In order to enable animations the ngAnimate module has to be loaded.</span>
<span class="Comment"> *</span>
<span class="Comment"> * To see the functional implementation check out src/ngAnimate/animate.js</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> $AnimateProvider = <span class="Identifier">[</span><span class="Constant">'$provide'</span>, <span class="Identifier">function</span>($provide) <span class="Identifier">{</span>


  <span class="Identifier">this</span>.$$selectors = <span class="Identifier">{}</span>;


  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.$animateProvider#register</span>
<span class="Comment">   * @methodOf ng.$animateProvider</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Registers a new injectable animation factory function. The factory function produces the</span>
<span class="Comment">   * animation object which contains callback functions for each event that is expected to be</span>
<span class="Comment">   * animated.</span>
<span class="Comment">   *</span>
<span class="Comment">   *   * `eventFn`: `function(Element, doneFunction)` The element to animate, the `doneFunction`</span>
<span class="Comment">   *   must be called once the element animation is complete. If a function is returned then the</span>
<span class="Comment">   *   animation service will use this function to cancel the animation whenever a cancel event is</span>
<span class="Comment">   *   triggered.</span>
<span class="Comment">   *</span>
<span class="Comment">   *</span>
<span class="Comment">   *&lt;pre&gt;</span>
<span class="Comment">   *   return {</span>
<span class="Comment">     *     eventFn : function(element, done) {</span>
<span class="Comment">     *       //code to run the animation</span>
<span class="Comment">     *       //once complete, then run done()</span>
<span class="Comment">     *       return function cancellationFunction() {</span>
<span class="Comment">     *         //code to cancel the animation</span>
<span class="Comment">     *       }</span>
<span class="Comment">     *     }</span>
<span class="Comment">     *   }</span>
<span class="Comment">   *&lt;/pre&gt;</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string} name The name of the animation.</span>
<span class="Comment">   * @param {function} factory The factory function that will be executed to return the animation</span>
<span class="Comment">   *                           object.</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.register = <span class="Identifier">function</span>(name, factory) <span class="Identifier">{</span>
    <span class="Identifier">var</span> key = name + <span class="Constant">'-animation'</span>;
    <span class="Statement">if</span> (name &amp;&amp; name.charAt(0) != <span class="Constant">'.'</span>) <span class="Statement">throw</span> $animateMinErr(<span class="Constant">'notcsel'</span>,
        <span class="Constant">&quot;Expecting class selector starting with '.' got '{0}'.&quot;</span>, name);
    <span class="Identifier">this</span>.$$selectors<span class="Identifier">[</span>name.substr(1)<span class="Identifier">]</span> = key;
    $provide.factory(key, factory);
  <span class="Identifier">}</span>;

  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$timeout'</span>, <span class="Identifier">function</span>($timeout) <span class="Identifier">{</span>

    <span class="Comment">/**</span>
<span class="Comment">     *</span>
<span class="Comment">     * @ngdoc object</span>
<span class="Comment">     * @name ng.$animate</span>
<span class="Comment">     * @description The $animate service provides rudimentary DOM manipulation functions to</span>
<span class="Comment">     * insert, remove and move elements within the DOM, as well as adding and removing classes.</span>
<span class="Comment">     * This service is the core service used by the ngAnimate $animator service which provides</span>
<span class="Comment">     * high-level animation hooks for CSS and JavaScript.</span>
<span class="Comment">     *</span>
<span class="Comment">     * $animate is available in the AngularJS core, however, the ngAnimate module must be included</span>
<span class="Comment">     * to enable full out animation support. Otherwise, $animate will only perform simple DOM</span>
<span class="Comment">     * manipulation operations.</span>
<span class="Comment">     *</span>
<span class="Comment">     * To learn more about enabling animation support, click here to visit the {@link ngAnimate</span>
<span class="Comment">     * ngAnimate module page} as well as the {@link ngAnimate.$animate ngAnimate $animate service</span>
<span class="Comment">     * page}.</span>
<span class="Comment">     */</span>
    <span class="Statement">return</span> <span class="Identifier">{</span>

      <span class="Comment">/**</span>
<span class="Comment">       *</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$animate#enter</span>
<span class="Comment">       * @methodOf ng.$animate</span>
<span class="Comment">       * @function</span>
<span class="Comment">       * @description Inserts the element into the DOM either after the `after` element or within</span>
<span class="Comment">       *   the `parent` element. Once complete, the done() callback will be fired (if provided).</span>
<span class="Comment">       * @param {jQuery/jqLite element} element the element which will be inserted into the DOM</span>
<span class="Comment">       * @param {jQuery/jqLite element} parent the parent element which will append the element as</span>
<span class="Comment">       *   a child (if the after element is not present)</span>
<span class="Comment">       * @param {jQuery/jqLite element} after the sibling element which will append the element</span>
<span class="Comment">       *   after itself</span>
<span class="Comment">       * @param {function=} done callback function that will be called after the element has been</span>
<span class="Comment">       *   inserted into the DOM</span>
<span class="Comment">       */</span>
      enter : <span class="Identifier">function</span>(element, <span class="Statement">parent</span>, after, done) <span class="Identifier">{</span>
        <span class="Statement">if</span> (after) <span class="Identifier">{</span>
          after.after(element);
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          <span class="Statement">if</span> (!<span class="Statement">parent</span> || !<span class="Statement">parent</span><span class="Identifier">[</span>0<span class="Identifier">]</span>) <span class="Identifier">{</span>
            <span class="Statement">parent</span> = after.<span class="Statement">parent</span>();
          <span class="Identifier">}</span>
          <span class="Statement">parent</span>.append(element);
        <span class="Identifier">}</span>
        done &amp;&amp; $timeout(done, 0, <span class="Constant">false</span>);
      <span class="Identifier">}</span>,

      <span class="Comment">/**</span>
<span class="Comment">       *</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$animate#leave</span>
<span class="Comment">       * @methodOf ng.$animate</span>
<span class="Comment">       * @function</span>
<span class="Comment">       * @description Removes the element from the DOM. Once complete, the done() callback will be</span>
<span class="Comment">       *   fired (if provided).</span>
<span class="Comment">       * @param {jQuery/jqLite element} element the element which will be removed from the DOM</span>
<span class="Comment">       * @param {function=} done callback function that will be called after the element has been</span>
<span class="Comment">       *   removed from the DOM</span>
<span class="Comment">       */</span>
      leave : <span class="Identifier">function</span>(element, done) <span class="Identifier">{</span>
        element.remove();
        done &amp;&amp; $timeout(done, 0, <span class="Constant">false</span>);
      <span class="Identifier">}</span>,

      <span class="Comment">/**</span>
<span class="Comment">       *</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$animate#move</span>
<span class="Comment">       * @methodOf ng.$animate</span>
<span class="Comment">       * @function</span>
<span class="Comment">       * @description Moves the position of the provided element within the DOM to be placed</span>
<span class="Comment">       * either after the `after` element or inside of the `parent` element. Once complete, the</span>
<span class="Comment">       * done() callback will be fired (if provided).</span>
<span class="Comment">       * </span>
<span class="Comment">       * @param {jQuery/jqLite element} element the element which will be moved around within the</span>
<span class="Comment">       *   DOM</span>
<span class="Comment">       * @param {jQuery/jqLite element} parent the parent element where the element will be</span>
<span class="Comment">       *   inserted into (if the after element is not present)</span>
<span class="Comment">       * @param {jQuery/jqLite element} after the sibling element where the element will be</span>
<span class="Comment">       *   positioned next to</span>
<span class="Comment">       * @param {function=} done the callback function (if provided) that will be fired after the</span>
<span class="Comment">       *   element has been moved to its new position</span>
<span class="Comment">       */</span>
      move : <span class="Identifier">function</span>(element, <span class="Statement">parent</span>, after, done) <span class="Identifier">{</span>
        <span class="Comment">// Do not remove element before insert. Removing will cause data associated with the</span>
        <span class="Comment">// element to be dropped. Insert will implicitly do the remove.</span>
        <span class="Identifier">this</span>.enter(element, <span class="Statement">parent</span>, after, done);
      <span class="Identifier">}</span>,

      <span class="Comment">/**</span>
<span class="Comment">       *</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$animate#addClass</span>
<span class="Comment">       * @methodOf ng.$animate</span>
<span class="Comment">       * @function</span>
<span class="Comment">       * @description Adds the provided className CSS class value to the provided element. Once</span>
<span class="Comment">       * complete, the done() callback will be fired (if provided).</span>
<span class="Comment">       * @param {jQuery/jqLite element} element the element which will have the className value</span>
<span class="Comment">       *   added to it</span>
<span class="Comment">       * @param {string} className the CSS class which will be added to the element</span>
<span class="Comment">       * @param {function=} done the callback function (if provided) that will be fired after the</span>
<span class="Comment">       *   className value has been added to the element</span>
<span class="Comment">       */</span>
      addClass : <span class="Identifier">function</span>(element, className, done) <span class="Identifier">{</span>
        className = isString(className) ?
                      className :
                      isArray(className) ? className.join(<span class="Constant">' '</span>) : <span class="Constant">''</span>;
        forEach(element, <span class="Identifier">function</span> (element) <span class="Identifier">{</span>
          jqLiteAddClass(element, className);
        <span class="Identifier">}</span>);
        done &amp;&amp; $timeout(done, 0, <span class="Constant">false</span>);
      <span class="Identifier">}</span>,

      <span class="Comment">/**</span>
<span class="Comment">       *</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$animate#removeClass</span>
<span class="Comment">       * @methodOf ng.$animate</span>
<span class="Comment">       * @function</span>
<span class="Comment">       * @description Removes the provided className CSS class value from the provided element.</span>
<span class="Comment">       * Once complete, the done() callback will be fired (if provided).</span>
<span class="Comment">       * @param {jQuery/jqLite element} element the element which will have the className value</span>
<span class="Comment">       *   removed from it</span>
<span class="Comment">       * @param {string} className the CSS class which will be removed from the element</span>
<span class="Comment">       * @param {function=} done the callback function (if provided) that will be fired after the</span>
<span class="Comment">       *   className value has been removed from the element</span>
<span class="Comment">       */</span>
      removeClass : <span class="Identifier">function</span>(element, className, done) <span class="Identifier">{</span>
        className = isString(className) ?
                      className :
                      isArray(className) ? className.join(<span class="Constant">' '</span>) : <span class="Constant">''</span>;
        forEach(element, <span class="Identifier">function</span> (element) <span class="Identifier">{</span>
          jqLiteRemoveClass(element, className);
        <span class="Identifier">}</span>);
        done &amp;&amp; $timeout(done, 0, <span class="Constant">false</span>);
      <span class="Identifier">}</span>,

      enabled : noop
    <span class="Identifier">}</span>;
  <span class="Identifier">}]</span>;
<span class="Identifier">}]</span>;

<span class="Comment">/**</span>
<span class="Comment"> * ! This is a private undocumented service !</span>
<span class="Comment"> *</span>
<span class="Comment"> * @name ng.$browser</span>
<span class="Comment"> * @requires $log</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * This object has two goals:</span>
<span class="Comment"> *</span>
<span class="Comment"> * - hide all the global state in the browser caused by the window object</span>
<span class="Comment"> * - abstract away all the browser specific features and inconsistencies</span>
<span class="Comment"> *</span>
<span class="Comment"> * For tests we provide {@link ngMock.$browser mock implementation} of the `$browser`</span>
<span class="Comment"> * service, which can be used for convenient testing of the application without the interaction with</span>
<span class="Comment"> * the real browser apis.</span>
<span class="Comment"> */</span>
<span class="Comment">/**</span>
<span class="Comment"> * @param {object} window The global window object.</span>
<span class="Comment"> * @param {object} document jQuery wrapped document.</span>
<span class="Comment"> * @param {function()} XHR XMLHttpRequest constructor.</span>
<span class="Comment"> * @param {object} $log console.log or an object with the same interface.</span>
<span class="Comment"> * @param {object} $sniffer $sniffer service</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> Browser(<span class="Statement">window</span>, <span class="Statement">document</span>, $log, $sniffer) <span class="Identifier">{</span>
  <span class="Identifier">var</span> <span class="Statement">self</span> = <span class="Identifier">this</span>,
      rawDocument = <span class="Statement">document</span><span class="Identifier">[</span>0<span class="Identifier">]</span>,
      <span class="Statement">location</span> = <span class="Statement">window</span>.<span class="Statement">location</span>,
      history = <span class="Statement">window</span>.history,
      setTimeout = <span class="Statement">window</span>.setTimeout,
      clearTimeout = <span class="Statement">window</span>.clearTimeout,
      pendingDeferIds = <span class="Identifier">{}</span>;

  <span class="Statement">self</span>.isMock = <span class="Constant">false</span>;

  <span class="Identifier">var</span> outstandingRequestCount = 0;
  <span class="Identifier">var</span> outstandingRequestCallbacks = <span class="Identifier">[]</span>;

  <span class="Comment">// </span><span class="Todo">TODO</span><span class="Comment">(vojta): remove this temporary api</span>
  <span class="Statement">self</span>.$$completeOutstandingRequest = completeOutstandingRequest;
  <span class="Statement">self</span>.$$incOutstandingRequestCount = <span class="Identifier">function</span>() <span class="Identifier">{</span> outstandingRequestCount++; <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`</span>
<span class="Comment">   * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.</span>
<span class="Comment">   */</span>
  <span class="Identifier">function</span> completeOutstandingRequest(fn) <span class="Identifier">{</span>
    <span class="Statement">try</span> <span class="Identifier">{</span>
      fn.apply(<span class="Statement">null</span>, sliceArgs(<span class="Identifier">arguments</span>, 1));
    <span class="Identifier">}</span> <span class="Statement">finally</span> <span class="Identifier">{</span>
      outstandingRequestCount--;
      <span class="Statement">if</span> (outstandingRequestCount === 0) <span class="Identifier">{</span>
        <span class="Statement">while</span>(outstandingRequestCallbacks.length) <span class="Identifier">{</span>
          <span class="Statement">try</span> <span class="Identifier">{</span>
            outstandingRequestCallbacks.pop()();
          <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
            $log.error(e);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>

  <span class="Comment">/**</span>
<span class="Comment">   * @private</span>
<span class="Comment">   * Note: this method is used only by scenario runner</span>
<span class="Comment">   * </span><span class="Todo">TODO</span><span class="Comment">(vojta): prefix this method with $$ ?</span>
<span class="Comment">   * @param {function()} callback Function that will be called when no outstanding request</span>
<span class="Comment">   */</span>
  <span class="Statement">self</span>.notifyWhenNoOutstandingRequests = <span class="Identifier">function</span>(callback) <span class="Identifier">{</span>
    <span class="Comment">// force browser to execute all pollFns - this is needed so that cookies and other pollers fire</span>
    <span class="Comment">// at some deterministic time in respect to the test runner's actions. Leaving things up to the</span>
    <span class="Comment">// regular poller would result in flaky tests.</span>
    forEach(pollFns, <span class="Identifier">function</span>(pollFn)<span class="Identifier">{</span> pollFn(); <span class="Identifier">}</span>);

    <span class="Statement">if</span> (outstandingRequestCount === 0) <span class="Identifier">{</span>
      callback();
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      outstandingRequestCallbacks.push(callback);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Comment">//////////////////////////////////////////////////////////////</span>
  <span class="Comment">// Poll Watcher API</span>
  <span class="Comment">//////////////////////////////////////////////////////////////</span>
  <span class="Identifier">var</span> pollFns = <span class="Identifier">[]</span>,
      pollTimeout;

  <span class="Comment">/**</span>
<span class="Comment">   * @name ng.$browser#addPollFn</span>
<span class="Comment">   * @methodOf ng.$browser</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {function()} fn Poll function to add</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Adds a function to the list of functions that poller periodically executes,</span>
<span class="Comment">   * and starts polling if not started yet.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @returns {function()} the added function</span>
<span class="Comment">   */</span>
  <span class="Statement">self</span>.addPollFn = <span class="Identifier">function</span>(fn) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isUndefined(pollTimeout)) startPoller(100, setTimeout);
    pollFns.push(fn);
    <span class="Statement">return</span> fn;
  <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @param {number} interval How often should browser call poll functions (ms)</span>
<span class="Comment">   * @param {function()} setTimeout Reference to a real or fake `setTimeout` function.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Configures the poller to run in the specified intervals, using the specified</span>
<span class="Comment">   * setTimeout fn and kicks it off.</span>
<span class="Comment">   */</span>
  <span class="Identifier">function</span> startPoller(interval, setTimeout) <span class="Identifier">{</span>
    (<span class="Identifier">function</span> check() <span class="Identifier">{</span>
      forEach(pollFns, <span class="Identifier">function</span>(pollFn)<span class="Identifier">{</span> pollFn(); <span class="Identifier">}</span>);
      pollTimeout = setTimeout(check, interval);
    <span class="Identifier">}</span>)();
  <span class="Identifier">}</span>

  <span class="Comment">//////////////////////////////////////////////////////////////</span>
  <span class="Comment">// URL API</span>
  <span class="Comment">//////////////////////////////////////////////////////////////</span>

  <span class="Identifier">var</span> lastBrowserUrl = <span class="Statement">location</span>.href,
      baseElement = <span class="Statement">document</span>.find(<span class="Constant">'base'</span>),
      newLocation = <span class="Statement">null</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @name ng.$browser#url</span>
<span class="Comment">   * @methodOf ng.$browser</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * GETTER:</span>
<span class="Comment">   * Without any argument, this method just returns current value of location.href.</span>
<span class="Comment">   *</span>
<span class="Comment">   * SETTER:</span>
<span class="Comment">   * With at least one argument, this method sets url to new value.</span>
<span class="Comment">   * If html5 history api supported, pushState/replaceState is used, otherwise</span>
<span class="Comment">   * location.href/location.replace is used.</span>
<span class="Comment">   * Returns its own instance to allow chaining</span>
<span class="Comment">   *</span>
<span class="Comment">   * NOTE: this api is intended for use only by the $location service. Please use the</span>
<span class="Comment">   * {@link ng.$location $location service} to change url.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string} url New url (when used as setter)</span>
<span class="Comment">   * @param {boolean=} replace Should new url replace current history record ?</span>
<span class="Comment">   */</span>
  <span class="Statement">self</span>.url = <span class="Identifier">function</span>(url, replace) <span class="Identifier">{</span>
    <span class="Comment">// Android Browser BFCache causes location reference to become stale.</span>
    <span class="Statement">if</span> (<span class="Statement">location</span> !== <span class="Statement">window</span>.<span class="Statement">location</span>) <span class="Statement">location</span> = <span class="Statement">window</span>.<span class="Statement">location</span>;

    <span class="Comment">// setter</span>
    <span class="Statement">if</span> (url) <span class="Identifier">{</span>
      <span class="Statement">if</span> (lastBrowserUrl == url) <span class="Statement">return</span>;
      lastBrowserUrl = url;
      <span class="Statement">if</span> ($sniffer.history) <span class="Identifier">{</span>
        <span class="Statement">if</span> (replace) history.replaceState(<span class="Statement">null</span>, <span class="Constant">''</span>, url);
        <span class="Statement">else</span> <span class="Identifier">{</span>
          history.pushState(<span class="Statement">null</span>, <span class="Constant">''</span>, url);
          <span class="Comment">// Crazy Opera Bug: <a href="http://my.opera.com/community/forums/topic.dml?id=1185462">http://my.opera.com/community/forums/topic.dml?id=1185462</a></span>
          baseElement.attr(<span class="Constant">'href'</span>, baseElement.attr(<span class="Constant">'href'</span>));
        <span class="Identifier">}</span>
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        newLocation = url;
        <span class="Statement">if</span> (replace) <span class="Identifier">{</span>
          <span class="Statement">location</span>.replace(url);
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          <span class="Statement">location</span>.href = url;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
      <span class="Statement">return</span> <span class="Statement">self</span>;
    <span class="Comment">// getter</span>
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Comment">// - newLocation is a workaround for an IE7-9 issue with location.replace and location.href</span>
      <span class="Comment">//   methods not updating location.href synchronously.</span>
      <span class="Comment">// - the replacement is a workaround for <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=407172">https://bugzilla.mozilla.org/show_bug.cgi?id=407172</a></span>
      <span class="Statement">return</span> newLocation || <span class="Statement">location</span>.href.replace(<span class="Constant">/%27/g</span>,<span class="Constant">&quot;'&quot;</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Identifier">var</span> urlChangeListeners = <span class="Identifier">[]</span>,
      urlChangeInit = <span class="Constant">false</span>;

  <span class="Identifier">function</span> fireUrlChange() <span class="Identifier">{</span>
    newLocation = <span class="Statement">null</span>;
    <span class="Statement">if</span> (lastBrowserUrl == <span class="Statement">self</span>.url()) <span class="Statement">return</span>;

    lastBrowserUrl = <span class="Statement">self</span>.url();
    forEach(urlChangeListeners, <span class="Identifier">function</span>(listener) <span class="Identifier">{</span>
      listener(<span class="Statement">self</span>.url());
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>

  <span class="Comment">/**</span>
<span class="Comment">   * @name ng.$browser#onUrlChange</span>
<span class="Comment">   * @methodOf ng.$browser</span>
<span class="Comment">   * @</span><span class="Todo">TODO</span><span class="Comment">(vojta): refactor to use node's syntax for events</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Register callback function that will be called, when url changes.</span>
<span class="Comment">   *</span>
<span class="Comment">   * It's only called when the url is changed by outside of angular:</span>
<span class="Comment">   * - user types different url into address bar</span>
<span class="Comment">   * - user clicks on history (forward/back) button</span>
<span class="Comment">   * - user clicks on a link</span>
<span class="Comment">   *</span>
<span class="Comment">   * It's not called when url is changed by $browser.url() method</span>
<span class="Comment">   *</span>
<span class="Comment">   * The listener gets called with new url as parameter.</span>
<span class="Comment">   *</span>
<span class="Comment">   * NOTE: this api is intended for use only by the $location service. Please use the</span>
<span class="Comment">   * {@link ng.$location $location service} to monitor url changes in angular apps.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {function(string)} listener Listener function to be called when url changes.</span>
<span class="Comment">   * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.</span>
<span class="Comment">   */</span>
  <span class="Statement">self</span>.onUrlChange = <span class="Identifier">function</span>(callback) <span class="Identifier">{</span>
    <span class="Statement">if</span> (!urlChangeInit) <span class="Identifier">{</span>
      <span class="Comment">// We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)</span>
      <span class="Comment">// don't fire popstate when user change the address bar and don't fire hashchange when url</span>
      <span class="Comment">// changed by push/replaceState</span>

      <span class="Comment">// html5 history api - popstate event</span>
      <span class="Statement">if</span> ($sniffer.history) jqLite(<span class="Statement">window</span>).on(<span class="Constant">'popstate'</span>, fireUrlChange);
      <span class="Comment">// hashchange event</span>
      <span class="Statement">if</span> ($sniffer.hashchange) jqLite(<span class="Statement">window</span>).on(<span class="Constant">'hashchange'</span>, fireUrlChange);
      <span class="Comment">// polling</span>
      <span class="Statement">else</span> <span class="Statement">self</span>.addPollFn(fireUrlChange);

      urlChangeInit = <span class="Constant">true</span>;
    <span class="Identifier">}</span>

    urlChangeListeners.push(callback);
    <span class="Statement">return</span> callback;
  <span class="Identifier">}</span>;

  <span class="Comment">//////////////////////////////////////////////////////////////</span>
  <span class="Comment">// Misc API</span>
  <span class="Comment">//////////////////////////////////////////////////////////////</span>

  <span class="Comment">/**</span>
<span class="Comment">   * @name ng.$browser#baseHref</span>
<span class="Comment">   * @methodOf ng.$browser</span>
<span class="Comment">   * </span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Returns current &lt;base href&gt;</span>
<span class="Comment">   * (always relative - without domain)</span>
<span class="Comment">   *</span>
<span class="Comment">   * @returns {string=} current &lt;base href&gt;</span>
<span class="Comment">   */</span>
  <span class="Statement">self</span>.baseHref = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> href = baseElement.attr(<span class="Constant">'href'</span>);
    <span class="Statement">return</span> href ? href.replace(<span class="Constant">/^https?\:\/\/[^\/]*/</span>, <span class="Constant">''</span>) : <span class="Constant">''</span>;
  <span class="Identifier">}</span>;

  <span class="Comment">//////////////////////////////////////////////////////////////</span>
  <span class="Comment">// Cookies API</span>
  <span class="Comment">//////////////////////////////////////////////////////////////</span>
  <span class="Identifier">var</span> lastCookies = <span class="Identifier">{}</span>;
  <span class="Identifier">var</span> lastCookieString = <span class="Constant">''</span>;
  <span class="Identifier">var</span> cookiePath = <span class="Statement">self</span>.baseHref();

  <span class="Comment">/**</span>
<span class="Comment">   * @name ng.$browser#cookies</span>
<span class="Comment">   * @methodOf ng.$browser</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string=} name Cookie name</span>
<span class="Comment">   * @param {string=} value Cookie value</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * The cookies method provides a 'private' low level access to browser cookies.</span>
<span class="Comment">   * It is not meant to be used directly, use the $cookie service instead.</span>
<span class="Comment">   *</span>
<span class="Comment">   * The return values vary depending on the arguments that the method was called with as follows:</span>
<span class="Comment">   * </span>
<span class="Comment">   * - cookies() -&gt; hash of all cookies, this is NOT a copy of the internal state, so do not modify</span>
<span class="Comment">   *   it</span>
<span class="Comment">   * - cookies(name, value) -&gt; set name to value, if value is undefined delete the cookie</span>
<span class="Comment">   * - cookies(name) -&gt; the same as (name, undefined) == DELETES (no one calls it right now that</span>
<span class="Comment">   *   way)</span>
<span class="Comment">   * </span>
<span class="Comment">   * @returns {Object} Hash of all cookies (if called without any parameter)</span>
<span class="Comment">   */</span>
  <span class="Statement">self</span>.cookies = <span class="Identifier">function</span>(name, value) <span class="Identifier">{</span>
    <span class="Comment">/* global escape: false, unescape: false */</span>
    <span class="Identifier">var</span> cookieLength, cookieArray, cookie, i, index;

    <span class="Statement">if</span> (name) <span class="Identifier">{</span>
      <span class="Statement">if</span> (value === <span class="Statement">undefined</span>) <span class="Identifier">{</span>
        rawDocument.cookie = <span class="Statement">escape</span>(name) + <span class="Constant">&quot;=;path=&quot;</span> + cookiePath +
                                <span class="Constant">&quot;;expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">if</span> (isString(value)) <span class="Identifier">{</span>
          cookieLength = (rawDocument.cookie = <span class="Statement">escape</span>(name) + <span class="Constant">'='</span> + <span class="Statement">escape</span>(value) +
                                <span class="Constant">';path='</span> + cookiePath).length + 1;

          <span class="Comment">// per <a href="http://www.ietf.org/rfc/rfc2109.txt">http://www.ietf.org/rfc/rfc2109.txt</a> browser must allow at minimum:</span>
          <span class="Comment">// - 300 cookies</span>
          <span class="Comment">// - 20 cookies per unique domain</span>
          <span class="Comment">// - 4096 bytes per cookie</span>
          <span class="Statement">if</span> (cookieLength &gt; 4096) <span class="Identifier">{</span>
            $log.warn(<span class="Constant">&quot;Cookie '&quot;</span>+ name +
              <span class="Constant">&quot;' possibly not set or overflowed because it was too large (&quot;</span>+
              cookieLength + <span class="Constant">&quot; &gt; 4096 bytes)!&quot;</span>);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">if</span> (rawDocument.cookie !== lastCookieString) <span class="Identifier">{</span>
        lastCookieString = rawDocument.cookie;
        cookieArray = lastCookieString.split(<span class="Constant">&quot;; &quot;</span>);
        lastCookies = <span class="Identifier">{}</span>;

        <span class="Statement">for</span> (i = 0; i &lt; cookieArray.length; i++) <span class="Identifier">{</span>
          cookie = cookieArray<span class="Identifier">[</span>i<span class="Identifier">]</span>;
          index = cookie.indexOf(<span class="Constant">'='</span>);
          <span class="Statement">if</span> (index &gt; 0) <span class="Identifier">{</span> <span class="Comment">//ignore nameless cookies</span>
            name = <span class="Statement">unescape</span>(cookie.substring(0, index));
            <span class="Comment">// the first value that is seen for a cookie is the most</span>
            <span class="Comment">// specific one.  values for the same cookie name that</span>
            <span class="Comment">// follow are for less specific paths.</span>
            <span class="Statement">if</span> (lastCookies<span class="Identifier">[</span>name<span class="Identifier">]</span> === <span class="Statement">undefined</span>) <span class="Identifier">{</span>
              lastCookies<span class="Identifier">[</span>name<span class="Identifier">]</span> = <span class="Statement">unescape</span>(cookie.substring(index + 1));
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
      <span class="Statement">return</span> lastCookies;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;


  <span class="Comment">/**</span>
<span class="Comment">   * @name ng.$browser#defer</span>
<span class="Comment">   * @methodOf ng.$browser</span>
<span class="Comment">   * @param {function()} fn A function, who's execution should be deferred.</span>
<span class="Comment">   * @param {number=} [delay=0] of milliseconds to defer the function execution.</span>
<span class="Comment">   * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Executes a fn asynchronously via `setTimeout(fn, delay)`.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using</span>
<span class="Comment">   * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed</span>
<span class="Comment">   * via `$browser.defer.flush()`.</span>
<span class="Comment">   *</span>
<span class="Comment">   */</span>
  <span class="Statement">self</span>.defer = <span class="Identifier">function</span>(fn, delay) <span class="Identifier">{</span>
    <span class="Identifier">var</span> timeoutId;
    outstandingRequestCount++;
    timeoutId = setTimeout(<span class="Identifier">function</span>() <span class="Identifier">{</span>
      <span class="Statement">delete</span> pendingDeferIds<span class="Identifier">[</span>timeoutId<span class="Identifier">]</span>;
      completeOutstandingRequest(fn);
    <span class="Identifier">}</span>, delay || 0);
    pendingDeferIds<span class="Identifier">[</span>timeoutId<span class="Identifier">]</span> = <span class="Constant">true</span>;
    <span class="Statement">return</span> timeoutId;
  <span class="Identifier">}</span>;


  <span class="Comment">/**</span>
<span class="Comment">   * @name ng.$browser#defer.cancel</span>
<span class="Comment">   * @methodOf ng.$browser.defer</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Cancels a deferred task identified with `deferId`.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {*} deferId Token returned by the `$browser.defer` function.</span>
<span class="Comment">   * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully</span>
<span class="Comment">   *                    canceled.</span>
<span class="Comment">   */</span>
  <span class="Statement">self</span>.defer.cancel = <span class="Identifier">function</span>(deferId) <span class="Identifier">{</span>
    <span class="Statement">if</span> (pendingDeferIds<span class="Identifier">[</span>deferId<span class="Identifier">]</span>) <span class="Identifier">{</span>
      <span class="Statement">delete</span> pendingDeferIds<span class="Identifier">[</span>deferId<span class="Identifier">]</span>;
      clearTimeout(deferId);
      completeOutstandingRequest(noop);
      <span class="Statement">return</span> <span class="Constant">true</span>;
    <span class="Identifier">}</span>
    <span class="Statement">return</span> <span class="Constant">false</span>;
  <span class="Identifier">}</span>;

<span class="Identifier">}</span>

<span class="Identifier">function</span> $BrowserProvider()<span class="Identifier">{</span>
  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$window'</span>, <span class="Constant">'$log'</span>, <span class="Constant">'$sniffer'</span>, <span class="Constant">'$document'</span>,
      <span class="Identifier">function</span>( $<span class="Statement">window</span>,   $log,   $sniffer,   $<span class="Statement">document</span>)<span class="Identifier">{</span>
        <span class="Statement">return</span> <span class="Statement">new</span> Browser($<span class="Statement">window</span>, $<span class="Statement">document</span>, $log, $sniffer);
      <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$cacheFactory</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Factory that constructs cache objects and gives access to them.</span>
<span class="Comment"> * </span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * </span>
<span class="Comment"> *  var cache = $cacheFactory('cacheId');</span>
<span class="Comment"> *  expect($cacheFactory.get('cacheId')).toBe(cache);</span>
<span class="Comment"> *  expect($cacheFactory.get('noSuchCacheId')).not.toBeDefined();</span>
<span class="Comment"> *</span>
<span class="Comment"> *  cache.put(&quot;key&quot;, &quot;value&quot;);</span>
<span class="Comment"> *  cache.put(&quot;another key&quot;, &quot;another value&quot;);</span>
<span class="Comment"> *</span>
<span class="Comment"> *  // We've specified no options on creation</span>
<span class="Comment"> *  expect(cache.info()).toEqual({id: 'cacheId', size: 2}); </span>
<span class="Comment"> * </span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} cacheId Name or id of the newly created cache.</span>
<span class="Comment"> * @param {object=} options Options object that specifies the cache behavior. Properties:</span>
<span class="Comment"> *</span>
<span class="Comment"> *   - `{number=}` `capacity` — turns the cache into LRU cache.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @returns {object} Newly created cache object with the following set of methods:</span>
<span class="Comment"> *</span>
<span class="Comment"> * - `{object}` `info()` — Returns id, size, and options of cache.</span>
<span class="Comment"> * - `{{*}}` `put({string} key, {*} value)` — Puts a new key-value pair into the cache and returns</span>
<span class="Comment"> *   it.</span>
<span class="Comment"> * - `{{*}}` `get({string} key)` — Returns cached value for `key` or undefined for cache miss.</span>
<span class="Comment"> * - `{void}` `remove({string} key)` — Removes a key-value pair from the cache.</span>
<span class="Comment"> * - `{void}` `removeAll()` — Removes all cached values.</span>
<span class="Comment"> * - `{void}` `destroy()` — Removes references to this cache from $cacheFactory.</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $CacheFactoryProvider() <span class="Identifier">{</span>

  <span class="Identifier">this</span>.$get = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> caches = <span class="Identifier">{}</span>;

    <span class="Identifier">function</span> cacheFactory(cacheId, options) <span class="Identifier">{</span>
      <span class="Statement">if</span> (cacheId <span class="Statement">in</span> caches) <span class="Identifier">{</span>
        <span class="Statement">throw</span> minErr(<span class="Constant">'$cacheFactory'</span>)(<span class="Constant">'iid'</span>, <span class="Constant">&quot;CacheId '{0}' is already taken!&quot;</span>, cacheId);
      <span class="Identifier">}</span>

      <span class="Identifier">var</span> size = 0,
          stats = extend(<span class="Identifier">{}</span>, options, <span class="Identifier">{</span>id: cacheId<span class="Identifier">}</span>),
          data = <span class="Identifier">{}</span>,
          capacity = (options &amp;&amp; options.capacity) || <span class="Type">Number</span>.MAX_VALUE,
          lruHash = <span class="Identifier">{}</span>,
          freshEnd = <span class="Statement">null</span>,
          staleEnd = <span class="Statement">null</span>;

      <span class="Statement">return</span> caches<span class="Identifier">[</span>cacheId<span class="Identifier">]</span> = <span class="Identifier">{</span>

        put: <span class="Identifier">function</span>(key, value) <span class="Identifier">{</span>
          <span class="Identifier">var</span> lruEntry = lruHash<span class="Identifier">[</span>key<span class="Identifier">]</span> || (lruHash<span class="Identifier">[</span>key<span class="Identifier">]</span> = <span class="Identifier">{</span>key: key<span class="Identifier">}</span>);

          refresh(lruEntry);

          <span class="Statement">if</span> (isUndefined(value)) <span class="Statement">return</span>;
          <span class="Statement">if</span> (!(key <span class="Statement">in</span> data)) size++;
          data<span class="Identifier">[</span>key<span class="Identifier">]</span> = value;

          <span class="Statement">if</span> (size &gt; capacity) <span class="Identifier">{</span>
            <span class="Identifier">this</span>.remove(staleEnd.key);
          <span class="Identifier">}</span>

          <span class="Statement">return</span> value;
        <span class="Identifier">}</span>,


        get: <span class="Identifier">function</span>(key) <span class="Identifier">{</span>
          <span class="Identifier">var</span> lruEntry = lruHash<span class="Identifier">[</span>key<span class="Identifier">]</span>;

          <span class="Statement">if</span> (!lruEntry) <span class="Statement">return</span>;

          refresh(lruEntry);

          <span class="Statement">return</span> data<span class="Identifier">[</span>key<span class="Identifier">]</span>;
        <span class="Identifier">}</span>,


        remove: <span class="Identifier">function</span>(key) <span class="Identifier">{</span>
          <span class="Identifier">var</span> lruEntry = lruHash<span class="Identifier">[</span>key<span class="Identifier">]</span>;

          <span class="Statement">if</span> (!lruEntry) <span class="Statement">return</span>;

          <span class="Statement">if</span> (lruEntry == freshEnd) freshEnd = lruEntry.p;
          <span class="Statement">if</span> (lruEntry == staleEnd) staleEnd = lruEntry.n;
          link(lruEntry.n,lruEntry.p);

          <span class="Statement">delete</span> lruHash<span class="Identifier">[</span>key<span class="Identifier">]</span>;
          <span class="Statement">delete</span> data<span class="Identifier">[</span>key<span class="Identifier">]</span>;
          size--;
        <span class="Identifier">}</span>,


        removeAll: <span class="Identifier">function</span>() <span class="Identifier">{</span>
          data = <span class="Identifier">{}</span>;
          size = 0;
          lruHash = <span class="Identifier">{}</span>;
          freshEnd = staleEnd = <span class="Statement">null</span>;
        <span class="Identifier">}</span>,


        destroy: <span class="Identifier">function</span>() <span class="Identifier">{</span>
          data = <span class="Statement">null</span>;
          stats = <span class="Statement">null</span>;
          lruHash = <span class="Statement">null</span>;
          <span class="Statement">delete</span> caches<span class="Identifier">[</span>cacheId<span class="Identifier">]</span>;
        <span class="Identifier">}</span>,


        info: <span class="Identifier">function</span>() <span class="Identifier">{</span>
          <span class="Statement">return</span> extend(<span class="Identifier">{}</span>, stats, <span class="Identifier">{</span>size: size<span class="Identifier">}</span>);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>;


      <span class="Comment">/**</span>
<span class="Comment">       * makes the `entry` the freshEnd of the LRU linked list</span>
<span class="Comment">       */</span>
      <span class="Identifier">function</span> refresh(entry) <span class="Identifier">{</span>
        <span class="Statement">if</span> (entry != freshEnd) <span class="Identifier">{</span>
          <span class="Statement">if</span> (!staleEnd) <span class="Identifier">{</span>
            staleEnd = entry;
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (staleEnd == entry) <span class="Identifier">{</span>
            staleEnd = entry.n;
          <span class="Identifier">}</span>

          link(entry.n, entry.p);
          link(entry, freshEnd);
          freshEnd = entry;
          freshEnd.n = <span class="Statement">null</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>


      <span class="Comment">/**</span>
<span class="Comment">       * bidirectionally links two entries of the LRU linked list</span>
<span class="Comment">       */</span>
      <span class="Identifier">function</span> link(nextEntry, prevEntry) <span class="Identifier">{</span>
        <span class="Statement">if</span> (nextEntry != prevEntry) <span class="Identifier">{</span>
          <span class="Statement">if</span> (nextEntry) nextEntry.p = prevEntry; <span class="Comment">//p stands for previous, 'prev' didn't minify</span>
          <span class="Statement">if</span> (prevEntry) prevEntry.n = nextEntry; <span class="Comment">//n stands for next, 'next' didn't minify</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>


  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$cacheFactory#info</span>
<span class="Comment">   * @methodOf ng.$cacheFactory</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Get information about all the of the caches that have been created</span>
<span class="Comment">   *</span>
<span class="Comment">   * @returns {Object} - key-value map of `cacheId` to the result of calling `cache#info`</span>
<span class="Comment">   */</span>
    cacheFactory.info = <span class="Identifier">function</span>() <span class="Identifier">{</span>
      <span class="Identifier">var</span> info = <span class="Identifier">{}</span>;
      forEach(caches, <span class="Identifier">function</span>(cache, cacheId) <span class="Identifier">{</span>
        info<span class="Identifier">[</span>cacheId<span class="Identifier">]</span> = cache.info();
      <span class="Identifier">}</span>);
      <span class="Statement">return</span> info;
    <span class="Identifier">}</span>;


  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$cacheFactory#get</span>
<span class="Comment">   * @methodOf ng.$cacheFactory</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Get access to a cache object by the `cacheId` used when it was created.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string} cacheId Name or id of a cache to access.</span>
<span class="Comment">   * @returns {object} Cache object identified by the cacheId or undefined if no such cache.</span>
<span class="Comment">   */</span>
    cacheFactory.get = <span class="Identifier">function</span>(cacheId) <span class="Identifier">{</span>
      <span class="Statement">return</span> caches<span class="Identifier">[</span>cacheId<span class="Identifier">]</span>;
    <span class="Identifier">}</span>;


    <span class="Statement">return</span> cacheFactory;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$templateCache</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The first time a template is used, it is loaded in the template cache for quick retrieval. You</span>
<span class="Comment"> * can load templates directly into the cache in a `script` tag, or by consuming the</span>
<span class="Comment"> * `$templateCache` service directly.</span>
<span class="Comment"> * </span>
<span class="Comment"> * Adding via the `script` tag:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * &lt;html ng-app&gt;</span>
<span class="Comment"> * &lt;head&gt;</span>
<span class="Comment"> * &lt;script type=&quot;text/ng-template&quot; id=&quot;templateId.html&quot;&gt;</span>
<span class="Comment"> *   This is the content of the template</span>
<span class="Comment"> * &lt;/script&gt;</span>
<span class="Comment"> * &lt;/head&gt;</span>
<span class="Comment"> *   ...</span>
<span class="Comment"> * &lt;/html&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> * </span>
<span class="Comment"> * **Note:** the `script` tag containing the template does not need to be included in the `head` of</span>
<span class="Comment"> * the document, but it must be below the `ng-app` definition.</span>
<span class="Comment"> * </span>
<span class="Comment"> * Adding via the $templateCache service:</span>
<span class="Comment"> * </span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * var myApp = angular.module('myApp', []);</span>
<span class="Comment"> * myApp.run(function($templateCache) {</span>
<span class="Comment"> *   $templateCache.put('templateId.html', 'This is the content of the template');</span>
<span class="Comment"> * });</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> * </span>
<span class="Comment"> * To retrieve the template later, simply use it in your HTML:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * &lt;div ng-include=&quot; 'templateId.html' &quot;&gt;&lt;/div&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> * </span>
<span class="Comment"> * or get it via Javascript:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * $templateCache.get('templateId.html')</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> * </span>
<span class="Comment"> * See {@link ng.$cacheFactory $cacheFactory}.</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $TemplateCacheProvider() <span class="Identifier">{</span>
  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$cacheFactory'</span>, <span class="Identifier">function</span>($cacheFactory) <span class="Identifier">{</span>
    <span class="Statement">return</span> $cacheFactory(<span class="Constant">'templates'</span>);
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Comment">/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!</span>
<span class="Comment"> *</span>
<span class="Comment"> * DOM-related variables:</span>
<span class="Comment"> *</span>
<span class="Comment"> * - &quot;node&quot; - DOM Node</span>
<span class="Comment"> * - &quot;element&quot; - DOM Element or Node</span>
<span class="Comment"> * - &quot;$node&quot; or &quot;$element&quot; - jqLite-wrapped node or element</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * Compiler related stuff:</span>
<span class="Comment"> *</span>
<span class="Comment"> * - &quot;linkFn&quot; - linking fn of a single directive</span>
<span class="Comment"> * - &quot;nodeLinkFn&quot; - function that aggregates all linking fns for a particular node</span>
<span class="Comment"> * - &quot;childLinkFn&quot; -  function that aggregates all linking fns for child nodes of a particular node</span>
<span class="Comment"> * - &quot;compositeLinkFn&quot; - function that aggregates all linking fns for a compilation root (nodeList)</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name ng.$compile</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Compiles a piece of HTML string or DOM into a template and produces a template function, which</span>
<span class="Comment"> * can then be used to link {@link ng.$rootScope.Scope `scope`} and the template together.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The compilation is a process of walking the DOM tree and matching DOM elements to</span>
<span class="Comment"> * {@link ng.$compileProvider#methods_directive directives}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;div class=&quot;alert alert-warning&quot;&gt;</span>
<span class="Comment"> * **Note:** This document is an in-depth reference of all directive options.</span>
<span class="Comment"> * For a gentle introduction to directives with examples of common use cases,</span>
<span class="Comment"> * see the {@link guide/directive directive guide}.</span>
<span class="Comment"> * &lt;/div&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## Comprehensive Directive API</span>
<span class="Comment"> *</span>
<span class="Comment"> * There are many different options for a directive.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The difference resides in the return value of the factory function.</span>
<span class="Comment"> * You can either return a &quot;Directive Definition Object&quot; (see below) that defines the directive properties,</span>
<span class="Comment"> * or just the `postLink` function (all other properties will have the default values).</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;div class=&quot;alert alert-success&quot;&gt;</span>
<span class="Comment"> * **Best Practice:** It's recommended to use the &quot;directive definition object&quot; form.</span>
<span class="Comment"> * &lt;/div&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * Here's an example directive declared with a Directive Definition Object:</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   var myModule = angular.module(...);</span>
<span class="Comment"> *</span>
<span class="Comment"> *   myModule.directive('directiveName', function factory(injectables) {</span>
<span class="Comment"> *     var directiveDefinitionObject = {</span>
<span class="Comment"> *       priority: 0,</span>
<span class="Comment"> *       template: '&lt;div&gt;&lt;/div&gt;', // or // function(tElement, tAttrs) { ... },</span>
<span class="Comment"> *       // or</span>
<span class="Comment"> *       // templateUrl: 'directive.html', // or // function(tElement, tAttrs) { ... },</span>
<span class="Comment"> *       replace: false,</span>
<span class="Comment"> *       transclude: false,</span>
<span class="Comment"> *       restrict: 'A',</span>
<span class="Comment"> *       scope: false,</span>
<span class="Comment"> *       controller: function($scope, $element, $attrs, $transclude, otherInjectables) { ... },</span>
<span class="Comment"> *       require: 'siblingDirectiveName', // or // ['^parentDirectiveName', '?optionalDirectiveName', '?^optionalParent'],</span>
<span class="Comment"> *       compile: function compile(tElement, tAttrs, transclude) {</span>
<span class="Comment"> *         return {</span>
<span class="Comment"> *           pre: function preLink(scope, iElement, iAttrs, controller) { ... },</span>
<span class="Comment"> *           post: function postLink(scope, iElement, iAttrs, controller) { ... }</span>
<span class="Comment"> *         }</span>
<span class="Comment"> *         // or</span>
<span class="Comment"> *         // return function postLink( ... ) { ... }</span>
<span class="Comment"> *       },</span>
<span class="Comment"> *       // or</span>
<span class="Comment"> *       // link: {</span>
<span class="Comment"> *       //  pre: function preLink(scope, iElement, iAttrs, controller) { ... },</span>
<span class="Comment"> *       //  post: function postLink(scope, iElement, iAttrs, controller) { ... }</span>
<span class="Comment"> *       // }</span>
<span class="Comment"> *       // or</span>
<span class="Comment"> *       // link: function postLink( ... ) { ... }</span>
<span class="Comment"> *     };</span>
<span class="Comment"> *     return directiveDefinitionObject;</span>
<span class="Comment"> *   });</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;div class=&quot;alert alert-warning&quot;&gt;</span>
<span class="Comment"> * **Note:** Any unspecified options will use the default value. You can see the default values below.</span>
<span class="Comment"> * &lt;/div&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * Therefore the above can be simplified as:</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   var myModule = angular.module(...);</span>
<span class="Comment"> *</span>
<span class="Comment"> *   myModule.directive('directiveName', function factory(injectables) {</span>
<span class="Comment"> *     var directiveDefinitionObject = {</span>
<span class="Comment"> *       link: function postLink(scope, iElement, iAttrs) { ... }</span>
<span class="Comment"> *     };</span>
<span class="Comment"> *     return directiveDefinitionObject;</span>
<span class="Comment"> *     // or</span>
<span class="Comment"> *     // return function postLink(scope, iElement, iAttrs) { ... }</span>
<span class="Comment"> *   });</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * ### Directive Definition Object</span>
<span class="Comment"> *</span>
<span class="Comment"> * The directive definition object provides instructions to the {@link api/ng.$compile</span>
<span class="Comment"> * compiler}. The attributes are:</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### `priority`</span>
<span class="Comment"> * When there are multiple directives defined on a single DOM element, sometimes it</span>
<span class="Comment"> * is necessary to specify the order in which the directives are applied. The `priority` is used</span>
<span class="Comment"> * to sort the directives before their `compile` functions get called. Priority is defined as a</span>
<span class="Comment"> * number. Directives with greater numerical `priority` are compiled first. Pre-link functions</span>
<span class="Comment"> * are also run in priority order, but post-link functions are run in reverse order. The order</span>
<span class="Comment"> * of directives with the same priority is undefined. The default priority is `0`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### `terminal`</span>
<span class="Comment"> * If set to true then the current `priority` will be the last set of directives</span>
<span class="Comment"> * which will execute (any directives at the current priority will still execute</span>
<span class="Comment"> * as the order of execution on same `priority` is undefined).</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### `scope`</span>
<span class="Comment"> * **If set to `true`,** then a new scope will be created for this directive. If multiple directives on the</span>
<span class="Comment"> * same element request a new scope, only one new scope is created. The new scope rule does not</span>
<span class="Comment"> * apply for the root of the template since the root of the template always gets a new scope.</span>
<span class="Comment"> *</span>
<span class="Comment"> * **If set to `{}` (object hash),** then a new &quot;isolate&quot; scope is created. The 'isolate' scope differs from</span>
<span class="Comment"> * normal scope in that it does not prototypically inherit from the parent scope. This is useful</span>
<span class="Comment"> * when creating reusable components, which should not accidentally read or modify data in the</span>
<span class="Comment"> * parent scope.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The 'isolate' scope takes an object hash which defines a set of local scope properties</span>
<span class="Comment"> * derived from the parent scope. These local properties are useful for aliasing values for</span>
<span class="Comment"> * templates. Locals definition is a hash of local scope property to its source:</span>
<span class="Comment"> *</span>
<span class="Comment"> * * `@` or `@attr` - bind a local scope property to the value of DOM attribute. The result is</span>
<span class="Comment"> *   always a string since DOM attributes are strings. If no `attr` name is specified  then the</span>
<span class="Comment"> *   attribute name is assumed to be the same as the local name.</span>
<span class="Comment"> *   Given `&lt;widget my-attr=&quot;hello {{name}}&quot;&gt;` and widget definition</span>
<span class="Comment"> *   of `scope: { localName:'@myAttr' }`, then widget scope property `localName` will reflect</span>
<span class="Comment"> *   the interpolated value of `hello {{name}}`. As the `name` attribute changes so will the</span>
<span class="Comment"> *   `localName` property on the widget scope. The `name` is read from the parent scope (not</span>
<span class="Comment"> *   component scope).</span>
<span class="Comment"> *</span>
<span class="Comment"> * * `=` or `=attr` - set up bi-directional binding between a local scope property and the</span>
<span class="Comment"> *   parent scope property of name defined via the value of the `attr` attribute. If no `attr`</span>
<span class="Comment"> *   name is specified then the attribute name is assumed to be the same as the local name.</span>
<span class="Comment"> *   Given `&lt;widget my-attr=&quot;parentModel&quot;&gt;` and widget definition of</span>
<span class="Comment"> *   `scope: { localModel:'=myAttr' }`, then widget scope property `localModel` will reflect the</span>
<span class="Comment"> *   value of `parentModel` on the parent scope. Any changes to `parentModel` will be reflected</span>
<span class="Comment"> *   in `localModel` and any changes in `localModel` will reflect in `parentModel`. If the parent</span>
<span class="Comment"> *   scope property doesn't exist, it will throw a NON_ASSIGNABLE_MODEL_EXPRESSION exception. You</span>
<span class="Comment"> *   can avoid this behavior using `=?` or `=?attr` in order to flag the property as optional.</span>
<span class="Comment"> *</span>
<span class="Comment"> * * `&amp;` or `&amp;attr` - provides a way to execute an expression in the context of the parent scope.</span>
<span class="Comment"> *   If no `attr` name is specified then the attribute name is assumed to be the same as the</span>
<span class="Comment"> *   local name. Given `&lt;widget my-attr=&quot;count = count + value&quot;&gt;` and widget definition of</span>
<span class="Comment"> *   `scope: { localFn:'&amp;myAttr' }`, then isolate scope property `localFn` will point to</span>
<span class="Comment"> *   a function wrapper for the `count = count + value` expression. Often it's desirable to</span>
<span class="Comment"> *   pass data from the isolated scope via an expression and to the parent scope, this can be</span>
<span class="Comment"> *   done by passing a map of local variable names and values into the expression wrapper fn.</span>
<span class="Comment"> *   For example, if the expression is `increment(amount)` then we can specify the amount value</span>
<span class="Comment"> *   by calling the `localFn` as `localFn({amount: 22})`.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### `controller`</span>
<span class="Comment"> * Controller constructor function. The controller is instantiated before the</span>
<span class="Comment"> * pre-linking phase and it is shared with other directives (see</span>
<span class="Comment"> * `require` attribute). This allows the directives to communicate with each other and augment</span>
<span class="Comment"> * each other's behavior. The controller is injectable (and supports bracket notation) with the following locals:</span>
<span class="Comment"> *</span>
<span class="Comment"> * * `$scope` - Current scope associated with the element</span>
<span class="Comment"> * * `$element` - Current element</span>
<span class="Comment"> * * `$attrs` - Current attributes object for the element</span>
<span class="Comment"> * * `$transclude` - A transclude linking function pre-bound to the correct transclusion scope.</span>
<span class="Comment"> *    The scope can be overridden by an optional first argument.</span>
<span class="Comment"> *   `function([scope], cloneLinkingFn)`.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### `require`</span>
<span class="Comment"> * Require another directive and inject its controller as the fourth argument to the linking function. The</span>
<span class="Comment"> * `require` takes a string name (or array of strings) of the directive(s) to pass in. If an array is used, the</span>
<span class="Comment"> * injected argument will be an array in corresponding order. If no such directive can be</span>
<span class="Comment"> * found, or if the directive does not have a controller, then an error is raised. The name can be prefixed with:</span>
<span class="Comment"> *</span>
<span class="Comment"> * * (no prefix) - Locate the required controller on the current element. Throw an error if not found.</span>
<span class="Comment"> * * `?` - Attempt to locate the required controller or pass `null` to the `link` fn if not found.</span>
<span class="Comment"> * * `^` - Locate the required controller by searching the element's parents. Throw an error if not found.</span>
<span class="Comment"> * * `?^` - Attempt to locate the required controller by searching the element's parents or pass `null` to the</span>
<span class="Comment"> *   `link` fn if not found.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### `controllerAs`</span>
<span class="Comment"> * Controller alias at the directive scope. An alias for the controller so it</span>
<span class="Comment"> * can be referenced at the directive template. The directive needs to define a scope for this</span>
<span class="Comment"> * configuration to be used. Useful in the case when directive is used as component.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### `restrict`</span>
<span class="Comment"> * String of subset of `EACM` which restricts the directive to a specific directive</span>
<span class="Comment"> * declaration style. If omitted, the default (attributes only) is used.</span>
<span class="Comment"> *</span>
<span class="Comment"> * * `E` - Element name: `&lt;my-directive&gt;&lt;/my-directive&gt;`</span>
<span class="Comment"> * * `A` - Attribute (default): `&lt;div my-directive=&quot;exp&quot;&gt;&lt;/div&gt;`</span>
<span class="Comment"> * * `C` - Class: `&lt;div class=&quot;my-directive: exp;&quot;&gt;&lt;/div&gt;`</span>
<span class="Comment"> * * `M` - Comment: `&lt;!-- directive: my-directive exp --&gt;`</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### `template`</span>
<span class="Comment"> * replace the current element with the contents of the HTML. The replacement process</span>
<span class="Comment"> * migrates all of the attributes / classes from the old element to the new one. See the</span>
<span class="Comment"> * {@link guide/directive#creating-custom-directives_creating-directives_template-expanding-directive</span>
<span class="Comment"> * Directives Guide} for an example.</span>
<span class="Comment"> *</span>
<span class="Comment"> * You can specify `template` as a string representing the template or as a function which takes</span>
<span class="Comment"> * two arguments `tElement` and `tAttrs` (described in the `compile` function api below) and</span>
<span class="Comment"> * returns a string value representing the template.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### `templateUrl`</span>
<span class="Comment"> * Same as `template` but the template is loaded from the specified URL. Because</span>
<span class="Comment"> * the template loading is asynchronous the compilation/linking is suspended until the template</span>
<span class="Comment"> * is loaded.</span>
<span class="Comment"> *</span>
<span class="Comment"> * You can specify `templateUrl` as a string representing the URL or as a function which takes two</span>
<span class="Comment"> * arguments `tElement` and `tAttrs` (described in the `compile` function api below) and returns</span>
<span class="Comment"> * a string value representing the url.  In either case, the template URL is passed through {@link</span>
<span class="Comment"> * api/ng.$sce#methods_getTrustedResourceUrl $sce.getTrustedResourceUrl}.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### `replace`</span>
<span class="Comment"> * specify where the template should be inserted. Defaults to `false`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * * `true` - the template will replace the current element.</span>
<span class="Comment"> * * `false` - the template will replace the contents of the current element.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### `transclude`</span>
<span class="Comment"> * compile the content of the element and make it available to the directive.</span>
<span class="Comment"> * Typically used with {@link api/ng.directive:ngTransclude</span>
<span class="Comment"> * ngTransclude}. The advantage of transclusion is that the linking function receives a</span>
<span class="Comment"> * transclusion function which is pre-bound to the correct scope. In a typical setup the widget</span>
<span class="Comment"> * creates an `isolate` scope, but the transclusion is not a child, but a sibling of the `isolate`</span>
<span class="Comment"> * scope. This makes it possible for the widget to have private state, and the transclusion to</span>
<span class="Comment"> * be bound to the parent (pre-`isolate`) scope.</span>
<span class="Comment"> *</span>
<span class="Comment"> * * `true` - transclude the content of the directive.</span>
<span class="Comment"> * * `'element'` - transclude the whole element including any directives defined at lower priority.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### `compile`</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   function compile(tElement, tAttrs, transclude) { ... }</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * The compile function deals with transforming the template DOM. Since most directives do not do</span>
<span class="Comment"> * template transformation, it is not used often. Examples that require compile functions are</span>
<span class="Comment"> * directives that transform template DOM, such as {@link</span>
<span class="Comment"> * api/ng.directive:ngRepeat ngRepeat}, or load the contents</span>
<span class="Comment"> * asynchronously, such as {@link api/ngRoute.directive:ngView ngView}. The</span>
<span class="Comment"> * compile function takes the following arguments.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * `tElement` - template element - The element where the directive has been declared. It is</span>
<span class="Comment"> *     safe to do template transformation on the element and child elements only.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * `tAttrs` - template attributes - Normalized list of attributes declared on this element shared</span>
<span class="Comment"> *     between all directive compile functions.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * `transclude` -  [*DEPRECATED*!] A transclude linking function: `function(scope, cloneLinkingFn)`</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;div class=&quot;alert alert-warning&quot;&gt;</span>
<span class="Comment"> * **Note:** The template instance and the link instance may be different objects if the template has</span>
<span class="Comment"> * been cloned. For this reason it is **not** safe to do anything other than DOM transformations that</span>
<span class="Comment"> * apply to all cloned DOM nodes within the compile function. Specifically, DOM listener registration</span>
<span class="Comment"> * should be done in a linking function rather than in a compile function.</span>
<span class="Comment"> * &lt;/div&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;div class=&quot;alert alert-error&quot;&gt;</span>
<span class="Comment"> * **Note:** The `transclude` function that is passed to the compile function is deprecated, as it</span>
<span class="Comment"> *   e.g. does not know about the right outer scope. Please use the transclude function that is passed</span>
<span class="Comment"> *   to the link function instead.</span>
<span class="Comment"> * &lt;/div&gt;</span>

<span class="Comment"> * A compile function can have a return value which can be either a function or an object.</span>
<span class="Comment"> *</span>
<span class="Comment"> * * returning a (post-link) function - is equivalent to registering the linking function via the</span>
<span class="Comment"> *   `link` property of the config object when the compile function is empty.</span>
<span class="Comment"> *</span>
<span class="Comment"> * * returning an object with function(s) registered via `pre` and `post` properties - allows you to</span>
<span class="Comment"> *   control when a linking function should be called during the linking phase. See info about</span>
<span class="Comment"> *   pre-linking and post-linking functions below.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### `link`</span>
<span class="Comment"> * This property is used only if the `compile` property is not defined.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   function link(scope, iElement, iAttrs, controller, transcludeFn) { ... }</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * The link function is responsible for registering DOM listeners as well as updating the DOM. It is</span>
<span class="Comment"> * executed after the template has been cloned. This is where most of the directive logic will be</span>
<span class="Comment"> * put.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * `scope` - {@link api/ng.$rootScope.Scope Scope} - The scope to be used by the</span>
<span class="Comment"> *     directive for registering {@link api/ng.$rootScope.Scope#methods_$watch watches}.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * `iElement` - instance element - The element where the directive is to be used. It is safe to</span>
<span class="Comment"> *     manipulate the children of the element only in `postLink` function since the children have</span>
<span class="Comment"> *     already been linked.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * `iAttrs` - instance attributes - Normalized list of attributes declared on this element shared</span>
<span class="Comment"> *     between all directive linking functions.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * `controller` - a controller instance - A controller instance if at least one directive on the</span>
<span class="Comment"> *     element defines a controller. The controller is shared among all the directives, which allows</span>
<span class="Comment"> *     the directives to use the controllers as a communication channel.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * `transcludeFn` - A transclude linking function pre-bound to the correct transclusion scope.</span>
<span class="Comment"> *     The scope can be overridden by an optional first argument. This is the same as the `$transclude`</span>
<span class="Comment"> *     parameter of directive controllers.</span>
<span class="Comment"> *     `function([scope], cloneLinkingFn)`.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### Pre-linking function</span>
<span class="Comment"> *</span>
<span class="Comment"> * Executed before the child elements are linked. Not safe to do DOM transformation since the</span>
<span class="Comment"> * compiler linking function will fail to locate the correct elements for linking.</span>
<span class="Comment"> *</span>
<span class="Comment"> * #### Post-linking function</span>
<span class="Comment"> *</span>
<span class="Comment"> * Executed after the child elements are linked. It is safe to do DOM transformation in the post-linking function.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;a name=&quot;Attributes&quot;&gt;&lt;/a&gt;</span>
<span class="Comment"> * ### Attributes</span>
<span class="Comment"> *</span>
<span class="Comment"> * The {@link api/ng.$compile.directive.Attributes Attributes} object - passed as a parameter in the</span>
<span class="Comment"> * `link()` or `compile()` functions. It has a variety of uses.</span>
<span class="Comment"> *</span>
<span class="Comment"> * accessing *Normalized attribute names:*</span>
<span class="Comment"> * Directives like 'ngBind' can be expressed in many ways: 'ng:bind', `data-ng-bind`, or 'x-ng-bind'.</span>
<span class="Comment"> * the attributes object allows for normalized access to</span>
<span class="Comment"> *   the attributes.</span>
<span class="Comment"> *</span>
<span class="Comment"> * * *Directive inter-communication:* All directives share the same instance of the attributes</span>
<span class="Comment"> *   object which allows the directives to use the attributes object as inter directive</span>
<span class="Comment"> *   communication.</span>
<span class="Comment"> *</span>
<span class="Comment"> * * *Supports interpolation:* Interpolation attributes are assigned to the attribute object</span>
<span class="Comment"> *   allowing other directives to read the interpolated value.</span>
<span class="Comment"> *</span>
<span class="Comment"> * * *Observing interpolated attributes:* Use `$observe` to observe the value changes of attributes</span>
<span class="Comment"> *   that contain interpolation (e.g. `src=&quot;{{bar}}&quot;`). Not only is this very efficient but it's also</span>
<span class="Comment"> *   the only way to easily get the actual value because during the linking phase the interpolation</span>
<span class="Comment"> *   hasn't been evaluated yet and so the value is at this time set to `undefined`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * function linkingFn(scope, elm, attrs, ctrl) {</span>
<span class="Comment"> *   // get the attribute value</span>
<span class="Comment"> *   console.log(attrs.ngModel);</span>
<span class="Comment"> *</span>
<span class="Comment"> *   // change the attribute</span>
<span class="Comment"> *   attrs.$set('ngModel', 'new value');</span>
<span class="Comment"> *</span>
<span class="Comment"> *   // observe changes to interpolated attribute</span>
<span class="Comment"> *   attrs.$observe('ngModel', function(value) {</span>
<span class="Comment"> *     console.log('ngModel has changed value to ' + value);</span>
<span class="Comment"> *   });</span>
<span class="Comment"> * }</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * Below is an example using `$compileProvider`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;div class=&quot;alert alert-warning&quot;&gt;</span>
<span class="Comment"> * **Note**: Typically directives are registered with `module.directive`. The example below is</span>
<span class="Comment"> * to illustrate how `$compile` works.</span>
<span class="Comment"> * &lt;/div&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> &lt;doc:example module=&quot;compile&quot;&gt;</span>
<span class="Comment">   &lt;doc:source&gt;</span>
<span class="Comment">    &lt;script&gt;</span>
<span class="Comment">      angular.module('compile', [], function($compileProvider) {</span>
<span class="Comment">        // configure new 'compile' directive by passing a directive</span>
<span class="Comment">        // factory function. The factory function injects the '$compile'</span>
<span class="Comment">        $compileProvider.directive('compile', function($compile) {</span>
<span class="Comment">          // directive factory creates a link function</span>
<span class="Comment">          return function(scope, element, attrs) {</span>
<span class="Comment">            scope.$watch(</span>
<span class="Comment">              function(scope) {</span>
<span class="Comment">                 // watch the 'compile' expression for changes</span>
<span class="Comment">                return scope.$eval(attrs.compile);</span>
<span class="Comment">              },</span>
<span class="Comment">              function(value) {</span>
<span class="Comment">                // when the 'compile' expression changes</span>
<span class="Comment">                // assign it into the current DOM</span>
<span class="Comment">                element.html(value);</span>

<span class="Comment">                // compile the new DOM and link it to the current</span>
<span class="Comment">                // scope.</span>
<span class="Comment">                // NOTE: we only compile .childNodes so that</span>
<span class="Comment">                // we don't get into infinite loop compiling ourselves</span>
<span class="Comment">                $compile(element.contents())(scope);</span>
<span class="Comment">              }</span>
<span class="Comment">            );</span>
<span class="Comment">          };</span>
<span class="Comment">        })</span>
<span class="Comment">      });</span>

<span class="Comment">      function Ctrl($scope) {</span>
<span class="Comment">        $scope.name = 'Angular';</span>
<span class="Comment">        $scope.html = 'Hello {{name}}';</span>
<span class="Comment">      }</span>
<span class="Comment">    &lt;/script&gt;</span>
<span class="Comment">    &lt;div ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">      &lt;input ng-model=&quot;name&quot;&gt; &lt;br&gt;</span>
<span class="Comment">      &lt;textarea ng-model=&quot;html&quot;&gt;&lt;/textarea&gt; &lt;br&gt;</span>
<span class="Comment">      &lt;div compile=&quot;html&quot;&gt;&lt;/div&gt;</span>
<span class="Comment">    &lt;/div&gt;</span>
<span class="Comment">   &lt;/doc:source&gt;</span>
<span class="Comment">   &lt;doc:scenario&gt;</span>
<span class="Comment">     it('should auto compile', function() {</span>
<span class="Comment">       expect(element('div[compile]').text()).toBe('Hello Angular');</span>
<span class="Comment">       input('html').enter('{{name}}!');</span>
<span class="Comment">       expect(element('div[compile]').text()).toBe('Angular!');</span>
<span class="Comment">     });</span>
<span class="Comment">   &lt;/doc:scenario&gt;</span>
<span class="Comment"> &lt;/doc:example&gt;</span>

<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string|DOMElement} element Element or HTML string to compile into a template function.</span>
<span class="Comment"> * @param {function(angular.Scope[, cloneAttachFn]} transclude function available to directives.</span>
<span class="Comment"> * @param {number} maxPriority only apply directives lower then given priority (Only effects the</span>
<span class="Comment"> *                 root element(s), not their children)</span>
<span class="Comment"> * @returns {function(scope[, cloneAttachFn])} a link function which is used to bind template</span>
<span class="Comment"> * (a DOM element/tree) to a scope. Where:</span>
<span class="Comment"> *</span>
<span class="Comment"> *  * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.</span>
<span class="Comment"> *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the</span>
<span class="Comment"> *  `template` and call the `cloneAttachFn` function allowing the caller to attach the</span>
<span class="Comment"> *  cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is</span>
<span class="Comment"> *  called as: &lt;br&gt; `cloneAttachFn(clonedElement, scope)` where:</span>
<span class="Comment"> *</span>
<span class="Comment"> *      * `clonedElement` - is a clone of the original `element` passed into the compiler.</span>
<span class="Comment"> *      * `scope` - is the current scope with which the linking function is working with.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Calling the linking function returns the element of the template. It is either the original</span>
<span class="Comment"> * element passed in, or the clone of the element if the `cloneAttachFn` is provided.</span>
<span class="Comment"> *</span>
<span class="Comment"> * After linking the view is not updated until after a call to $digest which typically is done by</span>
<span class="Comment"> * Angular automatically.</span>
<span class="Comment"> *</span>
<span class="Comment"> * If you need access to the bound view, there are two ways to do it:</span>
<span class="Comment"> *</span>
<span class="Comment"> * - If you are not asking the linking function to clone the template, create the DOM element(s)</span>
<span class="Comment"> *   before you send them to the compiler and keep this reference around.</span>
<span class="Comment"> *   &lt;pre&gt;</span>
<span class="Comment"> *     var element = $compile('&lt;p&gt;{{total}}&lt;/p&gt;')(scope);</span>
<span class="Comment"> *   &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * - if on the other hand, you need the element to be cloned, the view reference from the original</span>
<span class="Comment"> *   example would not point to the clone, but rather to the original template that was cloned. In</span>
<span class="Comment"> *   this case, you can access the clone via the cloneAttachFn:</span>
<span class="Comment"> *   &lt;pre&gt;</span>
<span class="Comment"> *     var templateHTML = angular.element('&lt;p&gt;{{total}}&lt;/p&gt;'),</span>
<span class="Comment"> *         scope = ....;</span>
<span class="Comment"> *</span>
<span class="Comment"> *     var clonedElement = $compile(templateHTML)(scope, function(clonedElement, scope) {</span>
<span class="Comment"> *       //attach the clone to DOM document at the right place</span>
<span class="Comment"> *     });</span>
<span class="Comment"> *</span>
<span class="Comment"> *     //now we have reference to the cloned DOM via `clone`</span>
<span class="Comment"> *   &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * For information on how the compiler works, see the</span>
<span class="Comment"> * {@link guide/compiler Angular HTML Compiler} section of the Developer Guide.</span>
<span class="Comment"> */</span>

<span class="Identifier">var</span> $compileMinErr = minErr(<span class="Constant">'$compile'</span>);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc service</span>
<span class="Comment"> * @name ng.$compileProvider</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> */</span>
$CompileProvider.$inject = <span class="Identifier">[</span><span class="Constant">'$provide'</span>, <span class="Constant">'$$sanitizeUriProvider'</span><span class="Identifier">]</span>;
<span class="Identifier">function</span> $CompileProvider($provide, $$sanitizeUriProvider) <span class="Identifier">{</span>
  <span class="Identifier">var</span> hasDirectives = <span class="Identifier">{}</span>,
      Suffix = <span class="Constant">'Directive'</span>,
      COMMENT_DIRECTIVE_REGEXP = <span class="Constant">/^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/</span>,
      CLASS_DIRECTIVE_REGEXP = <span class="Constant">/(([\d\w\-_]+)(?:\:([^;]+))?;?)/</span>;

  <span class="Comment">// Ref: <a href="http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes">http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes</a></span>
  <span class="Comment">// The assumption is that future DOM event attribute names will begin with</span>
  <span class="Comment">// 'on' and be composed of only English letters.</span>
  <span class="Identifier">var</span> EVENT_HANDLER_ATTR_REGEXP = <span class="Constant">/^(on[a-z]+|formaction)$/</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.$compileProvider#directive</span>
<span class="Comment">   * @methodOf ng.$compileProvider</span>
<span class="Comment">   * @function</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Register a new directive with the compiler.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string|Object} name Name of the directive in camel-case (i.e. &lt;code&gt;ngBind&lt;/code&gt; which</span>
<span class="Comment">   *    will match as &lt;code&gt;ng-bind&lt;/code&gt;), or an object map of directives where the keys are the</span>
<span class="Comment">   *    names and the values are the factories.</span>
<span class="Comment">   * @param {function|Array} directiveFactory An injectable directive factory function. See</span>
<span class="Comment">   *    {@link guide/directive} for more info.</span>
<span class="Comment">   * @returns {ng.$compileProvider} Self for chaining.</span>
<span class="Comment">   */</span>
   <span class="Identifier">this</span>.directive = <span class="Identifier">function</span> registerDirective(name, directiveFactory) <span class="Identifier">{</span>
    assertNotHasOwnProperty(name, <span class="Constant">'directive'</span>);
    <span class="Statement">if</span> (isString(name)) <span class="Identifier">{</span>
      assertArg(directiveFactory, <span class="Constant">'directiveFactory'</span>);
      <span class="Statement">if</span> (!hasDirectives.hasOwnProperty(name)) <span class="Identifier">{</span>
        hasDirectives<span class="Identifier">[</span>name<span class="Identifier">]</span> = <span class="Identifier">[]</span>;
        $provide.factory(name + Suffix, <span class="Identifier">[</span><span class="Constant">'$injector'</span>, <span class="Constant">'$exceptionHandler'</span>,
          <span class="Identifier">function</span>($injector, $exceptionHandler) <span class="Identifier">{</span>
            <span class="Identifier">var</span> directives = <span class="Identifier">[]</span>;
            forEach(hasDirectives<span class="Identifier">[</span>name<span class="Identifier">]</span>, <span class="Identifier">function</span>(directiveFactory, index) <span class="Identifier">{</span>
              <span class="Statement">try</span> <span class="Identifier">{</span>
                <span class="Identifier">var</span> directive = $injector.invoke(directiveFactory);
                <span class="Statement">if</span> (isFunction(directive)) <span class="Identifier">{</span>
                  directive = <span class="Identifier">{</span> compile: valueFn(directive) <span class="Identifier">}</span>;
                <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (!directive.compile &amp;&amp; directive.link) <span class="Identifier">{</span>
                  directive.compile = valueFn(directive.link);
                <span class="Identifier">}</span>
                directive.priority = directive.priority || 0;
                directive.index = index;
                directive.name = directive.name || name;
                directive.require = directive.require || (directive.controller &amp;&amp; directive.name);
                directive.restrict = directive.restrict || <span class="Constant">'A'</span>;
                directives.push(directive);
              <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
                $exceptionHandler(e);
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>);
            <span class="Statement">return</span> directives;
          <span class="Identifier">}]</span>);
      <span class="Identifier">}</span>
      hasDirectives<span class="Identifier">[</span>name<span class="Identifier">]</span>.push(directiveFactory);
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      forEach(name, reverseParams(registerDirective));
    <span class="Identifier">}</span>
    <span class="Statement">return</span> <span class="Identifier">this</span>;
  <span class="Identifier">}</span>;


  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.$compileProvider#aHrefSanitizationWhitelist</span>
<span class="Comment">   * @methodOf ng.$compileProvider</span>
<span class="Comment">   * @function</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Retrieves or overrides the default regular expression that is used for whitelisting of safe</span>
<span class="Comment">   * urls during a[href] sanitization.</span>
<span class="Comment">   *</span>
<span class="Comment">   * The sanitization is a security measure aimed at prevent XSS attacks via html links.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into</span>
<span class="Comment">   * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`</span>
<span class="Comment">   * regular expression. If a match is found, the original url is written into the dom. Otherwise,</span>
<span class="Comment">   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {RegExp=} regexp New regexp to whitelist urls with.</span>
<span class="Comment">   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for</span>
<span class="Comment">   *    chaining otherwise.</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.aHrefSanitizationWhitelist = <span class="Identifier">function</span>(regexp) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isDefined(regexp)) <span class="Identifier">{</span>
      $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
      <span class="Statement">return</span> <span class="Identifier">this</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> $$sanitizeUriProvider.aHrefSanitizationWhitelist();
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;


  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.$compileProvider#imgSrcSanitizationWhitelist</span>
<span class="Comment">   * @methodOf ng.$compileProvider</span>
<span class="Comment">   * @function</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Retrieves or overrides the default regular expression that is used for whitelisting of safe</span>
<span class="Comment">   * urls during img[src] sanitization.</span>
<span class="Comment">   *</span>
<span class="Comment">   * The sanitization is a security measure aimed at prevent XSS attacks via html links.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Any url about to be assigned to img[src] via data-binding is first normalized and turned into</span>
<span class="Comment">   * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist`</span>
<span class="Comment">   * regular expression. If a match is found, the original url is written into the dom. Otherwise,</span>
<span class="Comment">   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {RegExp=} regexp New regexp to whitelist urls with.</span>
<span class="Comment">   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for</span>
<span class="Comment">   *    chaining otherwise.</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.imgSrcSanitizationWhitelist = <span class="Identifier">function</span>(regexp) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isDefined(regexp)) <span class="Identifier">{</span>
      $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
      <span class="Statement">return</span> <span class="Identifier">this</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span>
            <span class="Constant">'$injector'</span>, <span class="Constant">'$interpolate'</span>, <span class="Constant">'$exceptionHandler'</span>, <span class="Constant">'$http'</span>, <span class="Constant">'$templateCache'</span>, <span class="Constant">'$parse'</span>,
            <span class="Constant">'$controller'</span>, <span class="Constant">'$rootScope'</span>, <span class="Constant">'$document'</span>, <span class="Constant">'$sce'</span>, <span class="Constant">'$animate'</span>, <span class="Constant">'$$sanitizeUri'</span>,
    <span class="Identifier">function</span>($injector,   $interpolate,   $exceptionHandler,   $http,   $templateCache,   $parse,
             $controller,   $rootScope,   $<span class="Statement">document</span>,   $sce,   $animate,   $$sanitizeUri) <span class="Identifier">{</span>

    <span class="Identifier">var</span> Attributes = <span class="Identifier">function</span>(element, attr) <span class="Identifier">{</span>
      <span class="Identifier">this</span>.$$element = element;
      <span class="Identifier">this</span>.$attr = attr || <span class="Identifier">{}</span>;
    <span class="Identifier">}</span>;

    Attributes.prototype = <span class="Identifier">{</span>
      $normalize: directiveNormalize,


      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$compile.directive.Attributes#$addClass</span>
<span class="Comment">       * @methodOf ng.$compile.directive.Attributes</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Adds the CSS class value specified by the classVal parameter to the element. If animations</span>
<span class="Comment">       * are enabled then an animation will be triggered for the class addition.</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {string} classVal The className value that will be added to the element</span>
<span class="Comment">       */</span>
      $addClass : <span class="Identifier">function</span>(classVal) <span class="Identifier">{</span>
        <span class="Statement">if</span>(classVal &amp;&amp; classVal.length &gt; 0) <span class="Identifier">{</span>
          $animate.addClass(<span class="Identifier">this</span>.$$element, classVal);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>,

      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$compile.directive.Attributes#$removeClass</span>
<span class="Comment">       * @methodOf ng.$compile.directive.Attributes</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Removes the CSS class value specified by the classVal parameter from the element. If</span>
<span class="Comment">       * animations are enabled then an animation will be triggered for the class removal.</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {string} classVal The className value that will be removed from the element</span>
<span class="Comment">       */</span>
      $removeClass : <span class="Identifier">function</span>(classVal) <span class="Identifier">{</span>
        <span class="Statement">if</span>(classVal &amp;&amp; classVal.length &gt; 0) <span class="Identifier">{</span>
          $animate.removeClass(<span class="Identifier">this</span>.$$element, classVal);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>,

      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$compile.directive.Attributes#$updateClass</span>
<span class="Comment">       * @methodOf ng.$compile.directive.Attributes</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Adds and removes the appropriate CSS class values to the element based on the difference</span>
<span class="Comment">       * between the new and old CSS class values (specified as newClasses and oldClasses).</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {string} newClasses The current CSS className value</span>
<span class="Comment">       * @param {string} oldClasses The former CSS className value</span>
<span class="Comment">       */</span>
      $updateClass : <span class="Identifier">function</span>(newClasses, oldClasses) <span class="Identifier">{</span>
        <span class="Identifier">this</span>.$removeClass(tokenDifference(oldClasses, newClasses));
        <span class="Identifier">this</span>.$addClass(tokenDifference(newClasses, oldClasses));
      <span class="Identifier">}</span>,

      <span class="Comment">/**</span>
<span class="Comment">       * Set a normalized attribute on the element in a way such that all directives</span>
<span class="Comment">       * can share the attribute. This function properly handles boolean attributes.</span>
<span class="Comment">       * @param {string} key Normalized key. (ie ngAttribute)</span>
<span class="Comment">       * @param {string|boolean} value The value to set. If `null` attribute will be deleted.</span>
<span class="Comment">       * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.</span>
<span class="Comment">       *     Defaults to true.</span>
<span class="Comment">       * @param {string=} attrName Optional none normalized name. Defaults to key.</span>
<span class="Comment">       */</span>
      $set: <span class="Identifier">function</span>(key, value, writeAttr, attrName) <span class="Identifier">{</span>
        <span class="Comment">// </span><span class="Todo">TODO</span><span class="Comment">: decide whether or not to throw an error if &quot;class&quot;</span>
        <span class="Comment">//is set through this function since it may cause $updateClass to</span>
        <span class="Comment">//become unstable.</span>

        <span class="Identifier">var</span> booleanKey = getBooleanAttrName(<span class="Identifier">this</span>.$$element<span class="Identifier">[</span>0<span class="Identifier">]</span>, key),
            normalizedVal,
            nodeName;

        <span class="Statement">if</span> (booleanKey) <span class="Identifier">{</span>
          <span class="Identifier">this</span>.$$element.prop(key, value);
          attrName = booleanKey;
        <span class="Identifier">}</span>

        <span class="Identifier">this</span><span class="Identifier">[</span>key<span class="Identifier">]</span> = value;

        <span class="Comment">// translate normalized key to actual key</span>
        <span class="Statement">if</span> (attrName) <span class="Identifier">{</span>
          <span class="Identifier">this</span>.$attr<span class="Identifier">[</span>key<span class="Identifier">]</span> = attrName;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          attrName = <span class="Identifier">this</span>.$attr<span class="Identifier">[</span>key<span class="Identifier">]</span>;
          <span class="Statement">if</span> (!attrName) <span class="Identifier">{</span>
            <span class="Identifier">this</span>.$attr<span class="Identifier">[</span>key<span class="Identifier">]</span> = attrName = snake_case(key, <span class="Constant">'-'</span>);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>

        nodeName = nodeName_(<span class="Identifier">this</span>.$$element);

        <span class="Comment">// sanitize a[href] and img[src] values</span>
        <span class="Statement">if</span> ((nodeName === <span class="Constant">'A'</span> &amp;&amp; key === <span class="Constant">'href'</span>) ||
            (nodeName === <span class="Constant">'IMG'</span> &amp;&amp; key === <span class="Constant">'src'</span>)) <span class="Identifier">{</span>
          <span class="Identifier">this</span><span class="Identifier">[</span>key<span class="Identifier">]</span> = value = $$sanitizeUri(value, key === <span class="Constant">'src'</span>);
        <span class="Identifier">}</span>

        <span class="Statement">if</span> (writeAttr !== <span class="Constant">false</span>) <span class="Identifier">{</span>
          <span class="Statement">if</span> (value === <span class="Statement">null</span> || value === <span class="Statement">undefined</span>) <span class="Identifier">{</span>
            <span class="Identifier">this</span>.$$element.removeAttr(attrName);
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            <span class="Identifier">this</span>.$$element.attr(attrName, value);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>

        <span class="Comment">// fire observers</span>
        <span class="Identifier">var</span> $$observers = <span class="Identifier">this</span>.$$observers;
        $$observers &amp;&amp; forEach($$observers<span class="Identifier">[</span>key<span class="Identifier">]</span>, <span class="Identifier">function</span>(fn) <span class="Identifier">{</span>
          <span class="Statement">try</span> <span class="Identifier">{</span>
            fn(value);
          <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
            $exceptionHandler(e);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>);
      <span class="Identifier">}</span>,


      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$compile.directive.Attributes#$observe</span>
<span class="Comment">       * @methodOf ng.$compile.directive.Attributes</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Observes an interpolated attribute.</span>
<span class="Comment">       *</span>
<span class="Comment">       * The observer function will be invoked once during the next `$digest` following</span>
<span class="Comment">       * compilation. The observer is then invoked whenever the interpolated value</span>
<span class="Comment">       * changes.</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {string} key Normalized key. (ie ngAttribute) .</span>
<span class="Comment">       * @param {function(interpolatedValue)} fn Function that will be called whenever</span>
<span class="Comment">                the interpolated value of the attribute changes.</span>
<span class="Comment">       *        See the {@link guide/directive#Attributes Directives} guide for more info.</span>
<span class="Comment">       * @returns {function()} the `fn` parameter.</span>
<span class="Comment">       */</span>
      $observe: <span class="Identifier">function</span>(key, fn) <span class="Identifier">{</span>
        <span class="Identifier">var</span> attrs = <span class="Identifier">this</span>,
            $$observers = (attrs.$$observers || (attrs.$$observers = <span class="Identifier">{}</span>)),
            listeners = ($$observers<span class="Identifier">[</span>key<span class="Identifier">]</span> || ($$observers<span class="Identifier">[</span>key<span class="Identifier">]</span> = <span class="Identifier">[]</span>));

        listeners.push(fn);
        $rootScope.$evalAsync(<span class="Identifier">function</span>() <span class="Identifier">{</span>
          <span class="Statement">if</span> (!listeners.$$inter) <span class="Identifier">{</span>
            <span class="Comment">// no one registered attribute interpolation function, so lets call it manually</span>
            fn(attrs<span class="Identifier">[</span>key<span class="Identifier">]</span>);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>);
        <span class="Statement">return</span> fn;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;

    <span class="Identifier">var</span> startSymbol = $interpolate.startSymbol(),
        endSymbol = $interpolate.endSymbol(),
        denormalizeTemplate = (startSymbol == <span class="Constant">'{{'</span> || endSymbol  == <span class="Constant">'}}'</span>)
            ? identity
            : <span class="Identifier">function</span> denormalizeTemplate(template) <span class="Identifier">{</span>
              <span class="Statement">return</span> template.replace(<span class="Constant">/\{\{/g</span>, startSymbol).replace(<span class="Constant">/}}/g</span>, endSymbol);
        <span class="Identifier">}</span>,
        NG_ATTR_BINDING = <span class="Constant">/^ngAttr[A-Z]/</span>;


    <span class="Statement">return</span> compile;

    <span class="Comment">//================================</span>

    <span class="Identifier">function</span> compile($compileNodes, transcludeFn, maxPriority, ignoreDirective,
                        previousCompileContext) <span class="Identifier">{</span>
      <span class="Statement">if</span> (!($compileNodes <span class="Statement">instanceof</span> jqLite)) <span class="Identifier">{</span>
        <span class="Comment">// jquery always rewraps, whereas we need to preserve the original selector so that we can</span>
        <span class="Comment">// modify it.</span>
        $compileNodes = jqLite($compileNodes);
      <span class="Identifier">}</span>
      <span class="Comment">// We can not compile top level text elements since text nodes can be merged and we will</span>
      <span class="Comment">// not be able to attach scope data to them, so we will wrap them in &lt;span&gt;</span>
      forEach($compileNodes, <span class="Identifier">function</span>(node, index)<span class="Identifier">{</span>
        <span class="Statement">if</span> (node.nodeType == 3 <span class="Comment">/* text node */</span> &amp;&amp; node.nodeValue.match(<span class="Constant">/\S+/</span>) <span class="Comment">/* non-empty */</span> ) <span class="Identifier">{</span>
          $compileNodes<span class="Identifier">[</span>index<span class="Identifier">]</span> = node = jqLite(node).wrap(<span class="Constant">'&lt;span&gt;&lt;/span&gt;'</span>).<span class="Statement">parent</span>()<span class="Identifier">[</span>0<span class="Identifier">]</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>);
      <span class="Identifier">var</span> compositeLinkFn =
              compileNodes($compileNodes, transcludeFn, $compileNodes,
                           maxPriority, ignoreDirective, previousCompileContext);
      <span class="Statement">return</span> <span class="Identifier">function</span> publicLinkFn(scope, cloneConnectFn, transcludeControllers)<span class="Identifier">{</span>
        assertArg(scope, <span class="Constant">'scope'</span>);
        <span class="Comment">// important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart</span>
        <span class="Comment">// and sometimes changes the structure of the DOM.</span>
        <span class="Identifier">var</span> $linkNode = cloneConnectFn
          ? JQLitePrototype.clone.call($compileNodes) <span class="Comment">// IMPORTANT!!!</span>
          : $compileNodes;

        forEach(transcludeControllers, <span class="Identifier">function</span>(instance, name) <span class="Identifier">{</span>
          $linkNode.data(<span class="Constant">'$'</span> + name + <span class="Constant">'Controller'</span>, instance);
        <span class="Identifier">}</span>);

        <span class="Comment">// Attach scope only to non-text nodes.</span>
        <span class="Statement">for</span>(<span class="Identifier">var</span> i = 0, ii = $linkNode.length; i&lt;ii; i++) <span class="Identifier">{</span>
          <span class="Identifier">var</span> node = $linkNode<span class="Identifier">[</span>i<span class="Identifier">]</span>;
          <span class="Statement">if</span> (node.nodeType == 1 <span class="Comment">/* element */</span> || node.nodeType == 9 <span class="Comment">/* document */</span>) <span class="Identifier">{</span>
            $linkNode.eq(i).data(<span class="Constant">'$scope'</span>, scope);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
        safeAddClass($linkNode, <span class="Constant">'ng-scope'</span>);
        <span class="Statement">if</span> (cloneConnectFn) cloneConnectFn($linkNode, scope);
        <span class="Statement">if</span> (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode);
        <span class="Statement">return</span> $linkNode;
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>

    <span class="Identifier">function</span> safeAddClass($element, className) <span class="Identifier">{</span>
      <span class="Statement">try</span> <span class="Identifier">{</span>
        $element.addClass(className);
      <span class="Identifier">}</span> <span class="Statement">catch</span>(e) <span class="Identifier">{</span>
        <span class="Comment">// ignore, since it means that we are trying to set class on</span>
        <span class="Comment">// SVG element, where class name is read-only.</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Comment">/**</span>
<span class="Comment">     * Compile function matches each node in nodeList against the directives. Once all directives</span>
<span class="Comment">     * for a particular node are collected their compile functions are executed. The compile</span>
<span class="Comment">     * functions return values - the linking functions - are combined into a composite linking</span>
<span class="Comment">     * function, which is the a linking function for the node.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {NodeList} nodeList an array of nodes or NodeList to compile</span>
<span class="Comment">     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the</span>
<span class="Comment">     *        scope argument is auto-generated to the new child of the transcluded parent scope.</span>
<span class="Comment">     * @param {DOMElement=} $rootElement If the nodeList is the root of the compilation tree then</span>
<span class="Comment">     *        the rootElement must be set the jqLite collection of the compile root. This is</span>
<span class="Comment">     *        needed so that the jqLite collection items can be replaced with widgets.</span>
<span class="Comment">     * @param {number=} max directive priority</span>
<span class="Comment">     * @returns {?function} A composite linking function of all of the matched directives or null.</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective,
                            previousCompileContext) <span class="Identifier">{</span>
      <span class="Identifier">var</span> linkFns = <span class="Identifier">[]</span>,
          nodeLinkFn, childLinkFn, directives, attrs, linkFnFound;

      <span class="Statement">for</span>(<span class="Identifier">var</span> i = 0; i &lt; nodeList.length; i++) <span class="Identifier">{</span>
        attrs = <span class="Statement">new</span> Attributes();

        <span class="Comment">// we must always refer to nodeList[i] since the nodes can be replaced underneath us.</span>
        directives = collectDirectives(nodeList<span class="Identifier">[</span>i<span class="Identifier">]</span>, <span class="Identifier">[]</span>, attrs, i === 0 ? maxPriority : <span class="Statement">undefined</span>,
                                        ignoreDirective);

        nodeLinkFn = (directives.length)
            ? applyDirectivesToNode(directives, nodeList<span class="Identifier">[</span>i<span class="Identifier">]</span>, attrs, transcludeFn, $rootElement,
                                      <span class="Statement">null</span>, <span class="Identifier">[]</span>, <span class="Identifier">[]</span>, previousCompileContext)
            : <span class="Statement">null</span>;

        childLinkFn = (nodeLinkFn &amp;&amp; nodeLinkFn.terminal ||
                      !nodeList<span class="Identifier">[</span>i<span class="Identifier">]</span>.childNodes ||
                      !nodeList<span class="Identifier">[</span>i<span class="Identifier">]</span>.childNodes.length)
            ? <span class="Statement">null</span>
            : compileNodes(nodeList<span class="Identifier">[</span>i<span class="Identifier">]</span>.childNodes,
                 nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);

        linkFns.push(nodeLinkFn);
        linkFns.push(childLinkFn);
        linkFnFound = (linkFnFound || nodeLinkFn || childLinkFn);
        <span class="Comment">//use the previous context only for the first element in the virtual group</span>
        previousCompileContext = <span class="Statement">null</span>;
      <span class="Identifier">}</span>

      <span class="Comment">// return a linking function if we have found anything, null otherwise</span>
      <span class="Statement">return</span> linkFnFound ? compositeLinkFn : <span class="Statement">null</span>;

      <span class="Identifier">function</span> compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) <span class="Identifier">{</span>
        <span class="Identifier">var</span> nodeLinkFn, childLinkFn, node, $node, childScope, childTranscludeFn, i, ii, n;

        <span class="Comment">// copy nodeList so that linking doesn't break due to live list updates.</span>
        <span class="Identifier">var</span> stableNodeList = <span class="Identifier">[]</span>;
        <span class="Statement">for</span> (i = 0, ii = nodeList.length; i &lt; ii; i++) <span class="Identifier">{</span>
          stableNodeList.push(nodeList<span class="Identifier">[</span>i<span class="Identifier">]</span>);
        <span class="Identifier">}</span>

        <span class="Statement">for</span>(i = 0, n = 0, ii = linkFns.length; i &lt; ii; n++) <span class="Identifier">{</span>
          node = stableNodeList<span class="Identifier">[</span>n<span class="Identifier">]</span>;
          nodeLinkFn = linkFns<span class="Identifier">[</span>i++<span class="Identifier">]</span>;
          childLinkFn = linkFns<span class="Identifier">[</span>i++<span class="Identifier">]</span>;
          $node = jqLite(node);

          <span class="Statement">if</span> (nodeLinkFn) <span class="Identifier">{</span>
            <span class="Statement">if</span> (nodeLinkFn.scope) <span class="Identifier">{</span>
              childScope = scope.$<span class="Statement">new</span>();
              $node.data(<span class="Constant">'$scope'</span>, childScope);
              safeAddClass($node, <span class="Constant">'ng-scope'</span>);
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
              childScope = scope;
            <span class="Identifier">}</span>
            childTranscludeFn = nodeLinkFn.transclude;
            <span class="Statement">if</span> (childTranscludeFn || (!boundTranscludeFn &amp;&amp; transcludeFn)) <span class="Identifier">{</span>
              nodeLinkFn(childLinkFn, childScope, node, $rootElement,
                createBoundTranscludeFn(scope, childTranscludeFn || transcludeFn)
              );
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
              nodeLinkFn(childLinkFn, childScope, node, $rootElement, boundTranscludeFn);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (childLinkFn) <span class="Identifier">{</span>
            childLinkFn(scope, node.childNodes, <span class="Statement">undefined</span>, boundTranscludeFn);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Identifier">function</span> createBoundTranscludeFn(scope, transcludeFn) <span class="Identifier">{</span>
      <span class="Statement">return</span> <span class="Identifier">function</span> boundTranscludeFn(transcludedScope, cloneFn, controllers) <span class="Identifier">{</span>
        <span class="Identifier">var</span> scopeCreated = <span class="Constant">false</span>;

        <span class="Statement">if</span> (!transcludedScope) <span class="Identifier">{</span>
          transcludedScope = scope.$<span class="Statement">new</span>();
          transcludedScope.$$transcluded = <span class="Constant">true</span>;
          scopeCreated = <span class="Constant">true</span>;
        <span class="Identifier">}</span>

        <span class="Identifier">var</span> clone = transcludeFn(transcludedScope, cloneFn, controllers);
        <span class="Statement">if</span> (scopeCreated) <span class="Identifier">{</span>
          clone.on(<span class="Constant">'$destroy'</span>, bind(transcludedScope, transcludedScope.$destroy));
        <span class="Identifier">}</span>
        <span class="Statement">return</span> clone;
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>

    <span class="Comment">/**</span>
<span class="Comment">     * Looks for directives on the given node and adds them to the directive collection which is</span>
<span class="Comment">     * sorted.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param node Node to search.</span>
<span class="Comment">     * @param directives An array to which the directives are added to. This array is sorted before</span>
<span class="Comment">     *        the function returns.</span>
<span class="Comment">     * @param attrs The shared attrs object which is used to populate the normalized attributes.</span>
<span class="Comment">     * @param {number=} maxPriority Max directive priority.</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) <span class="Identifier">{</span>
      <span class="Identifier">var</span> nodeType = node.nodeType,
          attrsMap = attrs.$attr,
          match,
          className;

      <span class="Statement">switch</span>(nodeType) <span class="Identifier">{</span>
        <span class="Statement">case</span> 1: <span class="Comment">/* Element */</span>
          <span class="Comment">// use the node name: &lt;directive&gt;</span>
          addDirective(directives,
              directiveNormalize(nodeName_(node).toLowerCase()), <span class="Constant">'E'</span>, maxPriority, ignoreDirective);

          <span class="Comment">// iterate over the attributes</span>
          <span class="Statement">for</span> (<span class="Identifier">var</span> attr, name, nName, ngAttrName, value, nAttrs = node.attributes,
                   j = 0, jj = nAttrs &amp;&amp; nAttrs.length; j &lt; jj; j++) <span class="Identifier">{</span>
            <span class="Identifier">var</span> attrStartName = <span class="Constant">false</span>;
            <span class="Identifier">var</span> attrEndName = <span class="Constant">false</span>;

            attr = nAttrs<span class="Identifier">[</span>j<span class="Identifier">]</span>;
            <span class="Statement">if</span> (!msie || msie &gt;= 8 || attr.specified) <span class="Identifier">{</span>
              name = attr.name;
              <span class="Comment">// support ngAttr attribute binding</span>
              ngAttrName = directiveNormalize(name);
              <span class="Statement">if</span> (NG_ATTR_BINDING.test(ngAttrName)) <span class="Identifier">{</span>
                name = snake_case(ngAttrName.substr(6), <span class="Constant">'-'</span>);
              <span class="Identifier">}</span>

              <span class="Identifier">var</span> directiveNName = ngAttrName.replace(<span class="Constant">/(Start|End)$/</span>, <span class="Constant">''</span>);
              <span class="Statement">if</span> (ngAttrName === directiveNName + <span class="Constant">'Start'</span>) <span class="Identifier">{</span>
                attrStartName = name;
                attrEndName = name.substr(0, name.length - 5) + <span class="Constant">'end'</span>;
                name = name.substr(0, name.length - 6);
              <span class="Identifier">}</span>

              nName = directiveNormalize(name.toLowerCase());
              attrsMap<span class="Identifier">[</span>nName<span class="Identifier">]</span> = name;
              attrs<span class="Identifier">[</span>nName<span class="Identifier">]</span> = value = trim((msie &amp;&amp; name == <span class="Constant">'href'</span>)
                ? decodeURIComponent(node.getAttribute(name, 2))
                : attr.value);
              <span class="Statement">if</span> (getBooleanAttrName(node, nName)) <span class="Identifier">{</span>
                attrs<span class="Identifier">[</span>nName<span class="Identifier">]</span> = <span class="Constant">true</span>; <span class="Comment">// presence means true</span>
              <span class="Identifier">}</span>
              addAttrInterpolateDirective(node, directives, value, nName);
              addDirective(directives, nName, <span class="Constant">'A'</span>, maxPriority, ignoreDirective, attrStartName,
                            attrEndName);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>

          <span class="Comment">// use class as directive</span>
          className = node.className;
          <span class="Statement">if</span> (isString(className) &amp;&amp; className !== <span class="Constant">''</span>) <span class="Identifier">{</span>
            <span class="Statement">while</span> (match = CLASS_DIRECTIVE_REGEXP.exec(className)) <span class="Identifier">{</span>
              nName = directiveNormalize(match<span class="Identifier">[</span>2<span class="Identifier">]</span>);
              <span class="Statement">if</span> (addDirective(directives, nName, <span class="Constant">'C'</span>, maxPriority, ignoreDirective)) <span class="Identifier">{</span>
                attrs<span class="Identifier">[</span>nName<span class="Identifier">]</span> = trim(match<span class="Identifier">[</span>3<span class="Identifier">]</span>);
              <span class="Identifier">}</span>
              className = className.substr(match.index + match<span class="Identifier">[</span>0<span class="Identifier">]</span>.length);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
          <span class="Statement">break</span>;
        <span class="Statement">case</span> 3: <span class="Comment">/* Text Node */</span>
          addTextInterpolateDirective(directives, node.nodeValue);
          <span class="Statement">break</span>;
        <span class="Statement">case</span> 8: <span class="Comment">/* Comment */</span>
          <span class="Statement">try</span> <span class="Identifier">{</span>
            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
            <span class="Statement">if</span> (match) <span class="Identifier">{</span>
              nName = directiveNormalize(match<span class="Identifier">[</span>1<span class="Identifier">]</span>);
              <span class="Statement">if</span> (addDirective(directives, nName, <span class="Constant">'M'</span>, maxPriority, ignoreDirective)) <span class="Identifier">{</span>
                attrs<span class="Identifier">[</span>nName<span class="Identifier">]</span> = trim(match<span class="Identifier">[</span>2<span class="Identifier">]</span>);
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>
          <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
            <span class="Comment">// turns out that under some circumstances IE9 throws errors when one attempts to read</span>
            <span class="Comment">// comment's node value.</span>
            <span class="Comment">// Just ignore it and continue. (Can't seem to reproduce in test case.)</span>
          <span class="Identifier">}</span>
          <span class="Statement">break</span>;
      <span class="Identifier">}</span>

      directives.sort(byPriority);
      <span class="Statement">return</span> directives;
    <span class="Identifier">}</span>

    <span class="Comment">/**</span>
<span class="Comment">     * Given a node with an directive-start it collects all of the siblings until it finds</span>
<span class="Comment">     * directive-end.</span>
<span class="Comment">     * @param node</span>
<span class="Comment">     * @param attrStart</span>
<span class="Comment">     * @param attrEnd</span>
<span class="Comment">     * @returns {*}</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> groupScan(node, attrStart, attrEnd) <span class="Identifier">{</span>
      <span class="Identifier">var</span> nodes = <span class="Identifier">[]</span>;
      <span class="Identifier">var</span> depth = 0;
      <span class="Statement">if</span> (attrStart &amp;&amp; node.hasAttribute &amp;&amp; node.hasAttribute(attrStart)) <span class="Identifier">{</span>
        <span class="Identifier">var</span> startNode = node;
        <span class="Statement">do</span> <span class="Identifier">{</span>
          <span class="Statement">if</span> (!node) <span class="Identifier">{</span>
            <span class="Statement">throw</span> $compileMinErr(<span class="Constant">'uterdir'</span>,
                      <span class="Constant">&quot;Unterminated attribute, found '{0}' but no matching '{1}' found.&quot;</span>,
                      attrStart, attrEnd);
          <span class="Identifier">}</span>
          <span class="Statement">if</span> (node.nodeType == 1 <span class="Comment">/** Element **/</span>) <span class="Identifier">{</span>
            <span class="Statement">if</span> (node.hasAttribute(attrStart)) depth++;
            <span class="Statement">if</span> (node.hasAttribute(attrEnd)) depth--;
          <span class="Identifier">}</span>
          nodes.push(node);
          node = node.nextSibling;
        <span class="Identifier">}</span> <span class="Statement">while</span> (depth &gt; 0);
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        nodes.push(node);
      <span class="Identifier">}</span>

      <span class="Statement">return</span> jqLite(nodes);
    <span class="Identifier">}</span>

    <span class="Comment">/**</span>
<span class="Comment">     * Wrapper for linking function which converts normal linking function into a grouped</span>
<span class="Comment">     * linking function.</span>
<span class="Comment">     * @param linkFn</span>
<span class="Comment">     * @param attrStart</span>
<span class="Comment">     * @param attrEnd</span>
<span class="Comment">     * @returns {Function}</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) <span class="Identifier">{</span>
      <span class="Statement">return</span> <span class="Identifier">function</span>(scope, element, attrs, controllers, transcludeFn) <span class="Identifier">{</span>
        element = groupScan(element<span class="Identifier">[</span>0<span class="Identifier">]</span>, attrStart, attrEnd);
        <span class="Statement">return</span> linkFn(scope, element, attrs, controllers, transcludeFn);
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>

    <span class="Comment">/**</span>
<span class="Comment">     * Once the directives have been collected, their compile functions are executed. This method</span>
<span class="Comment">     * is responsible for inlining directive templates as well as terminating the application</span>
<span class="Comment">     * of the directives if the terminal directive has been reached.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {Array} directives Array of collected directives to execute their compile function.</span>
<span class="Comment">     *        this needs to be pre-sorted by priority order.</span>
<span class="Comment">     * @param {Node} compileNode The raw DOM node to apply the compile functions to</span>
<span class="Comment">     * @param {Object} templateAttrs The shared attribute function</span>
<span class="Comment">     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the</span>
<span class="Comment">     *                                                  scope argument is auto-generated to the new</span>
<span class="Comment">     *                                                  child of the transcluded parent scope.</span>
<span class="Comment">     * @param {JQLite} jqCollection If we are working on the root of the compile tree then this</span>
<span class="Comment">     *                              argument has the root jqLite array so that we can replace nodes</span>
<span class="Comment">     *                              on it.</span>
<span class="Comment">     * @param {Object=} originalReplaceDirective An optional directive that will be ignored when</span>
<span class="Comment">     *                                           compiling the transclusion.</span>
<span class="Comment">     * @param {Array.&lt;Function&gt;} preLinkFns</span>
<span class="Comment">     * @param {Array.&lt;Function&gt;} postLinkFns</span>
<span class="Comment">     * @param {Object} previousCompileContext Context used for previous compilation of the current</span>
<span class="Comment">     *                                        node</span>
<span class="Comment">     * @returns linkFn</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn,
                                   jqCollection, originalReplaceDirective, preLinkFns, postLinkFns,
                                   previousCompileContext) <span class="Identifier">{</span>
      previousCompileContext = previousCompileContext || <span class="Identifier">{}</span>;

      <span class="Identifier">var</span> terminalPriority = -<span class="Type">Number</span>.MAX_VALUE,
          newScopeDirective,
          controllerDirectives = previousCompileContext.controllerDirectives,
          newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
          templateDirective = previousCompileContext.templateDirective,
          nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
          hasTranscludeDirective = <span class="Constant">false</span>,
          hasElementTranscludeDirective = <span class="Constant">false</span>,
          $compileNode = templateAttrs.$$element = jqLite(compileNode),
          directive,
          directiveName,
          $template,
          replaceDirective = originalReplaceDirective,
          childTranscludeFn = transcludeFn,
          linkFn,
          directiveValue;

      <span class="Comment">// executes all directives on the current element</span>
      <span class="Statement">for</span>(<span class="Identifier">var</span> i = 0, ii = directives.length; i &lt; ii; i++) <span class="Identifier">{</span>
        directive = directives<span class="Identifier">[</span>i<span class="Identifier">]</span>;
        <span class="Identifier">var</span> attrStart = directive.$$start;
        <span class="Identifier">var</span> attrEnd = directive.$$end;

        <span class="Comment">// collect multiblock sections</span>
        <span class="Statement">if</span> (attrStart) <span class="Identifier">{</span>
          $compileNode = groupScan(compileNode, attrStart, attrEnd);
        <span class="Identifier">}</span>
        $template = <span class="Statement">undefined</span>;

        <span class="Statement">if</span> (terminalPriority &gt; directive.priority) <span class="Identifier">{</span>
          <span class="Statement">break</span>; <span class="Comment">// prevent further processing of directives</span>
        <span class="Identifier">}</span>

        <span class="Statement">if</span> (directiveValue = directive.scope) <span class="Identifier">{</span>
          newScopeDirective = newScopeDirective || directive;

          <span class="Comment">// skip the check for directives with async templates, we'll check the derived sync</span>
          <span class="Comment">// directive when the template arrives</span>
          <span class="Statement">if</span> (!directive.templateUrl) <span class="Identifier">{</span>
            assertNoDuplicate(<span class="Constant">'new/isolated scope'</span>, newIsolateScopeDirective, directive,
                              $compileNode);
            <span class="Statement">if</span> (isObject(directiveValue)) <span class="Identifier">{</span>
              newIsolateScopeDirective = directive;
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>

        directiveName = directive.name;

        <span class="Statement">if</span> (!directive.templateUrl &amp;&amp; directive.controller) <span class="Identifier">{</span>
          directiveValue = directive.controller;
          controllerDirectives = controllerDirectives || <span class="Identifier">{}</span>;
          assertNoDuplicate(<span class="Constant">&quot;'&quot;</span> + directiveName + <span class="Constant">&quot;' controller&quot;</span>,
              controllerDirectives<span class="Identifier">[</span>directiveName<span class="Identifier">]</span>, directive, $compileNode);
          controllerDirectives<span class="Identifier">[</span>directiveName<span class="Identifier">]</span> = directive;
        <span class="Identifier">}</span>

        <span class="Statement">if</span> (directiveValue = directive.transclude) <span class="Identifier">{</span>
          hasTranscludeDirective = <span class="Constant">true</span>;

          <span class="Comment">// Special case ngIf and ngRepeat so that we don't complain about duplicate transclusion.</span>
          <span class="Comment">// This option should only be used by directives that know how to how to safely handle element transclusion,</span>
          <span class="Comment">// where the transcluded nodes are added or replaced after linking.</span>
          <span class="Statement">if</span> (!directive.$$tlb) <span class="Identifier">{</span>
            assertNoDuplicate(<span class="Constant">'transclusion'</span>, nonTlbTranscludeDirective, directive, $compileNode);
            nonTlbTranscludeDirective = directive;
          <span class="Identifier">}</span>

          <span class="Statement">if</span> (directiveValue == <span class="Constant">'element'</span>) <span class="Identifier">{</span>
            hasElementTranscludeDirective = <span class="Constant">true</span>;
            terminalPriority = directive.priority;
            $template = groupScan(compileNode, attrStart, attrEnd);
            $compileNode = templateAttrs.$$element =
                jqLite(<span class="Statement">document</span>.createComment(<span class="Constant">' '</span> + directiveName + <span class="Constant">': '</span> +
                                              templateAttrs<span class="Identifier">[</span>directiveName<span class="Identifier">]</span> + <span class="Constant">' '</span>));
            compileNode = $compileNode<span class="Identifier">[</span>0<span class="Identifier">]</span>;
            replaceWith(jqCollection, jqLite(sliceArgs($template)), compileNode);

            childTranscludeFn = compile($template, transcludeFn, terminalPriority,
                                        replaceDirective &amp;&amp; replaceDirective.name, <span class="Identifier">{</span>
                                          <span class="Comment">// Don't pass in:</span>
                                          <span class="Comment">// - controllerDirectives - otherwise we'll create duplicates controllers</span>
                                          <span class="Comment">// - newIsolateScopeDirective or templateDirective - combining templates with</span>
                                          <span class="Comment">//   element transclusion doesn't make sense.</span>
                                          <span class="Comment">//</span>
                                          <span class="Comment">// We need only nonTlbTranscludeDirective so that we prevent putting transclusion</span>
                                          <span class="Comment">// on the same element more than once.</span>
                                          nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                        <span class="Identifier">}</span>);
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            $template = jqLite(jqLiteClone(compileNode)).contents();
            $compileNode.html(<span class="Constant">''</span>); <span class="Comment">// clear contents</span>
            childTranscludeFn = compile($template, transcludeFn);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>

        <span class="Statement">if</span> (directive.template) <span class="Identifier">{</span>
          assertNoDuplicate(<span class="Constant">'template'</span>, templateDirective, directive, $compileNode);
          templateDirective = directive;

          directiveValue = (isFunction(directive.template))
              ? directive.template($compileNode, templateAttrs)
              : directive.template;

          directiveValue = denormalizeTemplate(directiveValue);

          <span class="Statement">if</span> (directive.replace) <span class="Identifier">{</span>
            replaceDirective = directive;
            $template = jqLite(<span class="Constant">'&lt;div&gt;'</span> +
                                 trim(directiveValue) +
                               <span class="Constant">'&lt;/div&gt;'</span>).contents();
            compileNode = $template<span class="Identifier">[</span>0<span class="Identifier">]</span>;

            <span class="Statement">if</span> ($template.length != 1 || compileNode.nodeType !== 1) <span class="Identifier">{</span>
              <span class="Statement">throw</span> $compileMinErr(<span class="Constant">'tplrt'</span>,
                  <span class="Constant">&quot;Template for directive '{0}' must have exactly one root element. {1}&quot;</span>,
                  directiveName, <span class="Constant">''</span>);
            <span class="Identifier">}</span>

            replaceWith(jqCollection, $compileNode, compileNode);

            <span class="Identifier">var</span> newTemplateAttrs = <span class="Identifier">{</span>$attr: <span class="Identifier">{}}</span>;

            <span class="Comment">// combine directives from the original node and from the template:</span>
            <span class="Comment">// - take the array of directives for this element</span>
            <span class="Comment">// - split it into two parts, those that already applied (processed) and those that weren't (unprocessed)</span>
            <span class="Comment">// - collect directives from the template and sort them by priority</span>
            <span class="Comment">// - combine directives as: processed + template + unprocessed</span>
            <span class="Identifier">var</span> templateDirectives = collectDirectives(compileNode, <span class="Identifier">[]</span>, newTemplateAttrs);
            <span class="Identifier">var</span> unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));

            <span class="Statement">if</span> (newIsolateScopeDirective) <span class="Identifier">{</span>
              markDirectivesAsIsolate(templateDirectives);
            <span class="Identifier">}</span>
            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);

            ii = directives.length;
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            $compileNode.html(directiveValue);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>

        <span class="Statement">if</span> (directive.templateUrl) <span class="Identifier">{</span>
          assertNoDuplicate(<span class="Constant">'template'</span>, templateDirective, directive, $compileNode);
          templateDirective = directive;

          <span class="Statement">if</span> (directive.replace) <span class="Identifier">{</span>
            replaceDirective = directive;
          <span class="Identifier">}</span>

          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode,
              templateAttrs, jqCollection, childTranscludeFn, preLinkFns, postLinkFns, <span class="Identifier">{</span>
                controllerDirectives: controllerDirectives,
                newIsolateScopeDirective: newIsolateScopeDirective,
                templateDirective: templateDirective,
                nonTlbTranscludeDirective: nonTlbTranscludeDirective
              <span class="Identifier">}</span>);
          ii = directives.length;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (directive.compile) <span class="Identifier">{</span>
          <span class="Statement">try</span> <span class="Identifier">{</span>
            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
            <span class="Statement">if</span> (isFunction(linkFn)) <span class="Identifier">{</span>
              addLinkFns(<span class="Statement">null</span>, linkFn, attrStart, attrEnd);
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (linkFn) <span class="Identifier">{</span>
              addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
            $exceptionHandler(e, startingTag($compileNode));
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>

        <span class="Statement">if</span> (directive.terminal) <span class="Identifier">{</span>
          nodeLinkFn.terminal = <span class="Constant">true</span>;
          terminalPriority = Math.max(terminalPriority, directive.priority);
        <span class="Identifier">}</span>

      <span class="Identifier">}</span>

      nodeLinkFn.scope = newScopeDirective &amp;&amp; newScopeDirective.scope === <span class="Constant">true</span>;
      nodeLinkFn.transclude = hasTranscludeDirective &amp;&amp; childTranscludeFn;

      <span class="Comment">// might be normal or delayed nodeLinkFn depending on if templateUrl is present</span>
      <span class="Statement">return</span> nodeLinkFn;

      <span class="Comment">////////////////////</span>

      <span class="Identifier">function</span> addLinkFns(pre, post, attrStart, attrEnd) <span class="Identifier">{</span>
        <span class="Statement">if</span> (pre) <span class="Identifier">{</span>
          <span class="Statement">if</span> (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
          pre.require = directive.require;
          <span class="Statement">if</span> (newIsolateScopeDirective === directive || directive.$$isolateScope) <span class="Identifier">{</span>
            pre = cloneAndAnnotateFn(pre, <span class="Identifier">{</span>isolateScope: <span class="Constant">true</span><span class="Identifier">}</span>);
          <span class="Identifier">}</span>
          preLinkFns.push(pre);
        <span class="Identifier">}</span>
        <span class="Statement">if</span> (post) <span class="Identifier">{</span>
          <span class="Statement">if</span> (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
          post.require = directive.require;
          <span class="Statement">if</span> (newIsolateScopeDirective === directive || directive.$$isolateScope) <span class="Identifier">{</span>
            post = cloneAndAnnotateFn(post, <span class="Identifier">{</span>isolateScope: <span class="Constant">true</span><span class="Identifier">}</span>);
          <span class="Identifier">}</span>
          postLinkFns.push(post);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>


      <span class="Identifier">function</span> getControllers(require, $element, elementControllers) <span class="Identifier">{</span>
        <span class="Identifier">var</span> value, retrievalMethod = <span class="Constant">'data'</span>, optional = <span class="Constant">false</span>;
        <span class="Statement">if</span> (isString(require)) <span class="Identifier">{</span>
          <span class="Statement">while</span>((value = require.charAt(0)) == <span class="Constant">'^'</span> || value == <span class="Constant">'?'</span>) <span class="Identifier">{</span>
            require = require.substr(1);
            <span class="Statement">if</span> (value == <span class="Constant">'^'</span>) <span class="Identifier">{</span>
              retrievalMethod = <span class="Constant">'inheritedData'</span>;
            <span class="Identifier">}</span>
            optional = optional || value == <span class="Constant">'?'</span>;
          <span class="Identifier">}</span>
          value = <span class="Statement">null</span>;

          <span class="Statement">if</span> (elementControllers &amp;&amp; retrievalMethod === <span class="Constant">'data'</span>) <span class="Identifier">{</span>
            value = elementControllers<span class="Identifier">[</span>require<span class="Identifier">]</span>;
          <span class="Identifier">}</span>
          value = value || $element<span class="Identifier">[</span>retrievalMethod<span class="Identifier">]</span>(<span class="Constant">'$'</span> + require + <span class="Constant">'Controller'</span>);

          <span class="Statement">if</span> (!value &amp;&amp; !optional) <span class="Identifier">{</span>
            <span class="Statement">throw</span> $compileMinErr(<span class="Constant">'ctreq'</span>,
                <span class="Constant">&quot;Controller '{0}', required by directive '{1}', can't be found!&quot;</span>,
                require, directiveName);
          <span class="Identifier">}</span>
          <span class="Statement">return</span> value;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isArray(require)) <span class="Identifier">{</span>
          value = <span class="Identifier">[]</span>;
          forEach(require, <span class="Identifier">function</span>(require) <span class="Identifier">{</span>
            value.push(getControllers(require, $element, elementControllers));
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>
        <span class="Statement">return</span> value;
      <span class="Identifier">}</span>


      <span class="Identifier">function</span> nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) <span class="Identifier">{</span>
        <span class="Identifier">var</span> attrs, $element, i, ii, linkFn, controller, isolateScope, elementControllers = <span class="Identifier">{}</span>, transcludeFn;

        <span class="Statement">if</span> (compileNode === linkNode) <span class="Identifier">{</span>
          attrs = templateAttrs;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          attrs = shallowCopy(templateAttrs, <span class="Statement">new</span> Attributes(jqLite(linkNode), templateAttrs.$attr));
        <span class="Identifier">}</span>
        $element = attrs.$$element;

        <span class="Statement">if</span> (newIsolateScopeDirective) <span class="Identifier">{</span>
          <span class="Identifier">var</span> LOCAL_REGEXP = <span class="Constant">/^\s*([@=&amp;])(\??)\s*(\w*)\s*$/</span>;
          <span class="Identifier">var</span> $linkNode = jqLite(linkNode);

          isolateScope = scope.$<span class="Statement">new</span>(<span class="Constant">true</span>);

          <span class="Statement">if</span> (templateDirective &amp;&amp; (templateDirective === newIsolateScopeDirective.$$originalDirective)) <span class="Identifier">{</span>
            $linkNode.data(<span class="Constant">'$isolateScope'</span>, isolateScope) ;
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            $linkNode.data(<span class="Constant">'$isolateScopeNoTemplate'</span>, isolateScope);
          <span class="Identifier">}</span>



          safeAddClass($linkNode, <span class="Constant">'ng-isolate-scope'</span>);

          forEach(newIsolateScopeDirective.scope, <span class="Identifier">function</span>(definition, scopeName) <span class="Identifier">{</span>
            <span class="Identifier">var</span> match = definition.match(LOCAL_REGEXP) || <span class="Identifier">[]</span>,
                attrName = match<span class="Identifier">[</span>3<span class="Identifier">]</span> || scopeName,
                optional = (match<span class="Identifier">[</span>2<span class="Identifier">]</span> == <span class="Constant">'?'</span>),
                mode = match<span class="Identifier">[</span>1<span class="Identifier">]</span>, <span class="Comment">// @, =, or &amp;</span>
                lastValue,
                parentGet, parentSet;

            isolateScope.$$isolateBindings<span class="Identifier">[</span>scopeName<span class="Identifier">]</span> = mode + attrName;

            <span class="Statement">switch</span> (mode) <span class="Identifier">{</span>

              <span class="Statement">case</span> <span class="Constant">'@'</span>:
                attrs.$observe(attrName, <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
                  isolateScope<span class="Identifier">[</span>scopeName<span class="Identifier">]</span> = value;
                <span class="Identifier">}</span>);
                attrs.$$observers<span class="Identifier">[</span>attrName<span class="Identifier">]</span>.$$scope = scope;
                <span class="Statement">if</span>( attrs<span class="Identifier">[</span>attrName<span class="Identifier">]</span> ) <span class="Identifier">{</span>
                  <span class="Comment">// If the attribute has been provided then we trigger an interpolation to ensure</span>
                  <span class="Comment">// the value is there for use in the link fn</span>
                  isolateScope<span class="Identifier">[</span>scopeName<span class="Identifier">]</span> = $interpolate(attrs<span class="Identifier">[</span>attrName<span class="Identifier">]</span>)(scope);
                <span class="Identifier">}</span>
                <span class="Statement">break</span>;

              <span class="Statement">case</span> <span class="Constant">'='</span>:
                <span class="Statement">if</span> (optional &amp;&amp; !attrs<span class="Identifier">[</span>attrName<span class="Identifier">]</span>) <span class="Identifier">{</span>
                  <span class="Statement">return</span>;
                <span class="Identifier">}</span>
                parentGet = $parse(attrs<span class="Identifier">[</span>attrName<span class="Identifier">]</span>);
                parentSet = parentGet.assign || <span class="Identifier">function</span>() <span class="Identifier">{</span>
                  <span class="Comment">// reset the change, or we will throw this exception on every $digest</span>
                  lastValue = isolateScope<span class="Identifier">[</span>scopeName<span class="Identifier">]</span> = parentGet(scope);
                  <span class="Statement">throw</span> $compileMinErr(<span class="Constant">'nonassign'</span>,
                      <span class="Constant">&quot;Expression '{0}' used with directive '{1}' is non-assignable!&quot;</span>,
                      attrs<span class="Identifier">[</span>attrName<span class="Identifier">]</span>, newIsolateScopeDirective.name);
                <span class="Identifier">}</span>;
                lastValue = isolateScope<span class="Identifier">[</span>scopeName<span class="Identifier">]</span> = parentGet(scope);
                isolateScope.$watch(<span class="Identifier">function</span> parentValueWatch() <span class="Identifier">{</span>
                  <span class="Identifier">var</span> parentValue = parentGet(scope);

                  <span class="Statement">if</span> (parentValue !== isolateScope<span class="Identifier">[</span>scopeName<span class="Identifier">]</span>) <span class="Identifier">{</span>
                    <span class="Comment">// we are out of sync and need to copy</span>
                    <span class="Statement">if</span> (parentValue !== lastValue) <span class="Identifier">{</span>
                      <span class="Comment">// parent changed and it has precedence</span>
                      isolateScope<span class="Identifier">[</span>scopeName<span class="Identifier">]</span> = parentValue;
                    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
                      <span class="Comment">// if the parent can be assigned then do so</span>
                      parentSet(scope, parentValue = isolateScope<span class="Identifier">[</span>scopeName<span class="Identifier">]</span>);
                    <span class="Identifier">}</span>
                  <span class="Identifier">}</span>
                  <span class="Statement">return</span> lastValue = parentValue;
                <span class="Identifier">}</span>);
                <span class="Statement">break</span>;

              <span class="Statement">case</span> <span class="Constant">'&amp;'</span>:
                parentGet = $parse(attrs<span class="Identifier">[</span>attrName<span class="Identifier">]</span>);
                isolateScope<span class="Identifier">[</span>scopeName<span class="Identifier">]</span> = <span class="Identifier">function</span>(locals) <span class="Identifier">{</span>
                  <span class="Statement">return</span> parentGet(scope, locals);
                <span class="Identifier">}</span>;
                <span class="Statement">break</span>;

              <span class="Statement">default</span>:
                <span class="Statement">throw</span> $compileMinErr(<span class="Constant">'iscp'</span>,
                    <span class="Constant">&quot;Invalid isolate scope definition for directive '{0}'.&quot;</span> +
                    <span class="Constant">&quot; Definition: {... {1}: '{2}' ...}&quot;</span>,
                    newIsolateScopeDirective.name, scopeName, definition);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>
        transcludeFn = boundTranscludeFn &amp;&amp; controllersBoundTransclude;
        <span class="Statement">if</span> (controllerDirectives) <span class="Identifier">{</span>
          forEach(controllerDirectives, <span class="Identifier">function</span>(directive) <span class="Identifier">{</span>
            <span class="Identifier">var</span> locals = <span class="Identifier">{</span>
              $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
              $element: $element,
              $attrs: attrs,
              $transclude: transcludeFn
            <span class="Identifier">}</span>, controllerInstance;

            controller = directive.controller;
            <span class="Statement">if</span> (controller == <span class="Constant">'@'</span>) <span class="Identifier">{</span>
              controller = attrs<span class="Identifier">[</span>directive.name<span class="Identifier">]</span>;
            <span class="Identifier">}</span>

            controllerInstance = $controller(controller, locals);
            <span class="Comment">// For directives with element transclusion the element is a comment,</span>
            <span class="Comment">// but jQuery .data doesn't support attaching data to comment nodes as it's hard to</span>
            <span class="Comment">// clean up (<a href="http://bugs.jquery.com/ticket/8335).">http://bugs.jquery.com/ticket/8335).</a></span>
            <span class="Comment">// Instead, we save the controllers for the element in a local hash and attach to .data</span>
            <span class="Comment">// later, once we have the actual element.</span>
            elementControllers<span class="Identifier">[</span>directive.name<span class="Identifier">]</span> = controllerInstance;
            <span class="Statement">if</span> (!hasElementTranscludeDirective) <span class="Identifier">{</span>
              $element.data(<span class="Constant">'$'</span> + directive.name + <span class="Constant">'Controller'</span>, controllerInstance);
            <span class="Identifier">}</span>

            <span class="Statement">if</span> (directive.controllerAs) <span class="Identifier">{</span>
              locals.$scope<span class="Identifier">[</span>directive.controllerAs<span class="Identifier">]</span> = controllerInstance;
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>

        <span class="Comment">// PRELINKING</span>
        <span class="Statement">for</span>(i = 0, ii = preLinkFns.length; i &lt; ii; i++) <span class="Identifier">{</span>
          <span class="Statement">try</span> <span class="Identifier">{</span>
            linkFn = preLinkFns<span class="Identifier">[</span>i<span class="Identifier">]</span>;
            linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs,
                linkFn.require &amp;&amp; getControllers(linkFn.require, $element, elementControllers), transcludeFn);
          <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
            $exceptionHandler(e, startingTag($element));
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>

        <span class="Comment">// RECURSION</span>
        <span class="Comment">// We only pass the isolate scope, if the isolate directive has a template,</span>
        <span class="Comment">// otherwise the child elements do not belong to the isolate directive.</span>
        <span class="Identifier">var</span> scopeToChild = scope;
        <span class="Statement">if</span> (newIsolateScopeDirective &amp;&amp; (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === <span class="Statement">null</span>)) <span class="Identifier">{</span>
          scopeToChild = isolateScope;
        <span class="Identifier">}</span>
        childLinkFn &amp;&amp; childLinkFn(scopeToChild, linkNode.childNodes, <span class="Statement">undefined</span>, boundTranscludeFn);

        <span class="Comment">// POSTLINKING</span>
        <span class="Statement">for</span>(i = postLinkFns.length - 1; i &gt;= 0; i--) <span class="Identifier">{</span>
          <span class="Statement">try</span> <span class="Identifier">{</span>
            linkFn = postLinkFns<span class="Identifier">[</span>i<span class="Identifier">]</span>;
            linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs,
                linkFn.require &amp;&amp; getControllers(linkFn.require, $element, elementControllers), transcludeFn);
          <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
            $exceptionHandler(e, startingTag($element));
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>

        <span class="Comment">// This is the function that is injected as `$transclude`.</span>
        <span class="Identifier">function</span> controllersBoundTransclude(scope, cloneAttachFn) <span class="Identifier">{</span>
          <span class="Identifier">var</span> transcludeControllers;

          <span class="Comment">// no scope passed</span>
          <span class="Statement">if</span> (<span class="Identifier">arguments</span>.length &lt; 2) <span class="Identifier">{</span>
            cloneAttachFn = scope;
            scope = <span class="Statement">undefined</span>;
          <span class="Identifier">}</span>

          <span class="Statement">if</span> (hasElementTranscludeDirective) <span class="Identifier">{</span>
            transcludeControllers = elementControllers;
          <span class="Identifier">}</span>

          <span class="Statement">return</span> boundTranscludeFn(scope, cloneAttachFn, transcludeControllers);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Identifier">function</span> markDirectivesAsIsolate(directives) <span class="Identifier">{</span>
      <span class="Comment">// mark all directives as needing isolate scope.</span>
      <span class="Statement">for</span> (<span class="Identifier">var</span> j = 0, jj = directives.length; j &lt; jj; j++) <span class="Identifier">{</span>
        directives<span class="Identifier">[</span>j<span class="Identifier">]</span> = inherit(directives<span class="Identifier">[</span>j<span class="Identifier">]</span>, <span class="Identifier">{</span>$$isolateScope: <span class="Constant">true</span><span class="Identifier">}</span>);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Comment">/**</span>
<span class="Comment">     * looks up the directive and decorates it with exception handling and proper parameters. We</span>
<span class="Comment">     * call this the boundDirective.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} name name of the directive to look up.</span>
<span class="Comment">     * @param {string} location The directive must be found in specific format.</span>
<span class="Comment">     *   String containing any of theses characters:</span>
<span class="Comment">     *</span>
<span class="Comment">     *   * `E`: element name</span>
<span class="Comment">     *   * `A': attribute</span>
<span class="Comment">     *   * `C`: class</span>
<span class="Comment">     *   * `M`: comment</span>
<span class="Comment">     * @returns true if directive was added.</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> addDirective(tDirectives, name, <span class="Statement">location</span>, maxPriority, ignoreDirective, startAttrName,
                          endAttrName) <span class="Identifier">{</span>
      <span class="Statement">if</span> (name === ignoreDirective) <span class="Statement">return</span> <span class="Statement">null</span>;
      <span class="Identifier">var</span> match = <span class="Statement">null</span>;
      <span class="Statement">if</span> (hasDirectives.hasOwnProperty(name)) <span class="Identifier">{</span>
        <span class="Statement">for</span>(<span class="Identifier">var</span> directive, directives = $injector.get(name + Suffix),
            i = 0, ii = directives.length; i&lt;ii; i++) <span class="Identifier">{</span>
          <span class="Statement">try</span> <span class="Identifier">{</span>
            directive = directives<span class="Identifier">[</span>i<span class="Identifier">]</span>;
            <span class="Statement">if</span> ( (maxPriority === <span class="Statement">undefined</span> || maxPriority &gt; directive.priority) &amp;&amp;
                 directive.restrict.indexOf(<span class="Statement">location</span>) != -1) <span class="Identifier">{</span>
              <span class="Statement">if</span> (startAttrName) <span class="Identifier">{</span>
                directive = inherit(directive, <span class="Identifier">{</span>$$start: startAttrName, $$end: endAttrName<span class="Identifier">}</span>);
              <span class="Identifier">}</span>
              tDirectives.push(directive);
              match = directive;
            <span class="Identifier">}</span>
          <span class="Identifier">}</span> <span class="Statement">catch</span>(e) <span class="Identifier">{</span> $exceptionHandler(e); <span class="Identifier">}</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
      <span class="Statement">return</span> match;
    <span class="Identifier">}</span>


    <span class="Comment">/**</span>
<span class="Comment">     * When the element is replaced with HTML template then the new attributes</span>
<span class="Comment">     * on the template need to be merged with the existing attributes in the DOM.</span>
<span class="Comment">     * The desired effect is to have both of the attributes present.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {object} dst destination attributes (original DOM)</span>
<span class="Comment">     * @param {object} src source attributes (from the directive template)</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> mergeTemplateAttributes(dst, src) <span class="Identifier">{</span>
      <span class="Identifier">var</span> srcAttr = src.$attr,
          dstAttr = dst.$attr,
          $element = dst.$$element;

      <span class="Comment">// reapply the old attributes to the new element</span>
      forEach(dst, <span class="Identifier">function</span>(value, key) <span class="Identifier">{</span>
        <span class="Statement">if</span> (key.charAt(0) != <span class="Constant">'$'</span>) <span class="Identifier">{</span>
          <span class="Statement">if</span> (src<span class="Identifier">[</span>key<span class="Identifier">]</span>) <span class="Identifier">{</span>
            value += (key === <span class="Constant">'style'</span> ? <span class="Constant">';'</span> : <span class="Constant">' '</span>) + src<span class="Identifier">[</span>key<span class="Identifier">]</span>;
          <span class="Identifier">}</span>
          dst.$set(key, value, <span class="Constant">true</span>, srcAttr<span class="Identifier">[</span>key<span class="Identifier">]</span>);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>);

      <span class="Comment">// copy the new attributes on the old attrs object</span>
      forEach(src, <span class="Identifier">function</span>(value, key) <span class="Identifier">{</span>
        <span class="Statement">if</span> (key == <span class="Constant">'class'</span>) <span class="Identifier">{</span>
          safeAddClass($element, value);
          dst<span class="Identifier">[</span><span class="Constant">'class'</span><span class="Identifier">]</span> = (dst<span class="Identifier">[</span><span class="Constant">'class'</span><span class="Identifier">]</span> ? dst<span class="Identifier">[</span><span class="Constant">'class'</span><span class="Identifier">]</span> + <span class="Constant">' '</span> : <span class="Constant">''</span>) + value;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (key == <span class="Constant">'style'</span>) <span class="Identifier">{</span>
          $element.attr(<span class="Constant">'style'</span>, $element.attr(<span class="Constant">'style'</span>) + <span class="Constant">';'</span> + value);
          dst<span class="Identifier">[</span><span class="Constant">'style'</span><span class="Identifier">]</span> = (dst<span class="Identifier">[</span><span class="Constant">'style'</span><span class="Identifier">]</span> ? dst<span class="Identifier">[</span><span class="Constant">'style'</span><span class="Identifier">]</span> + <span class="Constant">';'</span> : <span class="Constant">''</span>) + value;
          <span class="Comment">// `dst` will never contain hasOwnProperty as DOM parser won't let it.</span>
          <span class="Comment">// You will get an &quot;InvalidCharacterError: DOM Exception 5&quot; error if you</span>
          <span class="Comment">// have an attribute like &quot;has-own-property&quot; or &quot;data-has-own-property&quot;, etc.</span>
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (key.charAt(0) != <span class="Constant">'$'</span> &amp;&amp; !dst.hasOwnProperty(key)) <span class="Identifier">{</span>
          dst<span class="Identifier">[</span>key<span class="Identifier">]</span> = value;
          dstAttr<span class="Identifier">[</span>key<span class="Identifier">]</span> = srcAttr<span class="Identifier">[</span>key<span class="Identifier">]</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>


    <span class="Identifier">function</span> compileTemplateUrl(directives, $compileNode, tAttrs,
        $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) <span class="Identifier">{</span>
      <span class="Identifier">var</span> linkQueue = <span class="Identifier">[]</span>,
          afterTemplateNodeLinkFn,
          afterTemplateChildLinkFn,
          beforeTemplateCompileNode = $compileNode<span class="Identifier">[</span>0<span class="Identifier">]</span>,
          origAsyncDirective = directives.shift(),
          <span class="Comment">// The fact that we have to copy and patch the directive seems wrong!</span>
          derivedSyncDirective = extend(<span class="Identifier">{}</span>, origAsyncDirective, <span class="Identifier">{</span>
            templateUrl: <span class="Statement">null</span>, transclude: <span class="Statement">null</span>, replace: <span class="Statement">null</span>, $$originalDirective: origAsyncDirective
          <span class="Identifier">}</span>),
          templateUrl = (isFunction(origAsyncDirective.templateUrl))
              ? origAsyncDirective.templateUrl($compileNode, tAttrs)
              : origAsyncDirective.templateUrl;

      $compileNode.html(<span class="Constant">''</span>);

      $http.get($sce.getTrustedResourceUrl(templateUrl), <span class="Identifier">{</span>cache: $templateCache<span class="Identifier">}</span>).
        success(<span class="Identifier">function</span>(content) <span class="Identifier">{</span>
          <span class="Identifier">var</span> compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;

          content = denormalizeTemplate(content);

          <span class="Statement">if</span> (origAsyncDirective.replace) <span class="Identifier">{</span>
            $template = jqLite(<span class="Constant">'&lt;div&gt;'</span> + trim(content) + <span class="Constant">'&lt;/div&gt;'</span>).contents();
            compileNode = $template<span class="Identifier">[</span>0<span class="Identifier">]</span>;

            <span class="Statement">if</span> ($template.length != 1 || compileNode.nodeType !== 1) <span class="Identifier">{</span>
              <span class="Statement">throw</span> $compileMinErr(<span class="Constant">'tplrt'</span>,
                  <span class="Constant">&quot;Template for directive '{0}' must have exactly one root element. {1}&quot;</span>,
                  origAsyncDirective.name, templateUrl);
            <span class="Identifier">}</span>

            tempTemplateAttrs = <span class="Identifier">{</span>$attr: <span class="Identifier">{}}</span>;
            replaceWith($rootElement, $compileNode, compileNode);
            <span class="Identifier">var</span> templateDirectives = collectDirectives(compileNode, <span class="Identifier">[]</span>, tempTemplateAttrs);

            <span class="Statement">if</span> (isObject(origAsyncDirective.scope)) <span class="Identifier">{</span>
              markDirectivesAsIsolate(templateDirectives);
            <span class="Identifier">}</span>
            directives = templateDirectives.concat(directives);
            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            compileNode = beforeTemplateCompileNode;
            $compileNode.html(content);
          <span class="Identifier">}</span>

          directives.unshift(derivedSyncDirective);

          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs,
              childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns,
              previousCompileContext);
          forEach($rootElement, <span class="Identifier">function</span>(node, i) <span class="Identifier">{</span>
            <span class="Statement">if</span> (node == compileNode) <span class="Identifier">{</span>
              $rootElement<span class="Identifier">[</span>i<span class="Identifier">]</span> = $compileNode<span class="Identifier">[</span>0<span class="Identifier">]</span>;
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>);
          afterTemplateChildLinkFn = compileNodes($compileNode<span class="Identifier">[</span>0<span class="Identifier">]</span>.childNodes, childTranscludeFn);


          <span class="Statement">while</span>(linkQueue.length) <span class="Identifier">{</span>
            <span class="Identifier">var</span> scope = linkQueue.shift(),
                beforeTemplateLinkNode = linkQueue.shift(),
                linkRootElement = linkQueue.shift(),
                boundTranscludeFn = linkQueue.shift(),
                linkNode = $compileNode<span class="Identifier">[</span>0<span class="Identifier">]</span>;

            <span class="Statement">if</span> (beforeTemplateLinkNode !== beforeTemplateCompileNode) <span class="Identifier">{</span>
              <span class="Comment">// it was cloned therefore we have to clone as well.</span>
              linkNode = jqLiteClone(compileNode);
              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
            <span class="Identifier">}</span>
            <span class="Statement">if</span> (afterTemplateNodeLinkFn.transclude) <span class="Identifier">{</span>
              childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude);
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
              childBoundTranscludeFn = boundTranscludeFn;
            <span class="Identifier">}</span>
            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement,
              childBoundTranscludeFn);
          <span class="Identifier">}</span>
          linkQueue = <span class="Statement">null</span>;
        <span class="Identifier">}</span>).
        error(<span class="Identifier">function</span>(response, code, headers, config) <span class="Identifier">{</span>
          <span class="Statement">throw</span> $compileMinErr(<span class="Constant">'tpload'</span>, <span class="Constant">'Failed to load template: {0}'</span>, config.url);
        <span class="Identifier">}</span>);

      <span class="Statement">return</span> <span class="Identifier">function</span> delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) <span class="Identifier">{</span>
        <span class="Statement">if</span> (linkQueue) <span class="Identifier">{</span>
          linkQueue.push(scope);
          linkQueue.push(node);
          linkQueue.push(rootElement);
          linkQueue.push(boundTranscludeFn);
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, boundTranscludeFn);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>


    <span class="Comment">/**</span>
<span class="Comment">     * Sorting function for bound directives.</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> byPriority(a, b) <span class="Identifier">{</span>
      <span class="Identifier">var</span> diff = b.priority - a.priority;
      <span class="Statement">if</span> (diff !== 0) <span class="Statement">return</span> diff;
      <span class="Statement">if</span> (a.name !== b.name) <span class="Statement">return</span> (a.name &lt; b.name) ? -1 : 1;
      <span class="Statement">return</span> a.index - b.index;
    <span class="Identifier">}</span>


    <span class="Identifier">function</span> assertNoDuplicate(what, previousDirective, directive, element) <span class="Identifier">{</span>
      <span class="Statement">if</span> (previousDirective) <span class="Identifier">{</span>
        <span class="Statement">throw</span> $compileMinErr(<span class="Constant">'multidir'</span>, <span class="Constant">'Multiple directives [{0}, {1}] asking for {2} on: {3}'</span>,
            previousDirective.name, directive.name, what, startingTag(element));
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>


    <span class="Identifier">function</span> addTextInterpolateDirective(directives, text) <span class="Identifier">{</span>
      <span class="Identifier">var</span> interpolateFn = $interpolate(text, <span class="Constant">true</span>);
      <span class="Statement">if</span> (interpolateFn) <span class="Identifier">{</span>
        directives.push(<span class="Identifier">{</span>
          priority: 0,
          compile: valueFn(<span class="Identifier">function</span> textInterpolateLinkFn(scope, node) <span class="Identifier">{</span>
            <span class="Identifier">var</span> <span class="Statement">parent</span> = node.<span class="Statement">parent</span>(),
                bindings = <span class="Statement">parent</span>.data(<span class="Constant">'$binding'</span>) || <span class="Identifier">[]</span>;
            bindings.push(interpolateFn);
            safeAddClass(<span class="Statement">parent</span>.data(<span class="Constant">'$binding'</span>, bindings), <span class="Constant">'ng-binding'</span>);
            scope.$watch(interpolateFn, <span class="Identifier">function</span> interpolateFnWatchAction(value) <span class="Identifier">{</span>
              node<span class="Identifier">[</span>0<span class="Identifier">]</span>.nodeValue = value;
            <span class="Identifier">}</span>);
          <span class="Identifier">}</span>)
        <span class="Identifier">}</span>);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>


    <span class="Identifier">function</span> getTrustedContext(node, attrNormalizedName) <span class="Identifier">{</span>
      <span class="Statement">if</span> (attrNormalizedName == <span class="Constant">&quot;srcdoc&quot;</span>) <span class="Identifier">{</span>
        <span class="Statement">return</span> $sce.HTML;
      <span class="Identifier">}</span>
      <span class="Identifier">var</span> tag = nodeName_(node);
      <span class="Comment">// maction[xlink:href] can source SVG.  It's not limited to &lt;maction&gt;.</span>
      <span class="Statement">if</span> (attrNormalizedName == <span class="Constant">&quot;xlinkHref&quot;</span> ||
          (tag == <span class="Constant">&quot;FORM&quot;</span> &amp;&amp; attrNormalizedName == <span class="Constant">&quot;action&quot;</span>) ||
          (tag != <span class="Constant">&quot;IMG&quot;</span> &amp;&amp; (attrNormalizedName == <span class="Constant">&quot;src&quot;</span> ||
                            attrNormalizedName == <span class="Constant">&quot;ngSrc&quot;</span>))) <span class="Identifier">{</span>
        <span class="Statement">return</span> $sce.RESOURCE_URL;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>


    <span class="Identifier">function</span> addAttrInterpolateDirective(node, directives, value, name) <span class="Identifier">{</span>
      <span class="Identifier">var</span> interpolateFn = $interpolate(value, <span class="Constant">true</span>);

      <span class="Comment">// no interpolation found -&gt; ignore</span>
      <span class="Statement">if</span> (!interpolateFn) <span class="Statement">return</span>;


      <span class="Statement">if</span> (name === <span class="Constant">&quot;multiple&quot;</span> &amp;&amp; nodeName_(node) === <span class="Constant">&quot;SELECT&quot;</span>) <span class="Identifier">{</span>
        <span class="Statement">throw</span> $compileMinErr(<span class="Constant">&quot;selmulti&quot;</span>,
            <span class="Constant">&quot;Binding to the 'multiple' attribute is not supported. Element: {0}&quot;</span>,
            startingTag(node));
      <span class="Identifier">}</span>

      directives.push(<span class="Identifier">{</span>
        priority: 100,
        compile: <span class="Identifier">function</span>() <span class="Identifier">{</span>
            <span class="Statement">return</span> <span class="Identifier">{</span>
              pre: <span class="Identifier">function</span> attrInterpolatePreLinkFn(scope, element, attr) <span class="Identifier">{</span>
                <span class="Identifier">var</span> $$observers = (attr.$$observers || (attr.$$observers = <span class="Identifier">{}</span>));

                <span class="Statement">if</span> (EVENT_HANDLER_ATTR_REGEXP.test(name)) <span class="Identifier">{</span>
                  <span class="Statement">throw</span> $compileMinErr(<span class="Constant">'nodomevents'</span>,
                      <span class="Constant">&quot;Interpolations for HTML DOM event attributes are disallowed.  Please use the &quot;</span> +
                          <span class="Constant">&quot;ng- versions (such as ng-click instead of onclick) instead.&quot;</span>);
                <span class="Identifier">}</span>

                <span class="Comment">// we need to interpolate again, in case the attribute value has been updated</span>
                <span class="Comment">// (e.g. by another directive's compile function)</span>
                interpolateFn = $interpolate(attr<span class="Identifier">[</span>name<span class="Identifier">]</span>, <span class="Constant">true</span>, getTrustedContext(node, name));

                <span class="Comment">// if attribute was updated so that there is no interpolation going on we don't want to</span>
                <span class="Comment">// register any observers</span>
                <span class="Statement">if</span> (!interpolateFn) <span class="Statement">return</span>;

                <span class="Comment">// </span><span class="Todo">TODO</span><span class="Comment">(i): this should likely be attr.$set(name, iterpolateFn(scope) so that we reset the</span>
                <span class="Comment">// actual attr value</span>
                attr<span class="Identifier">[</span>name<span class="Identifier">]</span> = interpolateFn(scope);
                ($$observers<span class="Identifier">[</span>name<span class="Identifier">]</span> || ($$observers<span class="Identifier">[</span>name<span class="Identifier">]</span> = <span class="Identifier">[]</span>)).$$inter = <span class="Constant">true</span>;
                (attr.$$observers &amp;&amp; attr.$$observers<span class="Identifier">[</span>name<span class="Identifier">]</span>.$$scope || scope).
                  $watch(interpolateFn, <span class="Identifier">function</span> interpolateFnWatchAction(newValue, oldValue) <span class="Identifier">{</span>
                    <span class="Comment">//special case for class attribute addition + removal</span>
                    <span class="Comment">//so that class changes can tap into the animation</span>
                    <span class="Comment">//hooks provided by the $animate service. Be sure to</span>
                    <span class="Comment">//skip animations when the first digest occurs (when</span>
                    <span class="Comment">//both the new and the old values are the same) since</span>
                    <span class="Comment">//the CSS classes are the non-interpolated values</span>
                    <span class="Statement">if</span>(name === <span class="Constant">'class'</span> &amp;&amp; newValue != oldValue) <span class="Identifier">{</span>
                      attr.$updateClass(newValue, oldValue);
                    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
                      attr.$set(name, newValue);
                    <span class="Identifier">}</span>
                  <span class="Identifier">}</span>);
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>;
          <span class="Identifier">}</span>
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>


    <span class="Comment">/**</span>
<span class="Comment">     * This is a special jqLite.replaceWith, which can replace items which</span>
<span class="Comment">     * have no parents, provided that the containing jqLite collection is provided.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {JqLite=} $rootElement The root of the compile tree. Used so that we can replace nodes</span>
<span class="Comment">     *                               in the root of the tree.</span>
<span class="Comment">     * @param {JqLite} elementsToRemove The jqLite element which we are going to replace. We keep</span>
<span class="Comment">     *                                  the shell, but replace its DOM node reference.</span>
<span class="Comment">     * @param {Node} newNode The new DOM node.</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> replaceWith($rootElement, elementsToRemove, newNode) <span class="Identifier">{</span>
      <span class="Identifier">var</span> firstElementToRemove = elementsToRemove<span class="Identifier">[</span>0<span class="Identifier">]</span>,
          removeCount = elementsToRemove.length,
          <span class="Statement">parent</span> = firstElementToRemove.parentNode,
          i, ii;

      <span class="Statement">if</span> ($rootElement) <span class="Identifier">{</span>
        <span class="Statement">for</span>(i = 0, ii = $rootElement.length; i &lt; ii; i++) <span class="Identifier">{</span>
          <span class="Statement">if</span> ($rootElement<span class="Identifier">[</span>i<span class="Identifier">]</span> == firstElementToRemove) <span class="Identifier">{</span>
            $rootElement<span class="Identifier">[</span>i++<span class="Identifier">]</span> = newNode;
            <span class="Statement">for</span> (<span class="Identifier">var</span> j = i, j2 = j + removeCount - 1,
                     jj = $rootElement.length;
                 j &lt; jj; j++, j2++) <span class="Identifier">{</span>
              <span class="Statement">if</span> (j2 &lt; jj) <span class="Identifier">{</span>
                $rootElement<span class="Identifier">[</span>j<span class="Identifier">]</span> = $rootElement<span class="Identifier">[</span>j2<span class="Identifier">]</span>;
              <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
                <span class="Statement">delete</span> $rootElement<span class="Identifier">[</span>j<span class="Identifier">]</span>;
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>
            $rootElement.length -= removeCount - 1;
            <span class="Statement">break</span>;
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>

      <span class="Statement">if</span> (<span class="Statement">parent</span>) <span class="Identifier">{</span>
        <span class="Statement">parent</span>.replaceChild(newNode, firstElementToRemove);
      <span class="Identifier">}</span>
      <span class="Identifier">var</span> fragment = <span class="Statement">document</span>.createDocumentFragment();
      fragment.appendChild(firstElementToRemove);
      newNode<span class="Identifier">[</span>jqLite.expando<span class="Identifier">]</span> = firstElementToRemove<span class="Identifier">[</span>jqLite.expando<span class="Identifier">]</span>;
      <span class="Statement">for</span> (<span class="Identifier">var</span> k = 1, kk = elementsToRemove.length; k &lt; kk; k++) <span class="Identifier">{</span>
        <span class="Identifier">var</span> element = elementsToRemove<span class="Identifier">[</span>k<span class="Identifier">]</span>;
        jqLite(element).remove(); <span class="Comment">// must do this way to clean up expando</span>
        fragment.appendChild(element);
        <span class="Statement">delete</span> elementsToRemove<span class="Identifier">[</span>k<span class="Identifier">]</span>;
      <span class="Identifier">}</span>

      elementsToRemove<span class="Identifier">[</span>0<span class="Identifier">]</span> = newNode;
      elementsToRemove.length = 1;
    <span class="Identifier">}</span>


    <span class="Identifier">function</span> cloneAndAnnotateFn(fn, annotation) <span class="Identifier">{</span>
      <span class="Statement">return</span> extend(<span class="Identifier">function</span>() <span class="Identifier">{</span> <span class="Statement">return</span> fn.apply(<span class="Statement">null</span>, <span class="Identifier">arguments</span>); <span class="Identifier">}</span>, fn, annotation);
    <span class="Identifier">}</span>
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Identifier">var</span> PREFIX_REGEXP = <span class="Constant">/^(x[\:\-_]|data[\:\-_])/i</span>;
<span class="Comment">/**</span>
<span class="Comment"> * Converts all accepted directives format into proper directive name.</span>
<span class="Comment"> * All of these will become 'myDirective':</span>
<span class="Comment"> *   my:Directive</span>
<span class="Comment"> *   my-directive</span>
<span class="Comment"> *   x-my-directive</span>
<span class="Comment"> *   data-my:directive</span>
<span class="Comment"> *</span>
<span class="Comment"> * Also there is special case for Moz prefix starting with upper case letter.</span>
<span class="Comment"> * @param name Name to normalize</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> directiveNormalize(name) <span class="Identifier">{</span>
  <span class="Statement">return</span> camelCase(name.replace(PREFIX_REGEXP, <span class="Constant">''</span>));
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$compile.directive.Attributes</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * A shared object between directive compile / linking functions which contains normalized DOM</span>
<span class="Comment"> * element attributes. The values reflect current binding state `{{ }}`. The normalization is</span>
<span class="Comment"> * needed since all of these are treated as equivalent in Angular:</span>
<span class="Comment"> *</span>
<span class="Comment"> *    &lt;span ng:bind=&quot;a&quot; ng-bind=&quot;a&quot; data-ng-bind=&quot;a&quot; x-ng-bind=&quot;a&quot;&gt;</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc property</span>
<span class="Comment"> * @name ng.$compile.directive.Attributes#$attr</span>
<span class="Comment"> * @propertyOf ng.$compile.directive.Attributes</span>
<span class="Comment"> * @returns {object} A map of DOM element attribute names to the normalized name. This is</span>
<span class="Comment"> *                   needed to do reverse lookup from normalized name back to actual name.</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name ng.$compile.directive.Attributes#$set</span>
<span class="Comment"> * @methodOf ng.$compile.directive.Attributes</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Set DOM element attribute value.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} name Normalized element attribute name of the property to modify. The name is</span>
<span class="Comment"> *          revers translated using the {@link ng.$compile.directive.Attributes#$attr $attr}</span>
<span class="Comment"> *          property to the original name.</span>
<span class="Comment"> * @param {string} value Value to set the attribute to. The value can be an interpolated string.</span>
<span class="Comment"> */</span>



<span class="Comment">/**</span>
<span class="Comment"> * Closure compiler type information</span>
<span class="Comment"> */</span>

<span class="Identifier">function</span> nodesetLinkingFn(
  <span class="Comment">/* angular.Scope */</span> scope,
  <span class="Comment">/* NodeList */</span> nodeList,
  <span class="Comment">/* Element */</span> rootElement,
  <span class="Comment">/* function(Function) */</span> boundTranscludeFn
)<span class="Identifier">{}</span>

<span class="Identifier">function</span> directiveLinkingFn(
  <span class="Comment">/* nodesetLinkingFn */</span> nodesetLinkingFn,
  <span class="Comment">/* angular.Scope */</span> scope,
  <span class="Comment">/* Node */</span> node,
  <span class="Comment">/* Element */</span> rootElement,
  <span class="Comment">/* function(Function) */</span> boundTranscludeFn
)<span class="Identifier">{}</span>

<span class="Identifier">function</span> tokenDifference(str1, str2) <span class="Identifier">{</span>
  <span class="Identifier">var</span> values = <span class="Constant">''</span>,
      tokens1 = str1.split(<span class="Constant">/\s+/</span>),
      tokens2 = str2.split(<span class="Constant">/\s+/</span>);

  outer:
  <span class="Statement">for</span>(<span class="Identifier">var</span> i = 0; i &lt; tokens1.length; i++) <span class="Identifier">{</span>
    <span class="Identifier">var</span> token = tokens1<span class="Identifier">[</span>i<span class="Identifier">]</span>;
    <span class="Statement">for</span>(<span class="Identifier">var</span> j = 0; j &lt; tokens2.length; j++) <span class="Identifier">{</span>
      <span class="Statement">if</span>(token == tokens2<span class="Identifier">[</span>j<span class="Identifier">]</span>) <span class="Statement">continue</span> outer;
    <span class="Identifier">}</span>
    values += (values.length &gt; 0 ? <span class="Constant">' '</span> : <span class="Constant">''</span>) + token;
  <span class="Identifier">}</span>
  <span class="Statement">return</span> values;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$controllerProvider</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The {@link ng.$controller $controller service} is used by Angular to create new</span>
<span class="Comment"> * controllers.</span>
<span class="Comment"> *</span>
<span class="Comment"> * This provider allows controller registration via the</span>
<span class="Comment"> * {@link ng.$controllerProvider#methods_register register} method.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $ControllerProvider() <span class="Identifier">{</span>
  <span class="Identifier">var</span> controllers = <span class="Identifier">{}</span>,
      CNTRL_REG = <span class="Constant">/^(\S+)(\s+as\s+(\w+))?$/</span>;


  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.$controllerProvider#register</span>
<span class="Comment">   * @methodOf ng.$controllerProvider</span>
<span class="Comment">   * @param {string|Object} name Controller name, or an object map of controllers where the keys are</span>
<span class="Comment">   *    the names and the values are the constructors.</span>
<span class="Comment">   * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI</span>
<span class="Comment">   *    annotations in the array notation).</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.register = <span class="Identifier">function</span>(name, constructor) <span class="Identifier">{</span>
    assertNotHasOwnProperty(name, <span class="Constant">'controller'</span>);
    <span class="Statement">if</span> (isObject(name)) <span class="Identifier">{</span>
      extend(controllers, name);
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      controllers<span class="Identifier">[</span>name<span class="Identifier">]</span> = constructor;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;


  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$injector'</span>, <span class="Constant">'$window'</span>, <span class="Identifier">function</span>($injector, $<span class="Statement">window</span>) <span class="Identifier">{</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc function</span>
<span class="Comment">     * @name ng.$controller</span>
<span class="Comment">     * @requires $injector</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {Function|string} constructor If called with a function then it's considered to be the</span>
<span class="Comment">     *    controller constructor function. Otherwise it's considered to be a string which is used</span>
<span class="Comment">     *    to retrieve the controller constructor using the following steps:</span>
<span class="Comment">     *</span>
<span class="Comment">     *    * check if a controller with given name is registered via `$controllerProvider`</span>
<span class="Comment">     *    * check if evaluating the string on the current scope returns a constructor</span>
<span class="Comment">     *    * check `window[constructor]` on the global `window` object</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {Object} locals Injection locals for Controller.</span>
<span class="Comment">     * @return {Object} Instance of given controller.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * `$controller` service is responsible for instantiating controllers.</span>
<span class="Comment">     *</span>
<span class="Comment">     * It's just a simple call to {@link AUTO.$injector $injector}, but extracted into</span>
<span class="Comment">     * a service, so that one can override this service with {@link <a href="https://gist.github.com/1649788">https://gist.github.com/1649788</a></span>
<span class="Comment">     * BC version}.</span>
<span class="Comment">     */</span>
    <span class="Statement">return</span> <span class="Identifier">function</span>(expression, locals) <span class="Identifier">{</span>
      <span class="Identifier">var</span> instance, match, constructor, identifier;

      <span class="Statement">if</span>(isString(expression)) <span class="Identifier">{</span>
        match = expression.match(CNTRL_REG),
        constructor = match<span class="Identifier">[</span>1<span class="Identifier">]</span>,
        identifier = match<span class="Identifier">[</span>3<span class="Identifier">]</span>;
        expression = controllers.hasOwnProperty(constructor)
            ? controllers<span class="Identifier">[</span>constructor<span class="Identifier">]</span>
            : getter(locals.$scope, constructor, <span class="Constant">true</span>) || getter($<span class="Statement">window</span>, constructor, <span class="Constant">true</span>);

        assertArgFn(expression, constructor, <span class="Constant">true</span>);
      <span class="Identifier">}</span>

      instance = $injector.instantiate(expression, locals);

      <span class="Statement">if</span> (identifier) <span class="Identifier">{</span>
        <span class="Statement">if</span> (!(locals &amp;&amp; <span class="Statement">typeof</span> locals.$scope == <span class="Constant">'object'</span>)) <span class="Identifier">{</span>
          <span class="Statement">throw</span> minErr(<span class="Constant">'$controller'</span>)(<span class="Constant">'noscp'</span>,
              <span class="Constant">&quot;Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.&quot;</span>,
              constructor || expression.name, identifier);
        <span class="Identifier">}</span>

        locals.$scope<span class="Identifier">[</span>identifier<span class="Identifier">]</span> = instance;
      <span class="Identifier">}</span>

      <span class="Statement">return</span> instance;
    <span class="Identifier">}</span>;
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$document</span>
<span class="Comment"> * @requires $window</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * A {@link angular.element jQuery (lite)}-wrapped reference to the browser's `window.document`</span>
<span class="Comment"> * element.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $DocumentProvider()<span class="Identifier">{</span>
  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$window'</span>, <span class="Identifier">function</span>(<span class="Statement">window</span>)<span class="Identifier">{</span>
    <span class="Statement">return</span> jqLite(<span class="Statement">window</span>.<span class="Statement">document</span>);
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name ng.$exceptionHandler</span>
<span class="Comment"> * @requires $log</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Any uncaught exception in angular expressions is delegated to this service.</span>
<span class="Comment"> * The default implementation simply delegates to `$log.error` which logs it into</span>
<span class="Comment"> * the browser console.</span>
<span class="Comment"> * </span>
<span class="Comment"> * In unit tests, if `angular-mocks.js` is loaded, this service is overridden by</span>
<span class="Comment"> * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## Example:</span>
<span class="Comment"> * </span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   angular.module('exceptionOverride', []).factory('$exceptionHandler', function () {</span>
<span class="Comment"> *     return function (exception, cause) {</span>
<span class="Comment"> *       exception.message += ' (caused by &quot;' + cause + '&quot;)';</span>
<span class="Comment"> *       throw exception;</span>
<span class="Comment"> *     };</span>
<span class="Comment"> *   });</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> * </span>
<span class="Comment"> * This example will override the normal action of `$exceptionHandler`, to make angular</span>
<span class="Comment"> * exceptions fail hard when they happen, instead of just logging to the console.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {Error} exception Exception associated with the error.</span>
<span class="Comment"> * @param {string=} cause optional information about the context in which</span>
<span class="Comment"> *       the error was thrown.</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $ExceptionHandlerProvider() <span class="Identifier">{</span>
  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$log'</span>, <span class="Identifier">function</span>($log) <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">function</span>(exception, cause) <span class="Identifier">{</span>
      $log.error.apply($log, <span class="Identifier">arguments</span>);
    <span class="Identifier">}</span>;
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * Parse headers into key value object</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} headers Raw headers as a string</span>
<span class="Comment"> * @returns {Object} Parsed headers as key value object</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> parseHeaders(headers) <span class="Identifier">{</span>
  <span class="Identifier">var</span> parsed = <span class="Identifier">{}</span>, key, val, i;

  <span class="Statement">if</span> (!headers) <span class="Statement">return</span> parsed;

  forEach(headers.split(<span class="Special">'\n'</span>), <span class="Identifier">function</span>(line) <span class="Identifier">{</span>
    i = line.indexOf(<span class="Constant">':'</span>);
    key = lowercase(trim(line.substr(0, i)));
    val = trim(line.substr(i + 1));

    <span class="Statement">if</span> (key) <span class="Identifier">{</span>
      <span class="Statement">if</span> (parsed<span class="Identifier">[</span>key<span class="Identifier">]</span>) <span class="Identifier">{</span>
        parsed<span class="Identifier">[</span>key<span class="Identifier">]</span> += <span class="Constant">', '</span> + val;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        parsed<span class="Identifier">[</span>key<span class="Identifier">]</span> = val;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>);

  <span class="Statement">return</span> parsed;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * Returns a function that provides access to parsed headers.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Headers are lazy parsed when first requested.</span>
<span class="Comment"> * @see parseHeaders</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {(string|Object)} headers Headers to provide access to.</span>
<span class="Comment"> * @returns {function(string=)} Returns a getter function which if called with:</span>
<span class="Comment"> *</span>
<span class="Comment"> *   - if called with single an argument returns a single header value or null</span>
<span class="Comment"> *   - if called with no arguments returns an object containing all headers.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> headersGetter(headers) <span class="Identifier">{</span>
  <span class="Identifier">var</span> headersObj = isObject(headers) ? headers : <span class="Statement">undefined</span>;

  <span class="Statement">return</span> <span class="Identifier">function</span>(name) <span class="Identifier">{</span>
    <span class="Statement">if</span> (!headersObj) headersObj =  parseHeaders(headers);

    <span class="Statement">if</span> (name) <span class="Identifier">{</span>
      <span class="Statement">return</span> headersObj<span class="Identifier">[</span>lowercase(name)<span class="Identifier">]</span> || <span class="Statement">null</span>;
    <span class="Identifier">}</span>

    <span class="Statement">return</span> headersObj;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * Chain all given functions</span>
<span class="Comment"> *</span>
<span class="Comment"> * This function is used for both request and response transforming</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {*} data Data to transform.</span>
<span class="Comment"> * @param {function(string=)} headers Http headers getter fn.</span>
<span class="Comment"> * @param {(function|Array.&lt;function&gt;)} fns Function or an array of functions.</span>
<span class="Comment"> * @returns {*} Transformed data.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> transformData(data, headers, fns) <span class="Identifier">{</span>
  <span class="Statement">if</span> (isFunction(fns))
    <span class="Statement">return</span> fns(data, headers);

  forEach(fns, <span class="Identifier">function</span>(fn) <span class="Identifier">{</span>
    data = fn(data, headers);
  <span class="Identifier">}</span>);

  <span class="Statement">return</span> data;
<span class="Identifier">}</span>


<span class="Identifier">function</span> isSuccess(<span class="Statement">status</span>) <span class="Identifier">{</span>
  <span class="Statement">return</span> 200 &lt;= <span class="Statement">status</span> &amp;&amp; <span class="Statement">status</span> &lt; 300;
<span class="Identifier">}</span>


<span class="Identifier">function</span> $HttpProvider() <span class="Identifier">{</span>
  <span class="Identifier">var</span> JSON_START = <span class="Constant">/^\s*(\[|\{[^\{])/</span>,
      JSON_END = <span class="Constant">/[\}\]]\s*$/</span>,
      PROTECTION_PREFIX = <span class="Constant">/^\)\]\}',?\n/</span>,
      CONTENT_TYPE_APPLICATION_JSON = <span class="Identifier">{</span><span class="Constant">'Content-Type'</span>: <span class="Constant">'application/json;charset=utf-8'</span><span class="Identifier">}</span>;

  <span class="Identifier">var</span> defaults = <span class="Identifier">this</span>.defaults = <span class="Identifier">{</span>
    <span class="Comment">// transform incoming response data</span>
    transformResponse: <span class="Identifier">[</span><span class="Identifier">function</span>(data) <span class="Identifier">{</span>
      <span class="Statement">if</span> (isString(data)) <span class="Identifier">{</span>
        <span class="Comment">// strip json vulnerability protection prefix</span>
        data = data.replace(PROTECTION_PREFIX, <span class="Constant">''</span>);
        <span class="Statement">if</span> (JSON_START.test(data) &amp;&amp; JSON_END.test(data))
          data = fromJson(data);
      <span class="Identifier">}</span>
      <span class="Statement">return</span> data;
    <span class="Identifier">}]</span>,

    <span class="Comment">// transform outgoing request data</span>
    transformRequest: <span class="Identifier">[</span><span class="Identifier">function</span>(d) <span class="Identifier">{</span>
      <span class="Statement">return</span> isObject(d) &amp;&amp; !isFile(d) ? toJson(d) : d;
    <span class="Identifier">}]</span>,

    <span class="Comment">// default headers</span>
    headers: <span class="Identifier">{</span>
      common: <span class="Identifier">{</span>
        <span class="Constant">'Accept'</span>: <span class="Constant">'application/json, text/plain, */*'</span>
      <span class="Identifier">}</span>,
      post:   CONTENT_TYPE_APPLICATION_JSON,
      put:    CONTENT_TYPE_APPLICATION_JSON,
      patch:  CONTENT_TYPE_APPLICATION_JSON
    <span class="Identifier">}</span>,

    xsrfCookieName: <span class="Constant">'XSRF-TOKEN'</span>,
    xsrfHeaderName: <span class="Constant">'X-XSRF-TOKEN'</span>
  <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * Are ordered by request, i.e. they are applied in the same order as the</span>
<span class="Comment">   * array, on request, but reverse order, on response.</span>
<span class="Comment">   */</span>
  <span class="Identifier">var</span> interceptorFactories = <span class="Identifier">this</span>.interceptors = <span class="Identifier">[]</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * For historical reasons, response interceptors are ordered by the order in which</span>
<span class="Comment">   * they are applied to the response. (This is the opposite of interceptorFactories)</span>
<span class="Comment">   */</span>
  <span class="Identifier">var</span> responseInterceptorFactories = <span class="Identifier">this</span>.responseInterceptors = <span class="Identifier">[]</span>;

  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$httpBackend'</span>, <span class="Constant">'$browser'</span>, <span class="Constant">'$cacheFactory'</span>, <span class="Constant">'$rootScope'</span>, <span class="Constant">'$q'</span>, <span class="Constant">'$injector'</span>,
      <span class="Identifier">function</span>($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) <span class="Identifier">{</span>

    <span class="Identifier">var</span> defaultCache = $cacheFactory(<span class="Constant">'$http'</span>);

    <span class="Comment">/**</span>
<span class="Comment">     * Interceptors stored in reverse order. Inner interceptors before outer interceptors.</span>
<span class="Comment">     * The reversal is needed so that we can build up the interception chain around the</span>
<span class="Comment">     * server request.</span>
<span class="Comment">     */</span>
    <span class="Identifier">var</span> reversedInterceptors = <span class="Identifier">[]</span>;

    forEach(interceptorFactories, <span class="Identifier">function</span>(interceptorFactory) <span class="Identifier">{</span>
      reversedInterceptors.unshift(isString(interceptorFactory)
          ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
    <span class="Identifier">}</span>);

    forEach(responseInterceptorFactories, <span class="Identifier">function</span>(interceptorFactory, index) <span class="Identifier">{</span>
      <span class="Identifier">var</span> responseFn = isString(interceptorFactory)
          ? $injector.get(interceptorFactory)
          : $injector.invoke(interceptorFactory);

      <span class="Comment">/**</span>
<span class="Comment">       * Response interceptors go before &quot;around&quot; interceptors (no real reason, just</span>
<span class="Comment">       * had to pick one.) But they are already reversed, so we can't use unshift, hence</span>
<span class="Comment">       * the splice.</span>
<span class="Comment">       */</span>
      reversedInterceptors.splice(index, 0, <span class="Identifier">{</span>
        response: <span class="Identifier">function</span>(response) <span class="Identifier">{</span>
          <span class="Statement">return</span> responseFn($q.when(response));
        <span class="Identifier">}</span>,
        responseError: <span class="Identifier">function</span>(response) <span class="Identifier">{</span>
          <span class="Statement">return</span> responseFn($q.reject(response));
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>);


    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc function</span>
<span class="Comment">     * @name ng.$http</span>
<span class="Comment">     * @requires $httpBackend</span>
<span class="Comment">     * @requires $browser</span>
<span class="Comment">     * @requires $cacheFactory</span>
<span class="Comment">     * @requires $rootScope</span>
<span class="Comment">     * @requires $q</span>
<span class="Comment">     * @requires $injector</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * The `$http` service is a core Angular service that facilitates communication with the remote</span>
<span class="Comment">     * HTTP servers via the browser's {@link <a href="https://developer.mozilla.org/en/xmlhttprequest">https://developer.mozilla.org/en/xmlhttprequest</a></span>
<span class="Comment">     * XMLHttpRequest} object or via {@link <a href="http://en.wikipedia.org/wiki/JSONP">http://en.wikipedia.org/wiki/JSONP</a> JSONP}.</span>
<span class="Comment">     *</span>
<span class="Comment">     * For unit testing applications that use `$http` service, see</span>
<span class="Comment">     * {@link ngMock.$httpBackend $httpBackend mock}.</span>
<span class="Comment">     *</span>
<span class="Comment">     * For a higher level of abstraction, please check out the {@link ngResource.$resource</span>
<span class="Comment">     * $resource} service.</span>
<span class="Comment">     *</span>
<span class="Comment">     * The $http API is based on the {@link ng.$q deferred/promise APIs} exposed by</span>
<span class="Comment">     * the $q service. While for simple usage patterns this doesn't matter much, for advanced usage</span>
<span class="Comment">     * it is important to familiarize yourself with these APIs and the guarantees they provide.</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     * # General usage</span>
<span class="Comment">     * The `$http` service is a function which takes a single argument — a configuration object —</span>
<span class="Comment">     * that is used to generate an HTTP request and returns  a {@link ng.$q promise}</span>
<span class="Comment">     * with two $http specific methods: `success` and `error`.</span>
<span class="Comment">     *</span>
<span class="Comment">     * &lt;pre&gt;</span>
<span class="Comment">     *   $http({method: 'GET', url: '/someUrl'}).</span>
<span class="Comment">     *     success(function(data, status, headers, config) {</span>
<span class="Comment">     *       // this callback will be called asynchronously</span>
<span class="Comment">     *       // when the response is available</span>
<span class="Comment">     *     }).</span>
<span class="Comment">     *     error(function(data, status, headers, config) {</span>
<span class="Comment">     *       // called asynchronously if an error occurs</span>
<span class="Comment">     *       // or server returns response with an error status.</span>
<span class="Comment">     *     });</span>
<span class="Comment">     * &lt;/pre&gt;</span>
<span class="Comment">     *</span>
<span class="Comment">     * Since the returned value of calling the $http function is a `promise`, you can also use</span>
<span class="Comment">     * the `then` method to register callbacks, and these callbacks will receive a single argument –</span>
<span class="Comment">     * an object representing the response. See the API signature and type info below for more</span>
<span class="Comment">     * details.</span>
<span class="Comment">     *</span>
<span class="Comment">     * A response status code between 200 and 299 is considered a success status and</span>
<span class="Comment">     * will result in the success callback being called. Note that if the response is a redirect,</span>
<span class="Comment">     * XMLHttpRequest will transparently follow it, meaning that the error callback will not be</span>
<span class="Comment">     * called for such responses.</span>
<span class="Comment">     * </span>
<span class="Comment">     * # Calling $http from outside AngularJS</span>
<span class="Comment">     * The `$http` service will not actually send the request until the next `$digest()` is</span>
<span class="Comment">     * executed. Normally this is not an issue, since almost all the time your call to `$http` will</span>
<span class="Comment">     * be from within a `$apply()` block.</span>
<span class="Comment">     * If you are calling `$http` from outside Angular, then you should wrap it in a call to</span>
<span class="Comment">     * `$apply` to cause a $digest to occur and also to handle errors in the block correctly.</span>
<span class="Comment">     *</span>
<span class="Comment">     * ```</span>
<span class="Comment">     * $scope.$apply(function() {</span>
<span class="Comment">     *   $http(...);</span>
<span class="Comment">     * });</span>
<span class="Comment">     * ```</span>
<span class="Comment">     *</span>
<span class="Comment">     * # Writing Unit Tests that use $http</span>
<span class="Comment">     * When unit testing you are mostly responsible for scheduling the `$digest` cycle. If you do</span>
<span class="Comment">     * not trigger a `$digest` before calling `$httpBackend.flush()` then the request will not have</span>
<span class="Comment">     * been made and `$httpBackend.expect(...)` expectations will fail.  The solution is to run the</span>
<span class="Comment">     * code that calls the `$http()` method inside a $apply block as explained in the previous</span>
<span class="Comment">     * section.</span>
<span class="Comment">     *</span>
<span class="Comment">     * ```</span>
<span class="Comment">     * $httpBackend.expectGET(...);</span>
<span class="Comment">     * $scope.$apply(function() {</span>
<span class="Comment">     *   $http.get(...);</span>
<span class="Comment">     * });</span>
<span class="Comment">     * $httpBackend.flush();</span>
<span class="Comment">     * ```</span>
<span class="Comment">     *</span>
<span class="Comment">     * # Shortcut methods</span>
<span class="Comment">     *</span>
<span class="Comment">     * Since all invocations of the $http service require passing in an HTTP method and URL, and</span>
<span class="Comment">     * POST/PUT requests require request data to be provided as well, shortcut methods</span>
<span class="Comment">     * were created:</span>
<span class="Comment">     *</span>
<span class="Comment">     * &lt;pre&gt;</span>
<span class="Comment">     *   $http.get('/someUrl').success(successCallback);</span>
<span class="Comment">     *   $http.post('/someUrl', data).success(successCallback);</span>
<span class="Comment">     * &lt;/pre&gt;</span>
<span class="Comment">     *</span>
<span class="Comment">     * Complete list of shortcut methods:</span>
<span class="Comment">     *</span>
<span class="Comment">     * - {@link ng.$http#methods_get $http.get}</span>
<span class="Comment">     * - {@link ng.$http#methods_head $http.head}</span>
<span class="Comment">     * - {@link ng.$http#methods_post $http.post}</span>
<span class="Comment">     * - {@link ng.$http#methods_put $http.put}</span>
<span class="Comment">     * - {@link ng.$http#methods_delete $http.delete}</span>
<span class="Comment">     * - {@link ng.$http#methods_jsonp $http.jsonp}</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     * # Setting HTTP Headers</span>
<span class="Comment">     *</span>
<span class="Comment">     * The $http service will automatically add certain HTTP headers to all requests. These defaults</span>
<span class="Comment">     * can be fully configured by accessing the `$httpProvider.defaults.headers` configuration</span>
<span class="Comment">     * object, which currently contains this default configuration:</span>
<span class="Comment">     *</span>
<span class="Comment">     * - `$httpProvider.defaults.headers.common` (headers that are common for all requests):</span>
<span class="Comment">     *   - `Accept: application/json, text/plain, * / *`</span>
<span class="Comment">     * - `$httpProvider.defaults.headers.post`: (header defaults for POST requests)</span>
<span class="Comment">     *   - `Content-Type: application/json`</span>
<span class="Comment">     * - `$httpProvider.defaults.headers.put` (header defaults for PUT requests)</span>
<span class="Comment">     *   - `Content-Type: application/json`</span>
<span class="Comment">     *</span>
<span class="Comment">     * To add or overwrite these defaults, simply add or remove a property from these configuration</span>
<span class="Comment">     * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object</span>
<span class="Comment">     * with the lowercased HTTP method name as the key, e.g.</span>
<span class="Comment">     * `$httpProvider.defaults.headers.get = { 'My-Header' : 'value' }.</span>
<span class="Comment">     *</span>
<span class="Comment">     * The defaults can also be set at runtime via the `$http.defaults` object in the same</span>
<span class="Comment">     * fashion. In addition, you can supply a `headers` property in the config object passed when</span>
<span class="Comment">     * calling `$http(config)`, which overrides the defaults without changing them globally.</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     * # Transforming Requests and Responses</span>
<span class="Comment">     *</span>
<span class="Comment">     * Both requests and responses can be transformed using transform functions. By default, Angular</span>
<span class="Comment">     * applies these transformations:</span>
<span class="Comment">     *</span>
<span class="Comment">     * Request transformations:</span>
<span class="Comment">     *</span>
<span class="Comment">     * - If the `data` property of the request configuration object contains an object, serialize it</span>
<span class="Comment">     *   into JSON format.</span>
<span class="Comment">     *</span>
<span class="Comment">     * Response transformations:</span>
<span class="Comment">     *</span>
<span class="Comment">     *  - If XSRF prefix is detected, strip it (see Security Considerations section below).</span>
<span class="Comment">     *  - If JSON response is detected, deserialize it using a JSON parser.</span>
<span class="Comment">     *</span>
<span class="Comment">     * To globally augment or override the default transforms, modify the</span>
<span class="Comment">     * `$httpProvider.defaults.transformRequest` and `$httpProvider.defaults.transformResponse`</span>
<span class="Comment">     * properties. These properties are by default an array of transform functions, which allows you</span>
<span class="Comment">     * to `push` or `unshift` a new transformation function into the transformation chain. You can</span>
<span class="Comment">     * also decide to completely override any default transformations by assigning your</span>
<span class="Comment">     * transformation functions to these properties directly without the array wrapper.</span>
<span class="Comment">     *</span>
<span class="Comment">     * Similarly, to locally override the request/response transforms, augment the</span>
<span class="Comment">     * `transformRequest` and/or `transformResponse` properties of the configuration object passed</span>
<span class="Comment">     * into `$http`.</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     * # Caching</span>
<span class="Comment">     *</span>
<span class="Comment">     * To enable caching, set the request configuration `cache` property to `true` (to use default</span>
<span class="Comment">     * cache) or to a custom cache object (built with {@link ng.$cacheFactory `$cacheFactory`}).</span>
<span class="Comment">     * When the cache is enabled, `$http` stores the response from the server in the specified</span>
<span class="Comment">     * cache. The next time the same request is made, the response is served from the cache without</span>
<span class="Comment">     * sending a request to the server.</span>
<span class="Comment">     *</span>
<span class="Comment">     * Note that even if the response is served from cache, delivery of the data is asynchronous in</span>
<span class="Comment">     * the same way that real requests are.</span>
<span class="Comment">     *</span>
<span class="Comment">     * If there are multiple GET requests for the same URL that should be cached using the same</span>
<span class="Comment">     * cache, but the cache is not populated yet, only one request to the server will be made and</span>
<span class="Comment">     * the remaining requests will be fulfilled using the response from the first request.</span>
<span class="Comment">     *</span>
<span class="Comment">     * You can change the default cache to a new object (built with</span>
<span class="Comment">     * {@link ng.$cacheFactory `$cacheFactory`}) by updating the</span>
<span class="Comment">     * {@link ng.$http#properties_defaults `$http.defaults.cache`} property. All requests who set</span>
<span class="Comment">     * their `cache` property to `true` will now use this cache object.</span>
<span class="Comment">     *</span>
<span class="Comment">     * If you set the default cache to `false` then only requests that specify their own custom</span>
<span class="Comment">     * cache object will be cached.</span>
<span class="Comment">     *</span>
<span class="Comment">     * # Interceptors</span>
<span class="Comment">     *</span>
<span class="Comment">     * Before you start creating interceptors, be sure to understand the</span>
<span class="Comment">     * {@link ng.$q $q and deferred/promise APIs}.</span>
<span class="Comment">     *</span>
<span class="Comment">     * For purposes of global error handling, authentication, or any kind of synchronous or</span>
<span class="Comment">     * asynchronous pre-processing of request or postprocessing of responses, it is desirable to be</span>
<span class="Comment">     * able to intercept requests before they are handed to the server and</span>
<span class="Comment">     * responses before they are handed over to the application code that</span>
<span class="Comment">     * initiated these requests. The interceptors leverage the {@link ng.$q</span>
<span class="Comment">     * promise APIs} to fulfill this need for both synchronous and asynchronous pre-processing.</span>
<span class="Comment">     *</span>
<span class="Comment">     * The interceptors are service factories that are registered with the `$httpProvider` by</span>
<span class="Comment">     * adding them to the `$httpProvider.interceptors` array. The factory is called and</span>
<span class="Comment">     * injected with dependencies (if specified) and returns the interceptor.</span>
<span class="Comment">     *</span>
<span class="Comment">     * There are two kinds of interceptors (and two kinds of rejection interceptors):</span>
<span class="Comment">     *</span>
<span class="Comment">     *   * `request`: interceptors get called with http `config` object. The function is free to</span>
<span class="Comment">     *     modify the `config` or create a new one. The function needs to return the `config`</span>
<span class="Comment">     *     directly or as a promise.</span>
<span class="Comment">     *   * `requestError`: interceptor gets called when a previous interceptor threw an error or</span>
<span class="Comment">     *     resolved with a rejection.</span>
<span class="Comment">     *   * `response`: interceptors get called with http `response` object. The function is free to</span>
<span class="Comment">     *     modify the `response` or create a new one. The function needs to return the `response`</span>
<span class="Comment">     *     directly or as a promise.</span>
<span class="Comment">     *   * `responseError`: interceptor gets called when a previous interceptor threw an error or</span>
<span class="Comment">     *     resolved with a rejection.</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     * &lt;pre&gt;</span>
<span class="Comment">     *   // register the interceptor as a service</span>
<span class="Comment">     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {</span>
<span class="Comment">     *     return {</span>
<span class="Comment">     *       // optional method</span>
<span class="Comment">     *       'request': function(config) {</span>
<span class="Comment">     *         // do something on success</span>
<span class="Comment">     *         return config || $q.when(config);</span>
<span class="Comment">     *       },</span>
<span class="Comment">     *</span>
<span class="Comment">     *       // optional method</span>
<span class="Comment">     *      'requestError': function(rejection) {</span>
<span class="Comment">     *         // do something on error</span>
<span class="Comment">     *         if (canRecover(rejection)) {</span>
<span class="Comment">     *           return responseOrNewPromise</span>
<span class="Comment">     *         }</span>
<span class="Comment">     *         return $q.reject(rejection);</span>
<span class="Comment">     *       },</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     *       // optional method</span>
<span class="Comment">     *       'response': function(response) {</span>
<span class="Comment">     *         // do something on success</span>
<span class="Comment">     *         return response || $q.when(response);</span>
<span class="Comment">     *       },</span>
<span class="Comment">     *</span>
<span class="Comment">     *       // optional method</span>
<span class="Comment">     *      'responseError': function(rejection) {</span>
<span class="Comment">     *         // do something on error</span>
<span class="Comment">     *         if (canRecover(rejection)) {</span>
<span class="Comment">     *           return responseOrNewPromise</span>
<span class="Comment">     *         }</span>
<span class="Comment">     *         return $q.reject(rejection);</span>
<span class="Comment">     *       };</span>
<span class="Comment">     *     }</span>
<span class="Comment">     *   });</span>
<span class="Comment">     *</span>
<span class="Comment">     *   $httpProvider.interceptors.push('myHttpInterceptor');</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     *   // register the interceptor via an anonymous factory</span>
<span class="Comment">     *   $httpProvider.interceptors.push(function($q, dependency1, dependency2) {</span>
<span class="Comment">     *     return {</span>
<span class="Comment">     *      'request': function(config) {</span>
<span class="Comment">     *          // same as above</span>
<span class="Comment">     *       },</span>
<span class="Comment">     *       'response': function(response) {</span>
<span class="Comment">     *          // same as above</span>
<span class="Comment">     *       }</span>
<span class="Comment">     *     };</span>
<span class="Comment">     *   });</span>
<span class="Comment">     * &lt;/pre&gt;</span>
<span class="Comment">     *</span>
<span class="Comment">     * # Response interceptors (DEPRECATED)</span>
<span class="Comment">     *</span>
<span class="Comment">     * Before you start creating interceptors, be sure to understand the</span>
<span class="Comment">     * {@link ng.$q $q and deferred/promise APIs}.</span>
<span class="Comment">     *</span>
<span class="Comment">     * For purposes of global error handling, authentication or any kind of synchronous or</span>
<span class="Comment">     * asynchronous preprocessing of received responses, it is desirable to be able to intercept</span>
<span class="Comment">     * responses for http requests before they are handed over to the application code that</span>
<span class="Comment">     * initiated these requests. The response interceptors leverage the {@link ng.$q</span>
<span class="Comment">     * promise apis} to fulfil this need for both synchronous and asynchronous preprocessing.</span>
<span class="Comment">     *</span>
<span class="Comment">     * The interceptors are service factories that are registered with the $httpProvider by</span>
<span class="Comment">     * adding them to the `$httpProvider.responseInterceptors` array. The factory is called and</span>
<span class="Comment">     * injected with dependencies (if specified) and returns the interceptor  — a function that</span>
<span class="Comment">     * takes a {@link ng.$q promise} and returns the original or a new promise.</span>
<span class="Comment">     *</span>
<span class="Comment">     * &lt;pre&gt;</span>
<span class="Comment">     *   // register the interceptor as a service</span>
<span class="Comment">     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {</span>
<span class="Comment">     *     return function(promise) {</span>
<span class="Comment">     *       return promise.then(function(response) {</span>
<span class="Comment">     *         // do something on success</span>
<span class="Comment">     *         return response;</span>
<span class="Comment">     *       }, function(response) {</span>
<span class="Comment">     *         // do something on error</span>
<span class="Comment">     *         if (canRecover(response)) {</span>
<span class="Comment">     *           return responseOrNewPromise</span>
<span class="Comment">     *         }</span>
<span class="Comment">     *         return $q.reject(response);</span>
<span class="Comment">     *       });</span>
<span class="Comment">     *     }</span>
<span class="Comment">     *   });</span>
<span class="Comment">     *</span>
<span class="Comment">     *   $httpProvider.responseInterceptors.push('myHttpInterceptor');</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     *   // register the interceptor via an anonymous factory</span>
<span class="Comment">     *   $httpProvider.responseInterceptors.push(function($q, dependency1, dependency2) {</span>
<span class="Comment">     *     return function(promise) {</span>
<span class="Comment">     *       // same as above</span>
<span class="Comment">     *     }</span>
<span class="Comment">     *   });</span>
<span class="Comment">     * &lt;/pre&gt;</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     * # Security Considerations</span>
<span class="Comment">     *</span>
<span class="Comment">     * When designing web applications, consider security threats from:</span>
<span class="Comment">     *</span>
<span class="Comment">     * - {@link <a href="http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx">http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx</a></span>
<span class="Comment">     *   JSON vulnerability}</span>
<span class="Comment">     * - {@link <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">http://en.wikipedia.org/wiki/Cross-site_request_forgery</a> XSRF}</span>
<span class="Comment">     *</span>
<span class="Comment">     * Both server and the client must cooperate in order to eliminate these threats. Angular comes</span>
<span class="Comment">     * pre-configured with strategies that address these issues, but for this to work backend server</span>
<span class="Comment">     * cooperation is required.</span>
<span class="Comment">     *</span>
<span class="Comment">     * ## JSON Vulnerability Protection</span>
<span class="Comment">     *</span>
<span class="Comment">     * A {@link <a href="http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx">http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx</a></span>
<span class="Comment">     * JSON vulnerability} allows third party website to turn your JSON resource URL into</span>
<span class="Comment">     * {@link <a href="http://en.wikipedia.org/wiki/JSONP">http://en.wikipedia.org/wiki/JSONP</a> JSONP} request under some conditions. To</span>
<span class="Comment">     * counter this your server can prefix all JSON requests with following string `&quot;)]}',\n&quot;`.</span>
<span class="Comment">     * Angular will automatically strip the prefix before processing it as JSON.</span>
<span class="Comment">     *</span>
<span class="Comment">     * For example if your server needs to return:</span>
<span class="Comment">     * &lt;pre&gt;</span>
<span class="Comment">     * ['one','two']</span>
<span class="Comment">     * &lt;/pre&gt;</span>
<span class="Comment">     *</span>
<span class="Comment">     * which is vulnerable to attack, your server can return:</span>
<span class="Comment">     * &lt;pre&gt;</span>
<span class="Comment">     * )]}',</span>
<span class="Comment">     * ['one','two']</span>
<span class="Comment">     * &lt;/pre&gt;</span>
<span class="Comment">     *</span>
<span class="Comment">     * Angular will strip the prefix, before processing the JSON.</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     * ## Cross Site Request Forgery (XSRF) Protection</span>
<span class="Comment">     *</span>
<span class="Comment">     * {@link <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">http://en.wikipedia.org/wiki/Cross-site_request_forgery</a> XSRF} is a technique by which</span>
<span class="Comment">     * an unauthorized site can gain your user's private data. Angular provides a mechanism</span>
<span class="Comment">     * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie</span>
<span class="Comment">     * (by default, `XSRF-TOKEN`) and sets it as an HTTP header (`X-XSRF-TOKEN`). Since only</span>
<span class="Comment">     * JavaScript that runs on your domain could read the cookie, your server can be assured that</span>
<span class="Comment">     * the XHR came from JavaScript running on your domain. The header will not be set for</span>
<span class="Comment">     * cross-domain requests.</span>
<span class="Comment">     *</span>
<span class="Comment">     * To take advantage of this, your server needs to set a token in a JavaScript readable session</span>
<span class="Comment">     * cookie called `XSRF-TOKEN` on the first HTTP GET request. On subsequent XHR requests the</span>
<span class="Comment">     * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure</span>
<span class="Comment">     * that only JavaScript running on your domain could have sent the request. The token must be</span>
<span class="Comment">     * unique for each user and must be verifiable by the server (to prevent the JavaScript from</span>
<span class="Comment">     * making up its own tokens). We recommend that the token is a digest of your site's</span>
<span class="Comment">     * authentication cookie with a {@link <a href="https://en.wikipedia.org/wiki/Salt_(cryptography)">https://en.wikipedia.org/wiki/Salt_(cryptography)</a> salt}</span>
<span class="Comment">     * for added security.</span>
<span class="Comment">     *</span>
<span class="Comment">     * The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName</span>
<span class="Comment">     * properties of either $httpProvider.defaults, or the per-request config object.</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {object} config Object describing the request to be made and how it should be</span>
<span class="Comment">     *    processed. The object has following properties:</span>
<span class="Comment">     *</span>
<span class="Comment">     *    - **method** – `{string}` – HTTP method (e.g. 'GET', 'POST', etc)</span>
<span class="Comment">     *    - **url** – `{string}` – Absolute or relative URL of the resource that is being requested.</span>
<span class="Comment">     *    - **params** – `{Object.&lt;string|Object&gt;}` – Map of strings or objects which will be turned</span>
<span class="Comment">     *      to `?key1=value1&amp;key2=value2` after the url. If the value is not a string, it will be</span>
<span class="Comment">     *      JSONified.</span>
<span class="Comment">     *    - **data** – `{string|Object}` – Data to be sent as the request message data.</span>
<span class="Comment">     *    - **headers** – `{Object}` – Map of strings or functions which return strings representing</span>
<span class="Comment">     *      HTTP headers to send to the server. If the return value of a function is null, the</span>
<span class="Comment">     *      header will not be sent.</span>
<span class="Comment">     *    - **xsrfHeaderName** – `{string}` – Name of HTTP header to populate with the XSRF token.</span>
<span class="Comment">     *    - **xsrfCookieName** – `{string}` – Name of cookie containing the XSRF token.</span>
<span class="Comment">     *    - **transformRequest** –</span>
<span class="Comment">     *      `{function(data, headersGetter)|Array.&lt;function(data, headersGetter)&gt;}` –</span>
<span class="Comment">     *      transform function or an array of such functions. The transform function takes the http</span>
<span class="Comment">     *      request body and headers and returns its transformed (typically serialized) version.</span>
<span class="Comment">     *    - **transformResponse** –</span>
<span class="Comment">     *      `{function(data, headersGetter)|Array.&lt;function(data, headersGetter)&gt;}` –</span>
<span class="Comment">     *      transform function or an array of such functions. The transform function takes the http</span>
<span class="Comment">     *      response body and headers and returns its transformed (typically deserialized) version.</span>
<span class="Comment">     *    - **cache** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the</span>
<span class="Comment">     *      GET request, otherwise if a cache instance built with</span>
<span class="Comment">     *      {@link ng.$cacheFactory $cacheFactory}, this cache will be used for</span>
<span class="Comment">     *      caching.</span>
<span class="Comment">     *    - **timeout** – `{number|Promise}` – timeout in milliseconds, or {@link ng.$q promise}</span>
<span class="Comment">     *      that should abort the request when resolved.</span>
<span class="Comment">     *    - **withCredentials** - `{boolean}` - whether to to set the `withCredentials` flag on the</span>
<span class="Comment">     *      XHR object. See {@link <a href="https://developer.mozilla.org/en/http_access_control#section_5">https://developer.mozilla.org/en/http_access_control#section_5</a></span>
<span class="Comment">     *      requests with credentials} for more information.</span>
<span class="Comment">     *    - **responseType** - `{string}` - see {@link</span>
<span class="Comment">     *      <a href="https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType">https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType</a> requestType}.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @returns {HttpPromise} Returns a {@link ng.$q promise} object with the</span>
<span class="Comment">     *   standard `then` method and two http specific methods: `success` and `error`. The `then`</span>
<span class="Comment">     *   method takes two arguments a success and an error callback which will be called with a</span>
<span class="Comment">     *   response object. The `success` and `error` methods take a single argument - a function that</span>
<span class="Comment">     *   will be called when the request succeeds or fails respectively. The arguments passed into</span>
<span class="Comment">     *   these functions are destructured representation of the response object passed into the</span>
<span class="Comment">     *   `then` method. The response object has these properties:</span>
<span class="Comment">     *</span>
<span class="Comment">     *   - **data** – `{string|Object}` – The response body transformed with the transform</span>
<span class="Comment">     *     functions.</span>
<span class="Comment">     *   - **status** – `{number}` – HTTP status code of the response.</span>
<span class="Comment">     *   - **headers** – `{function([headerName])}` – Header getter function.</span>
<span class="Comment">     *   - **config** – `{Object}` – The configuration object that was used to generate the request.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @property {Array.&lt;Object&gt;} pendingRequests Array of config objects for currently pending</span>
<span class="Comment">     *   requests. This is primarily meant to be used for debugging purposes.</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     * @example</span>
<span class="Comment">&lt;example&gt;</span>
<span class="Comment">&lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">  &lt;div ng-controller=&quot;FetchCtrl&quot;&gt;</span>
<span class="Comment">    &lt;select ng-model=&quot;method&quot;&gt;</span>
<span class="Comment">      &lt;option&gt;GET&lt;/option&gt;</span>
<span class="Comment">      &lt;option&gt;JSONP&lt;/option&gt;</span>
<span class="Comment">    &lt;/select&gt;</span>
<span class="Comment">    &lt;input type=&quot;text&quot; ng-model=&quot;url&quot; size=&quot;80&quot;/&gt;</span>
<span class="Comment">    &lt;button ng-click=&quot;fetch()&quot;&gt;fetch&lt;/button&gt;&lt;br&gt;</span>
<span class="Comment">    &lt;button ng-click=&quot;updateModel('GET', 'http-hello.html')&quot;&gt;Sample GET&lt;/button&gt;</span>
<span class="Comment">    &lt;button</span>
<span class="Comment">      ng-click=&quot;updateModel('JSONP',</span>
<span class="Comment">                    '<a href="http://angularjs.org/greet.php?callback=JSON_CALLBACK&amp;name=Super%20Hero">http://angularjs.org/greet.php?callback=JSON_CALLBACK&amp;name=Super%20Hero</a>')&quot;&gt;</span>
<span class="Comment">      Sample JSONP</span>
<span class="Comment">    &lt;/button&gt;</span>
<span class="Comment">    &lt;button</span>
<span class="Comment">      ng-click=&quot;updateModel('JSONP', '<a href="http://angularjs.org/doesntexist&amp;callback=JSON_CALLBACK">http://angularjs.org/doesntexist&amp;callback=JSON_CALLBACK</a>')&quot;&gt;</span>
<span class="Comment">        Invalid JSONP</span>
<span class="Comment">      &lt;/button&gt;</span>
<span class="Comment">    &lt;pre&gt;http status code: {{status}}&lt;/pre&gt;</span>
<span class="Comment">    &lt;pre&gt;http response data: {{data}}&lt;/pre&gt;</span>
<span class="Comment">  &lt;/div&gt;</span>
<span class="Comment">&lt;/file&gt;</span>
<span class="Comment">&lt;file name=&quot;script.js&quot;&gt;</span>
<span class="Comment">  function FetchCtrl($scope, $http, $templateCache) {</span>
<span class="Comment">    $scope.method = 'GET';</span>
<span class="Comment">    $scope.url = 'http-hello.html';</span>

<span class="Comment">    $scope.fetch = function() {</span>
<span class="Comment">      $scope.code = null;</span>
<span class="Comment">      $scope.response = null;</span>

<span class="Comment">      $http({method: $scope.method, url: $scope.url, cache: $templateCache}).</span>
<span class="Comment">        success(function(data, status) {</span>
<span class="Comment">          $scope.status = status;</span>
<span class="Comment">          $scope.data = data;</span>
<span class="Comment">        }).</span>
<span class="Comment">        error(function(data, status) {</span>
<span class="Comment">          $scope.data = data || &quot;Request failed&quot;;</span>
<span class="Comment">          $scope.status = status;</span>
<span class="Comment">      });</span>
<span class="Comment">    };</span>

<span class="Comment">    $scope.updateModel = function(method, url) {</span>
<span class="Comment">      $scope.method = method;</span>
<span class="Comment">      $scope.url = url;</span>
<span class="Comment">    };</span>
<span class="Comment">  }</span>
<span class="Comment">&lt;/file&gt;</span>
<span class="Comment">&lt;file name=&quot;http-hello.html&quot;&gt;</span>
<span class="Comment">  Hello, $http!</span>
<span class="Comment">&lt;/file&gt;</span>
<span class="Comment">&lt;file name=&quot;scenario.js&quot;&gt;</span>
<span class="Comment">  it('should make an xhr GET request', function() {</span>
<span class="Comment">    element(':button:contains(&quot;Sample GET&quot;)').click();</span>
<span class="Comment">    element(':button:contains(&quot;fetch&quot;)').click();</span>
<span class="Comment">    expect(binding('status')).toBe('200');</span>
<span class="Comment">    expect(binding('data')).toMatch(/Hello, \$http!/);</span>
<span class="Comment">  });</span>

<span class="Comment">  it('should make a JSONP request to angularjs.org', function() {</span>
<span class="Comment">    element(':button:contains(&quot;Sample JSONP&quot;)').click();</span>
<span class="Comment">    element(':button:contains(&quot;fetch&quot;)').click();</span>
<span class="Comment">    expect(binding('status')).toBe('200');</span>
<span class="Comment">    expect(binding('data')).toMatch(/Super Hero!/);</span>
<span class="Comment">  });</span>

<span class="Comment">  it('should make JSONP request to invalid URL and invoke the error handler',</span>
<span class="Comment">      function() {</span>
<span class="Comment">    element(':button:contains(&quot;Invalid JSONP&quot;)').click();</span>
<span class="Comment">    element(':button:contains(&quot;fetch&quot;)').click();</span>
<span class="Comment">    expect(binding('status')).toBe('0');</span>
<span class="Comment">    expect(binding('data')).toBe('Request failed');</span>
<span class="Comment">  });</span>
<span class="Comment">&lt;/file&gt;</span>
<span class="Comment">&lt;/example&gt;</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> $http(requestConfig) <span class="Identifier">{</span>
      <span class="Identifier">var</span> config = <span class="Identifier">{</span>
        transformRequest: defaults.transformRequest,
        transformResponse: defaults.transformResponse
      <span class="Identifier">}</span>;
      <span class="Identifier">var</span> headers = mergeHeaders(requestConfig);

      extend(config, requestConfig);
      config.headers = headers;
      config.method = uppercase(config.method);

      <span class="Identifier">var</span> xsrfValue = urlIsSameOrigin(config.url)
          ? $browser.cookies()<span class="Identifier">[</span>config.xsrfCookieName || defaults.xsrfCookieName<span class="Identifier">]</span>
          : <span class="Statement">undefined</span>;
      <span class="Statement">if</span> (xsrfValue) <span class="Identifier">{</span>
        headers<span class="Identifier">[</span>(config.xsrfHeaderName || defaults.xsrfHeaderName)<span class="Identifier">]</span> = xsrfValue;
      <span class="Identifier">}</span>


      <span class="Identifier">var</span> serverRequest = <span class="Identifier">function</span>(config) <span class="Identifier">{</span>
        headers = config.headers;
        <span class="Identifier">var</span> reqData = transformData(config.data, headersGetter(headers), config.transformRequest);

        <span class="Comment">// strip content-type if data is undefined</span>
        <span class="Statement">if</span> (isUndefined(config.data)) <span class="Identifier">{</span>
          forEach(headers, <span class="Identifier">function</span>(value, header) <span class="Identifier">{</span>
            <span class="Statement">if</span> (lowercase(header) === <span class="Constant">'content-type'</span>) <span class="Identifier">{</span>
                <span class="Statement">delete</span> headers<span class="Identifier">[</span>header<span class="Identifier">]</span>;
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>

        <span class="Statement">if</span> (isUndefined(config.withCredentials) &amp;&amp; !isUndefined(defaults.withCredentials)) <span class="Identifier">{</span>
          config.withCredentials = defaults.withCredentials;
        <span class="Identifier">}</span>

        <span class="Comment">// send request</span>
        <span class="Statement">return</span> sendReq(config, reqData, headers).then(transformResponse, transformResponse);
      <span class="Identifier">}</span>;

      <span class="Identifier">var</span> chain = <span class="Identifier">[</span>serverRequest, <span class="Statement">undefined</span><span class="Identifier">]</span>;
      <span class="Identifier">var</span> promise = $q.when(config);

      <span class="Comment">// apply interceptors</span>
      forEach(reversedInterceptors, <span class="Identifier">function</span>(interceptor) <span class="Identifier">{</span>
        <span class="Statement">if</span> (interceptor.request || interceptor.requestError) <span class="Identifier">{</span>
          chain.unshift(interceptor.request, interceptor.requestError);
        <span class="Identifier">}</span>
        <span class="Statement">if</span> (interceptor.response || interceptor.responseError) <span class="Identifier">{</span>
          chain.push(interceptor.response, interceptor.responseError);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>);

      <span class="Statement">while</span>(chain.length) <span class="Identifier">{</span>
        <span class="Identifier">var</span> thenFn = chain.shift();
        <span class="Identifier">var</span> rejectFn = chain.shift();

        promise = promise.then(thenFn, rejectFn);
      <span class="Identifier">}</span>

      promise.success = <span class="Identifier">function</span>(fn) <span class="Identifier">{</span>
        promise.then(<span class="Identifier">function</span>(response) <span class="Identifier">{</span>
          fn(response.data, response.<span class="Statement">status</span>, response.headers, config);
        <span class="Identifier">}</span>);
        <span class="Statement">return</span> promise;
      <span class="Identifier">}</span>;

      promise.error = <span class="Identifier">function</span>(fn) <span class="Identifier">{</span>
        promise.then(<span class="Statement">null</span>, <span class="Identifier">function</span>(response) <span class="Identifier">{</span>
          fn(response.data, response.<span class="Statement">status</span>, response.headers, config);
        <span class="Identifier">}</span>);
        <span class="Statement">return</span> promise;
      <span class="Identifier">}</span>;

      <span class="Statement">return</span> promise;

      <span class="Identifier">function</span> transformResponse(response) <span class="Identifier">{</span>
        <span class="Comment">// make a copy since the response must be cacheable</span>
        <span class="Identifier">var</span> resp = extend(<span class="Identifier">{}</span>, response, <span class="Identifier">{</span>
          data: transformData(response.data, response.headers, config.transformResponse)
        <span class="Identifier">}</span>);
        <span class="Statement">return</span> (isSuccess(response.<span class="Statement">status</span>))
          ? resp
          : $q.reject(resp);
      <span class="Identifier">}</span>

      <span class="Identifier">function</span> mergeHeaders(config) <span class="Identifier">{</span>
        <span class="Identifier">var</span> defHeaders = defaults.headers,
            reqHeaders = extend(<span class="Identifier">{}</span>, config.headers),
            defHeaderName, lowercaseDefHeaderName, reqHeaderName;

        defHeaders = extend(<span class="Identifier">{}</span>, defHeaders.common, defHeaders<span class="Identifier">[</span>lowercase(config.method)<span class="Identifier">]</span>);

        <span class="Comment">// execute if header value is function</span>
        execHeaders(defHeaders);
        execHeaders(reqHeaders);

        <span class="Comment">// using for-in instead of forEach to avoid unecessary iteration after header has been found</span>
        defaultHeadersIteration:
        <span class="Statement">for</span> (defHeaderName <span class="Statement">in</span> defHeaders) <span class="Identifier">{</span>
          lowercaseDefHeaderName = lowercase(defHeaderName);

          <span class="Statement">for</span> (reqHeaderName <span class="Statement">in</span> reqHeaders) <span class="Identifier">{</span>
            <span class="Statement">if</span> (lowercase(reqHeaderName) === lowercaseDefHeaderName) <span class="Identifier">{</span>
              <span class="Statement">continue</span> defaultHeadersIteration;
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>

          reqHeaders<span class="Identifier">[</span>defHeaderName<span class="Identifier">]</span> = defHeaders<span class="Identifier">[</span>defHeaderName<span class="Identifier">]</span>;
        <span class="Identifier">}</span>

        <span class="Statement">return</span> reqHeaders;

        <span class="Identifier">function</span> execHeaders(headers) <span class="Identifier">{</span>
          <span class="Identifier">var</span> headerContent;

          forEach(headers, <span class="Identifier">function</span>(headerFn, header) <span class="Identifier">{</span>
            <span class="Statement">if</span> (isFunction(headerFn)) <span class="Identifier">{</span>
              headerContent = headerFn();
              <span class="Statement">if</span> (headerContent != <span class="Statement">null</span>) <span class="Identifier">{</span>
                headers<span class="Identifier">[</span>header<span class="Identifier">]</span> = headerContent;
              <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
                <span class="Statement">delete</span> headers<span class="Identifier">[</span>header<span class="Identifier">]</span>;
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    $http.pendingRequests = <span class="Identifier">[]</span>;

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$http#get</span>
<span class="Comment">     * @methodOf ng.$http</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shortcut method to perform `GET` request.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} url Relative or absolute URL specifying the destination of the request</span>
<span class="Comment">     * @param {Object=} config Optional configuration object</span>
<span class="Comment">     * @returns {HttpPromise} Future object</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$http#delete</span>
<span class="Comment">     * @methodOf ng.$http</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shortcut method to perform `DELETE` request.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} url Relative or absolute URL specifying the destination of the request</span>
<span class="Comment">     * @param {Object=} config Optional configuration object</span>
<span class="Comment">     * @returns {HttpPromise} Future object</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$http#head</span>
<span class="Comment">     * @methodOf ng.$http</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shortcut method to perform `HEAD` request.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} url Relative or absolute URL specifying the destination of the request</span>
<span class="Comment">     * @param {Object=} config Optional configuration object</span>
<span class="Comment">     * @returns {HttpPromise} Future object</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$http#jsonp</span>
<span class="Comment">     * @methodOf ng.$http</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shortcut method to perform `JSONP` request.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} url Relative or absolute URL specifying the destination of the request.</span>
<span class="Comment">     *                     Should contain `JSON_CALLBACK` string.</span>
<span class="Comment">     * @param {Object=} config Optional configuration object</span>
<span class="Comment">     * @returns {HttpPromise} Future object</span>
<span class="Comment">     */</span>
    createShortMethods(<span class="Constant">'get'</span>, <span class="Constant">'delete'</span>, <span class="Constant">'head'</span>, <span class="Constant">'jsonp'</span>);

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$http#post</span>
<span class="Comment">     * @methodOf ng.$http</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shortcut method to perform `POST` request.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} url Relative or absolute URL specifying the destination of the request</span>
<span class="Comment">     * @param {*} data Request content</span>
<span class="Comment">     * @param {Object=} config Optional configuration object</span>
<span class="Comment">     * @returns {HttpPromise} Future object</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$http#put</span>
<span class="Comment">     * @methodOf ng.$http</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shortcut method to perform `PUT` request.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} url Relative or absolute URL specifying the destination of the request</span>
<span class="Comment">     * @param {*} data Request content</span>
<span class="Comment">     * @param {Object=} config Optional configuration object</span>
<span class="Comment">     * @returns {HttpPromise} Future object</span>
<span class="Comment">     */</span>
    createShortMethodsWithData(<span class="Constant">'post'</span>, <span class="Constant">'put'</span>);

        <span class="Comment">/**</span>
<span class="Comment">         * @ngdoc property</span>
<span class="Comment">         * @name ng.$http#defaults</span>
<span class="Comment">         * @propertyOf ng.$http</span>
<span class="Comment">         *</span>
<span class="Comment">         * @description</span>
<span class="Comment">         * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of</span>
<span class="Comment">         * default headers, withCredentials as well as request and response transformations.</span>
<span class="Comment">         *</span>
<span class="Comment">         * See &quot;Setting HTTP Headers&quot; and &quot;Transforming Requests and Responses&quot; sections above.</span>
<span class="Comment">         */</span>
    $http.defaults = defaults;


    <span class="Statement">return</span> $http;


    <span class="Identifier">function</span> createShortMethods(names) <span class="Identifier">{</span>
      forEach(<span class="Identifier">arguments</span>, <span class="Identifier">function</span>(name) <span class="Identifier">{</span>
        $http<span class="Identifier">[</span>name<span class="Identifier">]</span> = <span class="Identifier">function</span>(url, config) <span class="Identifier">{</span>
          <span class="Statement">return</span> $http(extend(config || <span class="Identifier">{}</span>, <span class="Identifier">{</span>
            method: name,
            url: url
          <span class="Identifier">}</span>));
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>


    <span class="Identifier">function</span> createShortMethodsWithData(name) <span class="Identifier">{</span>
      forEach(<span class="Identifier">arguments</span>, <span class="Identifier">function</span>(name) <span class="Identifier">{</span>
        $http<span class="Identifier">[</span>name<span class="Identifier">]</span> = <span class="Identifier">function</span>(url, data, config) <span class="Identifier">{</span>
          <span class="Statement">return</span> $http(extend(config || <span class="Identifier">{}</span>, <span class="Identifier">{</span>
            method: name,
            url: url,
            data: data
          <span class="Identifier">}</span>));
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>


    <span class="Comment">/**</span>
<span class="Comment">     * Makes the request.</span>
<span class="Comment">     *</span>
<span class="Comment">     * !!! ACCESSES CLOSURE VARS:</span>
<span class="Comment">     * $httpBackend, defaults, $log, $rootScope, defaultCache, $http.pendingRequests</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> sendReq(config, reqData, reqHeaders) <span class="Identifier">{</span>
      <span class="Identifier">var</span> deferred = $q.defer(),
          promise = deferred.promise,
          cache,
          cachedResp,
          url = buildUrl(config.url, config.params);

      $http.pendingRequests.push(config);
      promise.then(removePendingReq, removePendingReq);


      <span class="Statement">if</span> ((config.cache || defaults.cache) &amp;&amp; config.cache !== <span class="Constant">false</span> &amp;&amp; config.method == <span class="Constant">'GET'</span>) <span class="Identifier">{</span>
        cache = isObject(config.cache) ? config.cache
              : isObject(defaults.cache) ? defaults.cache
              : defaultCache;
      <span class="Identifier">}</span>

      <span class="Statement">if</span> (cache) <span class="Identifier">{</span>
        cachedResp = cache.get(url);
        <span class="Statement">if</span> (isDefined(cachedResp)) <span class="Identifier">{</span>
          <span class="Statement">if</span> (cachedResp.then) <span class="Identifier">{</span>
            <span class="Comment">// cached request has already been sent, but there is no response yet</span>
            cachedResp.then(removePendingReq, removePendingReq);
            <span class="Statement">return</span> cachedResp;
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            <span class="Comment">// serving from cache</span>
            <span class="Statement">if</span> (isArray(cachedResp)) <span class="Identifier">{</span>
              resolvePromise(cachedResp<span class="Identifier">[</span>1<span class="Identifier">]</span>, cachedResp<span class="Identifier">[</span>0<span class="Identifier">]</span>, copy(cachedResp<span class="Identifier">[</span>2<span class="Identifier">]</span>));
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
              resolvePromise(cachedResp, 200, <span class="Identifier">{}</span>);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          <span class="Comment">// put the promise for the non-transformed response into cache as a placeholder</span>
          cache.put(url, promise);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>

      <span class="Comment">// if we won't have the response in cache, send the request to the backend</span>
      <span class="Statement">if</span> (isUndefined(cachedResp)) <span class="Identifier">{</span>
        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,
            config.withCredentials, config.responseType);
      <span class="Identifier">}</span>

      <span class="Statement">return</span> promise;


      <span class="Comment">/**</span>
<span class="Comment">       * Callback registered to $httpBackend():</span>
<span class="Comment">       *  - caches the response if desired</span>
<span class="Comment">       *  - resolves the raw $http promise</span>
<span class="Comment">       *  - calls $apply</span>
<span class="Comment">       */</span>
      <span class="Identifier">function</span> done(<span class="Statement">status</span>, response, headersString) <span class="Identifier">{</span>
        <span class="Statement">if</span> (cache) <span class="Identifier">{</span>
          <span class="Statement">if</span> (isSuccess(<span class="Statement">status</span>)) <span class="Identifier">{</span>
            cache.put(url, <span class="Identifier">[</span><span class="Statement">status</span>, response, parseHeaders(headersString)<span class="Identifier">]</span>);
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            <span class="Comment">// remove promise from the cache</span>
            cache.remove(url);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>

        resolvePromise(response, <span class="Statement">status</span>, headersString);
        <span class="Statement">if</span> (!$rootScope.$$phase) $rootScope.$apply();
      <span class="Identifier">}</span>


      <span class="Comment">/**</span>
<span class="Comment">       * Resolves the raw $http promise.</span>
<span class="Comment">       */</span>
      <span class="Identifier">function</span> resolvePromise(response, <span class="Statement">status</span>, headers) <span class="Identifier">{</span>
        <span class="Comment">// normalize internal statuses to 0</span>
        <span class="Statement">status</span> = Math.max(<span class="Statement">status</span>, 0);

        (isSuccess(<span class="Statement">status</span>) ? deferred.resolve : deferred.reject)(<span class="Identifier">{</span>
          data: response,
          <span class="Statement">status</span>: <span class="Statement">status</span>,
          headers: headersGetter(headers),
          config: config
        <span class="Identifier">}</span>);
      <span class="Identifier">}</span>


      <span class="Identifier">function</span> removePendingReq() <span class="Identifier">{</span>
        <span class="Identifier">var</span> idx = indexOf($http.pendingRequests, config);
        <span class="Statement">if</span> (idx !== -1) $http.pendingRequests.splice(idx, 1);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>


    <span class="Identifier">function</span> buildUrl(url, params) <span class="Identifier">{</span>
          <span class="Statement">if</span> (!params) <span class="Statement">return</span> url;
          <span class="Identifier">var</span> parts = <span class="Identifier">[]</span>;
          forEachSorted(params, <span class="Identifier">function</span>(value, key) <span class="Identifier">{</span>
            <span class="Statement">if</span> (value === <span class="Statement">null</span> || isUndefined(value)) <span class="Statement">return</span>;
            <span class="Statement">if</span> (!isArray(value)) value = <span class="Identifier">[</span>value<span class="Identifier">]</span>;

            forEach(value, <span class="Identifier">function</span>(v) <span class="Identifier">{</span>
              <span class="Statement">if</span> (isObject(v)) <span class="Identifier">{</span>
                v = toJson(v);
              <span class="Identifier">}</span>
              parts.push(encodeUriQuery(key) + <span class="Constant">'='</span> +
                         encodeUriQuery(v));
            <span class="Identifier">}</span>);
          <span class="Identifier">}</span>);
          <span class="Statement">return</span> url + ((url.indexOf(<span class="Constant">'?'</span>) == -1) ? <span class="Constant">'?'</span> : <span class="Constant">'&amp;'</span>) + parts.join(<span class="Constant">'&amp;'</span>);
        <span class="Identifier">}</span>


  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Identifier">var</span> XHR = <span class="Statement">window</span>.XMLHttpRequest || <span class="Identifier">function</span>() <span class="Identifier">{</span>
  <span class="Comment">/* global ActiveXObject */</span>
  <span class="Statement">try</span> <span class="Identifier">{</span> <span class="Statement">return</span> <span class="Statement">new</span> ActiveXObject(<span class="Constant">&quot;Msxml2.XMLHTTP.6.0&quot;</span>); <span class="Identifier">}</span> <span class="Statement">catch</span> (e1) <span class="Identifier">{}</span>
  <span class="Statement">try</span> <span class="Identifier">{</span> <span class="Statement">return</span> <span class="Statement">new</span> ActiveXObject(<span class="Constant">&quot;Msxml2.XMLHTTP.3.0&quot;</span>); <span class="Identifier">}</span> <span class="Statement">catch</span> (e2) <span class="Identifier">{}</span>
  <span class="Statement">try</span> <span class="Identifier">{</span> <span class="Statement">return</span> <span class="Statement">new</span> ActiveXObject(<span class="Constant">&quot;Msxml2.XMLHTTP&quot;</span>); <span class="Identifier">}</span> <span class="Statement">catch</span> (e3) <span class="Identifier">{}</span>
  <span class="Statement">throw</span> minErr(<span class="Constant">'$httpBackend'</span>)(<span class="Constant">'noxhr'</span>, <span class="Constant">&quot;This browser does not support XMLHttpRequest.&quot;</span>);
<span class="Identifier">}</span>;


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$httpBackend</span>
<span class="Comment"> * @requires $browser</span>
<span class="Comment"> * @requires $window</span>
<span class="Comment"> * @requires $document</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * HTTP backend used by the {@link ng.$http service} that delegates to</span>
<span class="Comment"> * XMLHttpRequest object or JSONP and deals with browser incompatibilities.</span>
<span class="Comment"> *</span>
<span class="Comment"> * You should never need to use this service directly, instead use the higher-level abstractions:</span>
<span class="Comment"> * {@link ng.$http $http} or {@link ngResource.$resource $resource}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * During testing this implementation is swapped with {@link ngMock.$httpBackend mock</span>
<span class="Comment"> * $httpBackend} which can be trained with responses.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $HttpBackendProvider() <span class="Identifier">{</span>
  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$browser'</span>, <span class="Constant">'$window'</span>, <span class="Constant">'$document'</span>, <span class="Identifier">function</span>($browser, $<span class="Statement">window</span>, $<span class="Statement">document</span>) <span class="Identifier">{</span>
    <span class="Statement">return</span> createHttpBackend($browser, XHR, $browser.defer, $<span class="Statement">window</span>.angular.callbacks, $<span class="Statement">document</span><span class="Identifier">[</span>0<span class="Identifier">]</span>);
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Identifier">function</span> createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument) <span class="Identifier">{</span>
  <span class="Identifier">var</span> ABORTED = -1;

  <span class="Comment">// </span><span class="Todo">TODO</span><span class="Comment">(vojta): fix the signature</span>
  <span class="Statement">return</span> <span class="Identifier">function</span>(method, url, post, callback, headers, timeout, withCredentials, responseType) <span class="Identifier">{</span>
    <span class="Identifier">var</span> <span class="Statement">status</span>;
    $browser.$$incOutstandingRequestCount();
    url = url || $browser.url();

    <span class="Statement">if</span> (lowercase(method) == <span class="Constant">'jsonp'</span>) <span class="Identifier">{</span>
      <span class="Identifier">var</span> callbackId = <span class="Constant">'_'</span> + (callbacks.counter++).toString(36);
      callbacks<span class="Identifier">[</span>callbackId<span class="Identifier">]</span> = <span class="Identifier">function</span>(data) <span class="Identifier">{</span>
        callbacks<span class="Identifier">[</span>callbackId<span class="Identifier">]</span>.data = data;
      <span class="Identifier">}</span>;

      <span class="Identifier">var</span> jsonpDone = jsonpReq(url.replace(<span class="Constant">'JSON_CALLBACK'</span>, <span class="Constant">'angular.callbacks.'</span> + callbackId),
          <span class="Identifier">function</span>() <span class="Identifier">{</span>
        <span class="Statement">if</span> (callbacks<span class="Identifier">[</span>callbackId<span class="Identifier">]</span>.data) <span class="Identifier">{</span>
          completeRequest(callback, 200, callbacks<span class="Identifier">[</span>callbackId<span class="Identifier">]</span>.data);
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          completeRequest(callback, <span class="Statement">status</span> || -2);
        <span class="Identifier">}</span>
        <span class="Statement">delete</span> callbacks<span class="Identifier">[</span>callbackId<span class="Identifier">]</span>;
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Identifier">var</span> xhr = <span class="Statement">new</span> XHR();
      xhr.open(method, url, <span class="Constant">true</span>);
      forEach(headers, <span class="Identifier">function</span>(value, key) <span class="Identifier">{</span>
        <span class="Statement">if</span> (isDefined(value)) <span class="Identifier">{</span>
            xhr.setRequestHeader(key, value);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>);

      <span class="Comment">// In IE6 and 7, this might be called synchronously when xhr.send below is called and the</span>
      <span class="Comment">// response is in the cache. the promise api will ensure that to the app code the api is</span>
      <span class="Comment">// always async</span>
      xhr.onreadystatechange = <span class="Identifier">function</span>() <span class="Identifier">{</span>
        <span class="Statement">if</span> (xhr.readyState == 4) <span class="Identifier">{</span>
          <span class="Identifier">var</span> responseHeaders = <span class="Statement">null</span>,
              response = <span class="Statement">null</span>;

          <span class="Statement">if</span>(<span class="Statement">status</span> !== ABORTED) <span class="Identifier">{</span>
            responseHeaders = xhr.getAllResponseHeaders();
            response = xhr.responseType ? xhr.response : xhr.responseText;
          <span class="Identifier">}</span>

          <span class="Comment">// responseText is the old-school way of retrieving response (supported by IE8 &amp; 9)</span>
          <span class="Comment">// response/responseType properties were introduced in XHR Level2 spec (supported by IE10)</span>
          completeRequest(callback,
              <span class="Statement">status</span> || xhr.<span class="Statement">status</span>,
              response,
              responseHeaders);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>;

      <span class="Statement">if</span> (withCredentials) <span class="Identifier">{</span>
        xhr.withCredentials = <span class="Constant">true</span>;
      <span class="Identifier">}</span>

      <span class="Statement">if</span> (responseType) <span class="Identifier">{</span>
        xhr.responseType = responseType;
      <span class="Identifier">}</span>

      xhr.send(post || <span class="Statement">null</span>);
    <span class="Identifier">}</span>

    <span class="Statement">if</span> (timeout &gt; 0) <span class="Identifier">{</span>
      <span class="Identifier">var</span> timeoutId = $browserDefer(timeoutRequest, timeout);
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (timeout &amp;&amp; timeout.then) <span class="Identifier">{</span>
      timeout.then(timeoutRequest);
    <span class="Identifier">}</span>


    <span class="Identifier">function</span> timeoutRequest() <span class="Identifier">{</span>
      <span class="Statement">status</span> = ABORTED;
      jsonpDone &amp;&amp; jsonpDone();
      xhr &amp;&amp; xhr.abort();
    <span class="Identifier">}</span>

    <span class="Identifier">function</span> completeRequest(callback, <span class="Statement">status</span>, response, headersString) <span class="Identifier">{</span>
      <span class="Identifier">var</span> protocol = urlResolve(url).protocol;

      <span class="Comment">// cancel timeout and subsequent timeout promise resolution</span>
      timeoutId &amp;&amp; $browserDefer.cancel(timeoutId);
      jsonpDone = xhr = <span class="Statement">null</span>;

      <span class="Comment">// fix status code for file protocol (it's always 0)</span>
      <span class="Statement">status</span> = (protocol == <span class="Constant">'file'</span> &amp;&amp; <span class="Statement">status</span> === 0) ? (response ? 200 : 404) : <span class="Statement">status</span>;

      <span class="Comment">// normalize IE bug (<a href="http://bugs.jquery.com/ticket/1450)">http://bugs.jquery.com/ticket/1450)</a></span>
      <span class="Statement">status</span> = <span class="Statement">status</span> == 1223 ? 204 : <span class="Statement">status</span>;

      callback(<span class="Statement">status</span>, response, headersString);
      $browser.$$completeOutstandingRequest(noop);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Identifier">function</span> jsonpReq(url, done) <span class="Identifier">{</span>
    <span class="Comment">// we can't use jQuery/jqLite here because jQuery does crazy shit with script elements, e.g.:</span>
    <span class="Comment">// - fetches local scripts via XHR and evals them</span>
    <span class="Comment">// - adds and immediately removes script elements from the document</span>
    <span class="Identifier">var</span> script = rawDocument.createElement(<span class="Constant">'script'</span>),
        doneWrapper = <span class="Identifier">function</span>() <span class="Identifier">{</span>
          script.onreadystatechange = script.onload = script.onerror = <span class="Statement">null</span>;
          rawDocument.body.removeChild(script);
          <span class="Statement">if</span> (done) done();
        <span class="Identifier">}</span>;

    script.type = <span class="Constant">'text/javascript'</span>;
    script.src = url;

    <span class="Statement">if</span> (msie &amp;&amp; msie &lt;= 8) <span class="Identifier">{</span>
      script.onreadystatechange = <span class="Identifier">function</span>() <span class="Identifier">{</span>
        <span class="Statement">if</span> (<span class="Constant">/loaded|complete/</span>.test(script.readyState)) <span class="Identifier">{</span>
          doneWrapper();
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      script.onload = script.onerror = <span class="Identifier">function</span>() <span class="Identifier">{</span>
        doneWrapper();
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>

    rawDocument.body.appendChild(script);
    <span class="Statement">return</span> doneWrapper;
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Identifier">var</span> $interpolateMinErr = minErr(<span class="Constant">'$interpolate'</span>);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$interpolateProvider</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">&lt;doc:example module=&quot;customInterpolationApp&quot;&gt;</span>
<span class="Comment">&lt;doc:source&gt;</span>
<span class="Comment">&lt;script&gt;</span>
<span class="Comment">  var customInterpolationApp = angular.module('customInterpolationApp', []);</span>

<span class="Comment">  customInterpolationApp.config(function($interpolateProvider) {</span>
<span class="Comment">    $interpolateProvider.startSymbol('//');</span>
<span class="Comment">    $interpolateProvider.endSymbol('//');</span>
<span class="Comment">  });</span>


<span class="Comment">  customInterpolationApp.controller('DemoController', function DemoController() {</span>
<span class="Comment">      this.label = &quot;This binding is brought you by // interpolation symbols.&quot;;</span>
<span class="Comment">  });</span>
<span class="Comment">&lt;/script&gt;</span>
<span class="Comment">&lt;div ng-app=&quot;App&quot; ng-controller=&quot;DemoController as demo&quot;&gt;</span>
<span class="Comment">    //demo.label//</span>
<span class="Comment">&lt;/div&gt;</span>
<span class="Comment">&lt;/doc:source&gt;</span>
<span class="Comment">&lt;doc:scenario&gt;</span>
<span class="Comment"> it('should interpolate binding with custom symbols', function() {</span>
<span class="Comment">  expect(binding('demo.label')).toBe('This binding is brought you by // interpolation symbols.');</span>
<span class="Comment"> });</span>
<span class="Comment">&lt;/doc:scenario&gt;</span>
<span class="Comment">&lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $InterpolateProvider() <span class="Identifier">{</span>
  <span class="Identifier">var</span> startSymbol = <span class="Constant">'{{'</span>;
  <span class="Identifier">var</span> endSymbol = <span class="Constant">'}}'</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$interpolateProvider#startSymbol</span>
<span class="Comment">   * @methodOf ng.$interpolateProvider</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string=} value new value to set the starting symbol to.</span>
<span class="Comment">   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.startSymbol = <span class="Identifier">function</span>(value)<span class="Identifier">{</span>
    <span class="Statement">if</span> (value) <span class="Identifier">{</span>
      startSymbol = value;
      <span class="Statement">return</span> <span class="Identifier">this</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> startSymbol;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$interpolateProvider#endSymbol</span>
<span class="Comment">   * @methodOf ng.$interpolateProvider</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string=} value new value to set the ending symbol to.</span>
<span class="Comment">   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.endSymbol = <span class="Identifier">function</span>(value)<span class="Identifier">{</span>
    <span class="Statement">if</span> (value) <span class="Identifier">{</span>
      endSymbol = value;
      <span class="Statement">return</span> <span class="Identifier">this</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> endSymbol;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;


  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$parse'</span>, <span class="Constant">'$exceptionHandler'</span>, <span class="Constant">'$sce'</span>, <span class="Identifier">function</span>($parse, $exceptionHandler, $sce) <span class="Identifier">{</span>
    <span class="Identifier">var</span> startSymbolLength = startSymbol.length,
        endSymbolLength = endSymbol.length;

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc function</span>
<span class="Comment">     * @name ng.$interpolate</span>
<span class="Comment">     * @function</span>
<span class="Comment">     *</span>
<span class="Comment">     * @requires $parse</span>
<span class="Comment">     * @requires $sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     *</span>
<span class="Comment">     * Compiles a string with markup into an interpolation function. This service is used by the</span>
<span class="Comment">     * HTML {@link ng.$compile $compile} service for data binding. See</span>
<span class="Comment">     * {@link ng.$interpolateProvider $interpolateProvider} for configuring the</span>
<span class="Comment">     * interpolation markup.</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">       &lt;pre&gt;</span>
<span class="Comment">         var $interpolate = ...; // injected</span>
<span class="Comment">         var exp = $interpolate('Hello {{name | uppercase}}!');</span>
<span class="Comment">         expect(exp({name:'Angular'}).toEqual('Hello ANGULAR!');</span>
<span class="Comment">       &lt;/pre&gt;</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} text The text with markup to interpolate.</span>
<span class="Comment">     * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have</span>
<span class="Comment">     *    embedded expression in order to return an interpolation function. Strings with no</span>
<span class="Comment">     *    embedded expression will return null for the interpolation function.</span>
<span class="Comment">     * @param {string=} trustedContext when provided, the returned function passes the interpolated</span>
<span class="Comment">     *    result through {@link ng.$sce#methods_getTrusted $sce.getTrusted(interpolatedResult,</span>
<span class="Comment">     *    trustedContext)} before returning it.  Refer to the {@link ng.$sce $sce} service that</span>
<span class="Comment">     *    provides Strict Contextual Escaping for details.</span>
<span class="Comment">     * @returns {function(context)} an interpolation function which is used to compute the</span>
<span class="Comment">     *    interpolated string. The function has these parameters:</span>
<span class="Comment">     *</span>
<span class="Comment">     *    * `context`: an object against which any expressions embedded in the strings are evaluated</span>
<span class="Comment">     *      against.</span>
<span class="Comment">     *</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> $interpolate(text, mustHaveExpression, trustedContext) <span class="Identifier">{</span>
      <span class="Identifier">var</span> startIndex,
          endIndex,
          index = 0,
          parts = <span class="Identifier">[]</span>,
          length = text.length,
          hasInterpolation = <span class="Constant">false</span>,
          fn,
          exp,
          concat = <span class="Identifier">[]</span>;

      <span class="Statement">while</span>(index &lt; length) <span class="Identifier">{</span>
        <span class="Statement">if</span> ( ((startIndex = text.indexOf(startSymbol, index)) != -1) &amp;&amp;
             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) ) <span class="Identifier">{</span>
          (index != startIndex) &amp;&amp; parts.push(text.substring(index, startIndex));
          parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));
          fn.exp = exp;
          index = endIndex + endSymbolLength;
          hasInterpolation = <span class="Constant">true</span>;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          <span class="Comment">// we did not find anything, so we have to add the remainder to the parts array</span>
          (index != length) &amp;&amp; parts.push(text.substring(index));
          index = length;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>

      <span class="Statement">if</span> (!(length = parts.length)) <span class="Identifier">{</span>
        <span class="Comment">// we added, nothing, must have been an empty string.</span>
        parts.push(<span class="Constant">''</span>);
        length = 1;
      <span class="Identifier">}</span>

      <span class="Comment">// Concatenating expressions makes it hard to reason about whether some combination of</span>
      <span class="Comment">// concatenated values are unsafe to use and could easily lead to XSS.  By requiring that a</span>
      <span class="Comment">// single expression be used for iframe[src], object[src], etc., we ensure that the value</span>
      <span class="Comment">// that's used is assigned or constructed by some JS code somewhere that is more testable or</span>
      <span class="Comment">// make it obvious that you bound the value to some user controlled value.  This helps reduce</span>
      <span class="Comment">// the load when auditing for XSS issues.</span>
      <span class="Statement">if</span> (trustedContext &amp;&amp; parts.length &gt; 1) <span class="Identifier">{</span>
          <span class="Statement">throw</span> $interpolateMinErr(<span class="Constant">'noconcat'</span>,
              <span class="Constant">&quot;Error while interpolating: {0}</span><span class="Special">\n</span><span class="Constant">Strict Contextual Escaping disallows &quot;</span> +
              <span class="Constant">&quot;interpolations that concatenate multiple expressions when a trusted value is &quot;</span> +
              <span class="Constant">&quot;required.  See <a href="http://docs.angularjs.org/api/ng.$sce">http://docs.angularjs.org/api/ng.$sce</a>&quot;</span>, text);
      <span class="Identifier">}</span>

      <span class="Statement">if</span> (!mustHaveExpression  || hasInterpolation) <span class="Identifier">{</span>
        concat.length = length;
        fn = <span class="Identifier">function</span>(context) <span class="Identifier">{</span>
          <span class="Statement">try</span> <span class="Identifier">{</span>
            <span class="Statement">for</span>(<span class="Identifier">var</span> i = 0, ii = length, part; i&lt;ii; i++) <span class="Identifier">{</span>
              <span class="Statement">if</span> (<span class="Statement">typeof</span> (part = parts<span class="Identifier">[</span>i<span class="Identifier">]</span>) == <span class="Constant">'function'</span>) <span class="Identifier">{</span>
                part = part(context);
                <span class="Statement">if</span> (trustedContext) <span class="Identifier">{</span>
                  part = $sce.getTrusted(trustedContext, part);
                <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
                  part = $sce.valueOf(part);
                <span class="Identifier">}</span>
                <span class="Statement">if</span> (part === <span class="Statement">null</span> || isUndefined(part)) <span class="Identifier">{</span>
                  part = <span class="Constant">''</span>;
                <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Statement">typeof</span> part != <span class="Constant">'string'</span>) <span class="Identifier">{</span>
                  part = toJson(part);
                <span class="Identifier">}</span>
              <span class="Identifier">}</span>
              concat<span class="Identifier">[</span>i<span class="Identifier">]</span> = part;
            <span class="Identifier">}</span>
            <span class="Statement">return</span> concat.join(<span class="Constant">''</span>);
          <span class="Identifier">}</span>
          <span class="Statement">catch</span>(err) <span class="Identifier">{</span>
            <span class="Identifier">var</span> newErr = $interpolateMinErr(<span class="Constant">'interr'</span>, <span class="Constant">&quot;Can't interpolate: {0}</span><span class="Special">\n</span><span class="Constant">{1}&quot;</span>, text,
                err.toString());
            $exceptionHandler(newErr);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>;
        fn.exp = text;
        fn.parts = parts;
        <span class="Statement">return</span> fn;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>


    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$interpolate#startSymbol</span>
<span class="Comment">     * @methodOf ng.$interpolate</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.</span>
<span class="Comment">     *</span>
<span class="Comment">     * Use {@link ng.$interpolateProvider#startSymbol $interpolateProvider#startSymbol} to change</span>
<span class="Comment">     * the symbol.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @returns {string} start symbol.</span>
<span class="Comment">     */</span>
    $interpolate.startSymbol = <span class="Identifier">function</span>() <span class="Identifier">{</span>
      <span class="Statement">return</span> startSymbol;
    <span class="Identifier">}</span>;


    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$interpolate#endSymbol</span>
<span class="Comment">     * @methodOf ng.$interpolate</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.</span>
<span class="Comment">     *</span>
<span class="Comment">     * Use {@link ng.$interpolateProvider#endSymbol $interpolateProvider#endSymbol} to change</span>
<span class="Comment">     * the symbol.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @returns {string} start symbol.</span>
<span class="Comment">     */</span>
    $interpolate.endSymbol = <span class="Identifier">function</span>() <span class="Identifier">{</span>
      <span class="Statement">return</span> endSymbol;
    <span class="Identifier">}</span>;

    <span class="Statement">return</span> $interpolate;
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Identifier">function</span> $IntervalProvider() <span class="Identifier">{</span>
  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$rootScope'</span>, <span class="Constant">'$window'</span>, <span class="Constant">'$q'</span>,
       <span class="Identifier">function</span>($rootScope,   $<span class="Statement">window</span>,   $q) <span class="Identifier">{</span>
    <span class="Identifier">var</span> intervals = <span class="Identifier">{}</span>;


     <span class="Comment">/**</span>
<span class="Comment">      * @ngdoc function</span>
<span class="Comment">      * @name ng.$interval</span>
<span class="Comment">      *</span>
<span class="Comment">      * @description</span>
<span class="Comment">      * Angular's wrapper for `window.setInterval`. The `fn` function is executed every `delay`</span>
<span class="Comment">      * milliseconds.</span>
<span class="Comment">      *</span>
<span class="Comment">      * The return value of registering an interval function is a promise. This promise will be</span>
<span class="Comment">      * notified upon each tick of the interval, and will be resolved after `count` iterations, or</span>
<span class="Comment">      * run indefinitely if `count` is not defined. The value of the notification will be the</span>
<span class="Comment">      * number of iterations that have run.</span>
<span class="Comment">      * To cancel an interval, call `$interval.cancel(promise)`.</span>
<span class="Comment">      *</span>
<span class="Comment">      * In tests you can use {@link ngMock.$interval#methods_flush `$interval.flush(millis)`} to</span>
<span class="Comment">      * move forward by `millis` milliseconds and trigger any functions scheduled to run in that</span>
<span class="Comment">      * time.</span>
<span class="Comment">      *</span>
<span class="Comment">      * @param {function()} fn A function that should be called repeatedly.</span>
<span class="Comment">      * @param {number} delay Number of milliseconds between each function call.</span>
<span class="Comment">      * @param {number=} [count=0] Number of times to repeat. If not set, or 0, will repeat</span>
<span class="Comment">      *   indefinitely.</span>
<span class="Comment">      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise</span>
<span class="Comment">      *   will invoke `fn` within the {@link ng.$rootScope.Scope#methods_$apply $apply} block.</span>
<span class="Comment">      * @returns {promise} A promise which will be notified on each iteration.</span>
<span class="Comment">      */</span>
    <span class="Identifier">function</span> interval(fn, delay, count, invokeApply) <span class="Identifier">{</span>
      <span class="Identifier">var</span> setInterval = $<span class="Statement">window</span>.setInterval,
          clearInterval = $<span class="Statement">window</span>.clearInterval,
          deferred = $q.defer(),
          promise = deferred.promise,
          iteration = 0,
          skipApply = (isDefined(invokeApply) &amp;&amp; !invokeApply);

      count = isDefined(count) ? count : 0,

      promise.then(<span class="Statement">null</span>, <span class="Statement">null</span>, fn);

      promise.$$intervalId = setInterval(<span class="Identifier">function</span> tick() <span class="Identifier">{</span>
        deferred.notify(iteration++);

        <span class="Statement">if</span> (count &gt; 0 &amp;&amp; iteration &gt;= count) <span class="Identifier">{</span>
          deferred.resolve(iteration);
          clearInterval(promise.$$intervalId);
          <span class="Statement">delete</span> intervals<span class="Identifier">[</span>promise.$$intervalId<span class="Identifier">]</span>;
        <span class="Identifier">}</span>

        <span class="Statement">if</span> (!skipApply) $rootScope.$apply();

      <span class="Identifier">}</span>, delay);

      intervals<span class="Identifier">[</span>promise.$$intervalId<span class="Identifier">]</span> = deferred;

      <span class="Statement">return</span> promise;
    <span class="Identifier">}</span>


     <span class="Comment">/**</span>
<span class="Comment">      * @ngdoc function</span>
<span class="Comment">      * @name ng.$interval#cancel</span>
<span class="Comment">      * @methodOf ng.$interval</span>
<span class="Comment">      *</span>
<span class="Comment">      * @description</span>
<span class="Comment">      * Cancels a task associated with the `promise`.</span>
<span class="Comment">      *</span>
<span class="Comment">      * @param {number} promise Promise returned by the `$interval` function.</span>
<span class="Comment">      * @returns {boolean} Returns `true` if the task was successfully canceled.</span>
<span class="Comment">      */</span>
    interval.cancel = <span class="Identifier">function</span>(promise) <span class="Identifier">{</span>
      <span class="Statement">if</span> (promise &amp;&amp; promise.$$intervalId <span class="Statement">in</span> intervals) <span class="Identifier">{</span>
        intervals<span class="Identifier">[</span>promise.$$intervalId<span class="Identifier">]</span>.reject(<span class="Constant">'canceled'</span>);
        clearInterval(promise.$$intervalId);
        <span class="Statement">delete</span> intervals<span class="Identifier">[</span>promise.$$intervalId<span class="Identifier">]</span>;
        <span class="Statement">return</span> <span class="Constant">true</span>;
      <span class="Identifier">}</span>
      <span class="Statement">return</span> <span class="Constant">false</span>;
    <span class="Identifier">}</span>;

    <span class="Statement">return</span> interval;
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$locale</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * $locale service provides localization rules for various Angular components. As of right now the</span>
<span class="Comment"> * only public api is:</span>
<span class="Comment"> *</span>
<span class="Comment"> * * `id` – `{string}` – locale id formatted as `languageId-countryId` (e.g. `en-us`)</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $LocaleProvider()<span class="Identifier">{</span>
  <span class="Identifier">this</span>.$get = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">{</span>
      id: <span class="Constant">'en-us'</span>,

      NUMBER_FORMATS: <span class="Identifier">{</span>
        DECIMAL_SEP: <span class="Constant">'.'</span>,
        GROUP_SEP: <span class="Constant">','</span>,
        PATTERNS: <span class="Identifier">[</span>
          <span class="Identifier">{</span> <span class="Comment">// Decimal Pattern</span>
            minInt: 1,
            minFrac: 0,
            maxFrac: 3,
            posPre: <span class="Constant">''</span>,
            posSuf: <span class="Constant">''</span>,
            negPre: <span class="Constant">'-'</span>,
            negSuf: <span class="Constant">''</span>,
            gSize: 3,
            lgSize: 3
          <span class="Identifier">}</span>,<span class="Identifier">{</span> <span class="Comment">//Currency Pattern</span>
            minInt: 1,
            minFrac: 2,
            maxFrac: 2,
            posPre: <span class="Constant">'</span><span class="Special">\u</span><span class="Constant">00A4'</span>,
            posSuf: <span class="Constant">''</span>,
            negPre: <span class="Constant">'(</span><span class="Special">\u</span><span class="Constant">00A4'</span>,
            negSuf: <span class="Constant">')'</span>,
            gSize: 3,
            lgSize: 3
          <span class="Identifier">}</span>
        <span class="Identifier">]</span>,
        CURRENCY_SYM: <span class="Constant">'$'</span>
      <span class="Identifier">}</span>,

      DATETIME_FORMATS: <span class="Identifier">{</span>
        MONTH:
            <span class="Constant">'January,February,March,April,May,June,July,August,September,October,November,December'</span>
            .split(<span class="Constant">','</span>),
        SHORTMONTH:  <span class="Constant">'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'</span>.split(<span class="Constant">','</span>),
        DAY: <span class="Constant">'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'</span>.split(<span class="Constant">','</span>),
        SHORTDAY: <span class="Constant">'Sun,Mon,Tue,Wed,Thu,Fri,Sat'</span>.split(<span class="Constant">','</span>),
        AMPMS: <span class="Identifier">[</span><span class="Constant">'AM'</span>,<span class="Constant">'PM'</span><span class="Identifier">]</span>,
        medium: <span class="Constant">'MMM d, y h:mm:ss a'</span>,
        <span class="Statement">short</span>: <span class="Constant">'M/d/yy h:mm a'</span>,
        fullDate: <span class="Constant">'EEEE, MMMM d, y'</span>,
        longDate: <span class="Constant">'MMMM d, y'</span>,
        mediumDate: <span class="Constant">'MMM d, y'</span>,
        shortDate: <span class="Constant">'M/d/yy'</span>,
        mediumTime: <span class="Constant">'h:mm:ss a'</span>,
        shortTime: <span class="Constant">'h:mm a'</span>
      <span class="Identifier">}</span>,

      pluralCat: <span class="Identifier">function</span>(num) <span class="Identifier">{</span>
        <span class="Statement">if</span> (num === 1) <span class="Identifier">{</span>
          <span class="Statement">return</span> <span class="Constant">'one'</span>;
        <span class="Identifier">}</span>
        <span class="Statement">return</span> <span class="Constant">'other'</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Identifier">var</span> PATH_MATCH = <span class="Constant">/^([^\?#]*)(\?([^#]*))?(#(.*))?$/</span>,
    DEFAULT_PORTS = <span class="Identifier">{</span><span class="Constant">'http'</span>: 80, <span class="Constant">'https'</span>: 443, <span class="Constant">'ftp'</span>: 21<span class="Identifier">}</span>;
<span class="Identifier">var</span> $locationMinErr = minErr(<span class="Constant">'$location'</span>);


<span class="Comment">/**</span>
<span class="Comment"> * Encode path using encodeUriSegment, ignoring forward slashes</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} path Path to encode</span>
<span class="Comment"> * @returns {string}</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> encodePath(path) <span class="Identifier">{</span>
  <span class="Identifier">var</span> segments = path.split(<span class="Constant">'/'</span>),
      i = segments.length;

  <span class="Statement">while</span> (i--) <span class="Identifier">{</span>
    segments<span class="Identifier">[</span>i<span class="Identifier">]</span> = encodeUriSegment(segments<span class="Identifier">[</span>i<span class="Identifier">]</span>);
  <span class="Identifier">}</span>

  <span class="Statement">return</span> segments.join(<span class="Constant">'/'</span>);
<span class="Identifier">}</span>

<span class="Identifier">function</span> parseAbsoluteUrl(absoluteUrl, locationObj, appBase) <span class="Identifier">{</span>
  <span class="Identifier">var</span> parsedUrl = urlResolve(absoluteUrl, appBase);

  locationObj.$$protocol = parsedUrl.protocol;
  locationObj.$$host = parsedUrl.hostname;
  locationObj.$$port = <span class="Statement">int</span>(parsedUrl.port) || DEFAULT_PORTS<span class="Identifier">[</span>parsedUrl.protocol<span class="Identifier">]</span> || <span class="Statement">null</span>;
<span class="Identifier">}</span>


<span class="Identifier">function</span> parseAppUrl(relativeUrl, locationObj, appBase) <span class="Identifier">{</span>
  <span class="Identifier">var</span> prefixed = (relativeUrl.charAt(0) !== <span class="Constant">'/'</span>);
  <span class="Statement">if</span> (prefixed) <span class="Identifier">{</span>
    relativeUrl = <span class="Constant">'/'</span> + relativeUrl;
  <span class="Identifier">}</span>
  <span class="Identifier">var</span> match = urlResolve(relativeUrl, appBase);
  locationObj.$$path = decodeURIComponent(prefixed &amp;&amp; match.pathname.charAt(0) === <span class="Constant">'/'</span> ?
      match.pathname.substring(1) : match.pathname);
  locationObj.$$search = parseKeyValue(match.search);
  locationObj.$$hash = decodeURIComponent(match.hash);

  <span class="Comment">// make sure path starts with '/';</span>
  <span class="Statement">if</span> (locationObj.$$path &amp;&amp; locationObj.$$path.charAt(0) != <span class="Constant">'/'</span>) <span class="Identifier">{</span>
    locationObj.$$path = <span class="Constant">'/'</span> + locationObj.$$path;
  <span class="Identifier">}</span>
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} begin</span>
<span class="Comment"> * @param {string} whole</span>
<span class="Comment"> * @returns {string} returns text from whole after begin or undefined if it does not begin with</span>
<span class="Comment"> *                   expected string.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> beginsWith(begin, whole) <span class="Identifier">{</span>
  <span class="Statement">if</span> (whole.indexOf(begin) === 0) <span class="Identifier">{</span>
    <span class="Statement">return</span> whole.substr(begin.length);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>


<span class="Identifier">function</span> stripHash(url) <span class="Identifier">{</span>
  <span class="Identifier">var</span> index = url.indexOf(<span class="Constant">'#'</span>);
  <span class="Statement">return</span> index == -1 ? url : url.substr(0, index);
<span class="Identifier">}</span>


<span class="Identifier">function</span> stripFile(url) <span class="Identifier">{</span>
  <span class="Statement">return</span> url.substr(0, stripHash(url).lastIndexOf(<span class="Constant">'/'</span>) + 1);
<span class="Identifier">}</span>

<span class="Comment">/* return the server only (scheme://host:port) */</span>
<span class="Identifier">function</span> serverBase(url) <span class="Identifier">{</span>
  <span class="Statement">return</span> url.substring(0, url.indexOf(<span class="Constant">'/'</span>, url.indexOf(<span class="Constant">'//'</span>) + 2));
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * LocationHtml5Url represents an url</span>
<span class="Comment"> * This object is exposed as $location service when HTML5 mode is enabled and supported</span>
<span class="Comment"> *</span>
<span class="Comment"> * @constructor</span>
<span class="Comment"> * @param {string} appBase application base URL</span>
<span class="Comment"> * @param {string} basePrefix url path prefix</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> LocationHtml5Url(appBase, basePrefix) <span class="Identifier">{</span>
  <span class="Identifier">this</span>.$$html5 = <span class="Constant">true</span>;
  basePrefix = basePrefix || <span class="Constant">''</span>;
  <span class="Identifier">var</span> appBaseNoFile = stripFile(appBase);
  parseAbsoluteUrl(appBase, <span class="Identifier">this</span>, appBase);


  <span class="Comment">/**</span>
<span class="Comment">   * Parse given html5 (regular) url string into properties</span>
<span class="Comment">   * @param {string} newAbsoluteUrl HTML5 url</span>
<span class="Comment">   * @private</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.$$parse = <span class="Identifier">function</span>(url) <span class="Identifier">{</span>
    <span class="Identifier">var</span> pathUrl = beginsWith(appBaseNoFile, url);
    <span class="Statement">if</span> (!isString(pathUrl)) <span class="Identifier">{</span>
      <span class="Statement">throw</span> $locationMinErr(<span class="Constant">'ipthprfx'</span>, <span class="Constant">'Invalid url &quot;{0}&quot;, missing path prefix &quot;{1}&quot;.'</span>, url,
          appBaseNoFile);
    <span class="Identifier">}</span>

    parseAppUrl(pathUrl, <span class="Identifier">this</span>, appBase);

    <span class="Statement">if</span> (!<span class="Identifier">this</span>.$$path) <span class="Identifier">{</span>
      <span class="Identifier">this</span>.$$path = <span class="Constant">'/'</span>;
    <span class="Identifier">}</span>

    <span class="Identifier">this</span>.$$compose();
  <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * Compose url and update `absUrl` property</span>
<span class="Comment">   * @private</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.$$compose = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> search = toKeyValue(<span class="Identifier">this</span>.$$search),
        hash = <span class="Identifier">this</span>.$$hash ? <span class="Constant">'#'</span> + encodeUriSegment(<span class="Identifier">this</span>.$$hash) : <span class="Constant">''</span>;

    <span class="Identifier">this</span>.$$url = encodePath(<span class="Identifier">this</span>.$$path) + (search ? <span class="Constant">'?'</span> + search : <span class="Constant">''</span>) + hash;
    <span class="Identifier">this</span>.$$absUrl = appBaseNoFile + <span class="Identifier">this</span>.$$url.substr(1); <span class="Comment">// first char is always '/'</span>
  <span class="Identifier">}</span>;

  <span class="Identifier">this</span>.$$rewrite = <span class="Identifier">function</span>(url) <span class="Identifier">{</span>
    <span class="Identifier">var</span> appUrl, prevAppUrl;

    <span class="Statement">if</span> ( (appUrl = beginsWith(appBase, url)) !== <span class="Statement">undefined</span> ) <span class="Identifier">{</span>
      prevAppUrl = appUrl;
      <span class="Statement">if</span> ( (appUrl = beginsWith(basePrefix, appUrl)) !== <span class="Statement">undefined</span> ) <span class="Identifier">{</span>
        <span class="Statement">return</span> appBaseNoFile + (beginsWith(<span class="Constant">'/'</span>, appUrl) || appUrl);
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">return</span> appBase + prevAppUrl;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> ( (appUrl = beginsWith(appBaseNoFile, url)) !== <span class="Statement">undefined</span> ) <span class="Identifier">{</span>
      <span class="Statement">return</span> appBaseNoFile + appUrl;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (appBaseNoFile == url + <span class="Constant">'/'</span>) <span class="Identifier">{</span>
      <span class="Statement">return</span> appBaseNoFile;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * LocationHashbangUrl represents url</span>
<span class="Comment"> * This object is exposed as $location service when developer doesn't opt into html5 mode.</span>
<span class="Comment"> * It also serves as the base class for html5 mode fallback on legacy browsers.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @constructor</span>
<span class="Comment"> * @param {string} appBase application base URL</span>
<span class="Comment"> * @param {string} hashPrefix hashbang prefix</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> LocationHashbangUrl(appBase, hashPrefix) <span class="Identifier">{</span>
  <span class="Identifier">var</span> appBaseNoFile = stripFile(appBase);

  parseAbsoluteUrl(appBase, <span class="Identifier">this</span>, appBase);


  <span class="Comment">/**</span>
<span class="Comment">   * Parse given hashbang url into properties</span>
<span class="Comment">   * @param {string} url Hashbang url</span>
<span class="Comment">   * @private</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.$$parse = <span class="Identifier">function</span>(url) <span class="Identifier">{</span>
    <span class="Identifier">var</span> withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
    <span class="Identifier">var</span> withoutHashUrl = withoutBaseUrl.charAt(0) == <span class="Constant">'#'</span>
        ? beginsWith(hashPrefix, withoutBaseUrl)
        : (<span class="Identifier">this</span>.$$html5)
          ? withoutBaseUrl
          : <span class="Constant">''</span>;

    <span class="Statement">if</span> (!isString(withoutHashUrl)) <span class="Identifier">{</span>
      <span class="Statement">throw</span> $locationMinErr(<span class="Constant">'ihshprfx'</span>, <span class="Constant">'Invalid url &quot;{0}&quot;, missing hash prefix &quot;{1}&quot;.'</span>, url,
          hashPrefix);
    <span class="Identifier">}</span>
    parseAppUrl(withoutHashUrl, <span class="Identifier">this</span>, appBase);

    <span class="Identifier">this</span>.$$path = removeWindowsDriveName(<span class="Identifier">this</span>.$$path, withoutHashUrl, appBase);

    <span class="Identifier">this</span>.$$compose();

    <span class="Comment">/*</span>
<span class="Comment">     * In Windows, on an anchor node on documents loaded from</span>
<span class="Comment">     * the filesystem, the browser will return a pathname</span>
<span class="Comment">     * prefixed with the drive name ('/C:/path') when a</span>
<span class="Comment">     * pathname without a drive is set:</span>
<span class="Comment">     *  * a.setAttribute('href', '/foo')</span>
<span class="Comment">     *   * a.pathname === '/C:/foo' //true</span>
<span class="Comment">     *</span>
<span class="Comment">     * Inside of Angular, we're always using pathnames that</span>
<span class="Comment">     * do not include drive names for routing.</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> removeWindowsDriveName (path, url, base) <span class="Identifier">{</span>
      <span class="Comment">/*</span>
<span class="Comment">      Matches paths for file protocol on windows,</span>
<span class="Comment">      such as /C:/foo/bar, and captures only /foo/bar.</span>
<span class="Comment">      */</span>
      <span class="Identifier">var</span> windowsFilePathExp = <span class="Constant">/^\/?.*?:(\/.*)/</span>;

      <span class="Identifier">var</span> firstPathSegmentMatch;

      <span class="Comment">//Get the relative path from the input URL.</span>
      <span class="Statement">if</span> (url.indexOf(base) === 0) <span class="Identifier">{</span>
        url = url.replace(base, <span class="Constant">''</span>);
      <span class="Identifier">}</span>

      <span class="Comment">/*</span>
<span class="Comment">       * The input URL intentionally contains a</span>
<span class="Comment">       * first path segment that ends with a colon.</span>
<span class="Comment">       */</span>
      <span class="Statement">if</span> (windowsFilePathExp.exec(url)) <span class="Identifier">{</span>
        <span class="Statement">return</span> path;
      <span class="Identifier">}</span>

      firstPathSegmentMatch = windowsFilePathExp.exec(path);
      <span class="Statement">return</span> firstPathSegmentMatch ? firstPathSegmentMatch<span class="Identifier">[</span>1<span class="Identifier">]</span> : path;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * Compose hashbang url and update `absUrl` property</span>
<span class="Comment">   * @private</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.$$compose = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> search = toKeyValue(<span class="Identifier">this</span>.$$search),
        hash = <span class="Identifier">this</span>.$$hash ? <span class="Constant">'#'</span> + encodeUriSegment(<span class="Identifier">this</span>.$$hash) : <span class="Constant">''</span>;

    <span class="Identifier">this</span>.$$url = encodePath(<span class="Identifier">this</span>.$$path) + (search ? <span class="Constant">'?'</span> + search : <span class="Constant">''</span>) + hash;
    <span class="Identifier">this</span>.$$absUrl = appBase + (<span class="Identifier">this</span>.$$url ? hashPrefix + <span class="Identifier">this</span>.$$url : <span class="Constant">''</span>);
  <span class="Identifier">}</span>;

  <span class="Identifier">this</span>.$$rewrite = <span class="Identifier">function</span>(url) <span class="Identifier">{</span>
    <span class="Statement">if</span>(stripHash(appBase) == stripHash(url)) <span class="Identifier">{</span>
      <span class="Statement">return</span> url;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * LocationHashbangUrl represents url</span>
<span class="Comment"> * This object is exposed as $location service when html5 history api is enabled but the browser</span>
<span class="Comment"> * does not support it.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @constructor</span>
<span class="Comment"> * @param {string} appBase application base URL</span>
<span class="Comment"> * @param {string} hashPrefix hashbang prefix</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> LocationHashbangInHtml5Url(appBase, hashPrefix) <span class="Identifier">{</span>
  <span class="Identifier">this</span>.$$html5 = <span class="Constant">true</span>;
  LocationHashbangUrl.apply(<span class="Identifier">this</span>, <span class="Identifier">arguments</span>);

  <span class="Identifier">var</span> appBaseNoFile = stripFile(appBase);

  <span class="Identifier">this</span>.$$rewrite = <span class="Identifier">function</span>(url) <span class="Identifier">{</span>
    <span class="Identifier">var</span> appUrl;

    <span class="Statement">if</span> ( appBase == stripHash(url) ) <span class="Identifier">{</span>
      <span class="Statement">return</span> url;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> ( (appUrl = beginsWith(appBaseNoFile, url)) ) <span class="Identifier">{</span>
      <span class="Statement">return</span> appBase + hashPrefix + appUrl;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> ( appBaseNoFile === url + <span class="Constant">'/'</span>) <span class="Identifier">{</span>
      <span class="Statement">return</span> appBaseNoFile;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>


LocationHashbangInHtml5Url.prototype =
  LocationHashbangUrl.prototype =
  LocationHtml5Url.prototype = <span class="Identifier">{</span>

  <span class="Comment">/**</span>
<span class="Comment">   * Are we in html5 mode?</span>
<span class="Comment">   * @private</span>
<span class="Comment">   */</span>
  $$html5: <span class="Constant">false</span>,

  <span class="Comment">/**</span>
<span class="Comment">   * Has any change been replacing ?</span>
<span class="Comment">   * @private</span>
<span class="Comment">   */</span>
  $$replace: <span class="Constant">false</span>,

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$location#absUrl</span>
<span class="Comment">   * @methodOf ng.$location</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * This method is getter only.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Return full url representation with all segments encoded according to rules specified in</span>
<span class="Comment">   * {@link <a href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a> RFC 3986}.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @return {string} full url</span>
<span class="Comment">   */</span>
  absUrl: locationGetter(<span class="Constant">'$$absUrl'</span>),

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$location#url</span>
<span class="Comment">   * @methodOf ng.$location</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * This method is getter / setter.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Return url (e.g. `/path?a=b#hash`) when called without any parameter.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Change path, search and hash, when called with parameter and return `$location`.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string=} url New url without base prefix (e.g. `/path?a=b#hash`)</span>
<span class="Comment">   * @param {string=} replace The path that will be changed</span>
<span class="Comment">   * @return {string} url</span>
<span class="Comment">   */</span>
  url: <span class="Identifier">function</span>(url, replace) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isUndefined(url))
      <span class="Statement">return</span> <span class="Identifier">this</span>.$$url;

    <span class="Identifier">var</span> match = PATH_MATCH.exec(url);
    <span class="Statement">if</span> (match<span class="Identifier">[</span>1<span class="Identifier">]</span>) <span class="Identifier">this</span>.path(decodeURIComponent(match<span class="Identifier">[</span>1<span class="Identifier">]</span>));
    <span class="Statement">if</span> (match<span class="Identifier">[</span>2<span class="Identifier">]</span> || match<span class="Identifier">[</span>1<span class="Identifier">]</span>) <span class="Identifier">this</span>.search(match<span class="Identifier">[</span>3<span class="Identifier">]</span> || <span class="Constant">''</span>);
    <span class="Identifier">this</span>.hash(match<span class="Identifier">[</span>5<span class="Identifier">]</span> || <span class="Constant">''</span>, replace);

    <span class="Statement">return</span> <span class="Identifier">this</span>;
  <span class="Identifier">}</span>,

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$location#protocol</span>
<span class="Comment">   * @methodOf ng.$location</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * This method is getter only.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Return protocol of current url.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @return {string} protocol of current url</span>
<span class="Comment">   */</span>
  protocol: locationGetter(<span class="Constant">'$$protocol'</span>),

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$location#host</span>
<span class="Comment">   * @methodOf ng.$location</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * This method is getter only.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Return host of current url.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @return {string} host of current url.</span>
<span class="Comment">   */</span>
  host: locationGetter(<span class="Constant">'$$host'</span>),

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$location#port</span>
<span class="Comment">   * @methodOf ng.$location</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * This method is getter only.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Return port of current url.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @return {Number} port</span>
<span class="Comment">   */</span>
  port: locationGetter(<span class="Constant">'$$port'</span>),

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$location#path</span>
<span class="Comment">   * @methodOf ng.$location</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * This method is getter / setter.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Return path of current url when called without any parameter.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Change path when called with parameter and return `$location`.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Note: Path should always begin with forward slash (/), this method will add the forward slash</span>
<span class="Comment">   * if it is missing.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string=} path New path</span>
<span class="Comment">   * @return {string} path</span>
<span class="Comment">   */</span>
  path: locationGetterSetter(<span class="Constant">'$$path'</span>, <span class="Identifier">function</span>(path) <span class="Identifier">{</span>
    <span class="Statement">return</span> path.charAt(0) == <span class="Constant">'/'</span> ? path : <span class="Constant">'/'</span> + path;
  <span class="Identifier">}</span>),

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$location#search</span>
<span class="Comment">   * @methodOf ng.$location</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * This method is getter / setter.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Return search part (as object) of current url when called without any parameter.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Change search part when called with parameter and return `$location`.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string|Object.&lt;string&gt;|Object.&lt;Array.&lt;string&gt;&gt;} search New search params - string or</span>
<span class="Comment">   * hash object. Hash object may contain an array of values, which will be decoded as duplicates in</span>
<span class="Comment">   * the url.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {(string|Array&lt;string&gt;)=} paramValue If `search` is a string, then `paramValue` will override only a</span>
<span class="Comment">   * single search parameter. If `paramValue` is an array, it will set the parameter as a</span>
<span class="Comment">   * comma-separated value. If `paramValue` is `null`, the parameter will be deleted.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @return {string} search</span>
<span class="Comment">   */</span>
  search: <span class="Identifier">function</span>(search, paramValue) <span class="Identifier">{</span>
    <span class="Statement">switch</span> (<span class="Identifier">arguments</span>.length) <span class="Identifier">{</span>
      <span class="Statement">case</span> 0:
        <span class="Statement">return</span> <span class="Identifier">this</span>.$$search;
      <span class="Statement">case</span> 1:
        <span class="Statement">if</span> (isString(search)) <span class="Identifier">{</span>
          <span class="Identifier">this</span>.$$search = parseKeyValue(search);
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isObject(search)) <span class="Identifier">{</span>
          <span class="Identifier">this</span>.$$search = search;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          <span class="Statement">throw</span> $locationMinErr(<span class="Constant">'isrcharg'</span>,
              <span class="Constant">'The first argument of the `$location#search()` call must be a string or an object.'</span>);
        <span class="Identifier">}</span>
        <span class="Statement">break</span>;
      <span class="Statement">default</span>:
        <span class="Statement">if</span> (isUndefined(paramValue) || paramValue === <span class="Statement">null</span>) <span class="Identifier">{</span>
          <span class="Statement">delete</span> <span class="Identifier">this</span>.$$search<span class="Identifier">[</span>search<span class="Identifier">]</span>;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          <span class="Identifier">this</span>.$$search<span class="Identifier">[</span>search<span class="Identifier">]</span> = paramValue;
        <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Identifier">this</span>.$$compose();
    <span class="Statement">return</span> <span class="Identifier">this</span>;
  <span class="Identifier">}</span>,

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$location#hash</span>
<span class="Comment">   * @methodOf ng.$location</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * This method is getter / setter.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Return hash fragment when called without any parameter.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Change hash fragment when called with parameter and return `$location`.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string=} hash New hash fragment</span>
<span class="Comment">   * @return {string} hash</span>
<span class="Comment">   */</span>
  hash: locationGetterSetter(<span class="Constant">'$$hash'</span>, identity),

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$location#replace</span>
<span class="Comment">   * @methodOf ng.$location</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * If called, all changes to $location during current `$digest` will be replacing current history</span>
<span class="Comment">   * record, instead of adding new one.</span>
<span class="Comment">   */</span>
  replace: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">this</span>.$$replace = <span class="Constant">true</span>;
    <span class="Statement">return</span> <span class="Identifier">this</span>;
  <span class="Identifier">}</span>
<span class="Identifier">}</span>;

<span class="Identifier">function</span> locationGetter(property) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">this</span><span class="Identifier">[</span>property<span class="Identifier">]</span>;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>


<span class="Identifier">function</span> locationGetterSetter(property, preprocess) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isUndefined(value))
      <span class="Statement">return</span> <span class="Identifier">this</span><span class="Identifier">[</span>property<span class="Identifier">]</span>;

    <span class="Identifier">this</span><span class="Identifier">[</span>property<span class="Identifier">]</span> = preprocess(value);
    <span class="Identifier">this</span>.$$compose();

    <span class="Statement">return</span> <span class="Identifier">this</span>;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$location</span>
<span class="Comment"> *</span>
<span class="Comment"> * @requires $browser</span>
<span class="Comment"> * @requires $sniffer</span>
<span class="Comment"> * @requires $rootElement</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The $location service parses the URL in the browser address bar (based on the</span>
<span class="Comment"> * {@link <a href="https://developer.mozilla.org/en/window.location">https://developer.mozilla.org/en/window.location</a> window.location}) and makes the URL</span>
<span class="Comment"> * available to your application. Changes to the URL in the address bar are reflected into</span>
<span class="Comment"> * $location service and changes to $location are reflected into the browser address bar.</span>
<span class="Comment"> *</span>
<span class="Comment"> * **The $location service:**</span>
<span class="Comment"> *</span>
<span class="Comment"> * - Exposes the current URL in the browser address bar, so you can</span>
<span class="Comment"> *   - Watch and observe the URL.</span>
<span class="Comment"> *   - Change the URL.</span>
<span class="Comment"> * - Synchronizes the URL with the browser when the user</span>
<span class="Comment"> *   - Changes the address bar.</span>
<span class="Comment"> *   - Clicks the back or forward button (or clicks a History link).</span>
<span class="Comment"> *   - Clicks on a link.</span>
<span class="Comment"> * - Represents the URL object as a set of methods (protocol, host, port, path, search, hash).</span>
<span class="Comment"> *</span>
<span class="Comment"> * For more information see {@link guide/dev_guide.services.$location Developer Guide: Angular</span>
<span class="Comment"> * Services: Using $location}</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$locationProvider</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Use the `$locationProvider` to configure how the application deep linking paths are stored.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $LocationProvider()<span class="Identifier">{</span>
  <span class="Identifier">var</span> hashPrefix = <span class="Constant">''</span>,
      html5Mode = <span class="Constant">false</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc property</span>
<span class="Comment">   * @name ng.$locationProvider#hashPrefix</span>
<span class="Comment">   * @methodOf ng.$locationProvider</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * @param {string=} prefix Prefix for hash part (containing path and search)</span>
<span class="Comment">   * @returns {*} current value if used as getter or itself (chaining) if used as setter</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.hashPrefix = <span class="Identifier">function</span>(prefix) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isDefined(prefix)) <span class="Identifier">{</span>
      hashPrefix = prefix;
      <span class="Statement">return</span> <span class="Identifier">this</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> hashPrefix;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc property</span>
<span class="Comment">   * @name ng.$locationProvider#html5Mode</span>
<span class="Comment">   * @methodOf ng.$locationProvider</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * @param {boolean=} mode Use HTML5 strategy if available.</span>
<span class="Comment">   * @returns {*} current value if used as getter or itself (chaining) if used as setter</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.html5Mode = <span class="Identifier">function</span>(mode) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isDefined(mode)) <span class="Identifier">{</span>
      html5Mode = mode;
      <span class="Statement">return</span> <span class="Identifier">this</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> html5Mode;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc event</span>
<span class="Comment">   * @name ng.$location#$locationChangeStart</span>
<span class="Comment">   * @eventOf ng.$location</span>
<span class="Comment">   * @eventType broadcast on root scope</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Broadcasted before a URL will change. This change can be prevented by calling</span>
<span class="Comment">   * `preventDefault` method of the event. See {@link ng.$rootScope.Scope#$on} for more</span>
<span class="Comment">   * details about event object. Upon successful change</span>
<span class="Comment">   * {@link ng.$location#$locationChangeSuccess $locationChangeSuccess} is fired.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {Object} angularEvent Synthetic event object.</span>
<span class="Comment">   * @param {string} newUrl New URL</span>
<span class="Comment">   * @param {string=} oldUrl URL that was before it was changed.</span>
<span class="Comment">   */</span>

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc event</span>
<span class="Comment">   * @name ng.$location#$locationChangeSuccess</span>
<span class="Comment">   * @eventOf ng.$location</span>
<span class="Comment">   * @eventType broadcast on root scope</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Broadcasted after a URL was changed.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {Object} angularEvent Synthetic event object.</span>
<span class="Comment">   * @param {string} newUrl New URL</span>
<span class="Comment">   * @param {string=} oldUrl URL that was before it was changed.</span>
<span class="Comment">   */</span>

  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$rootScope'</span>, <span class="Constant">'$browser'</span>, <span class="Constant">'$sniffer'</span>, <span class="Constant">'$rootElement'</span>,
      <span class="Identifier">function</span>( $rootScope,   $browser,   $sniffer,   $rootElement) <span class="Identifier">{</span>
    <span class="Identifier">var</span> $<span class="Statement">location</span>,
        LocationMode,
        baseHref = $browser.baseHref(), <span class="Comment">// if base[href] is undefined, it defaults to ''</span>
        initialUrl = $browser.url(),
        appBase;

    <span class="Statement">if</span> (html5Mode) <span class="Identifier">{</span>
      appBase = serverBase(initialUrl) + (baseHref || <span class="Constant">'/'</span>);
      LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      appBase = stripHash(initialUrl);
      LocationMode = LocationHashbangUrl;
    <span class="Identifier">}</span>
    $<span class="Statement">location</span> = <span class="Statement">new</span> LocationMode(appBase, <span class="Constant">'#'</span> + hashPrefix);
    $<span class="Statement">location</span>.$$parse($<span class="Statement">location</span>.$$rewrite(initialUrl));

    $rootElement.on(<span class="Constant">'click'</span>, <span class="Identifier">function</span>(<span class="Statement">event</span>) <span class="Identifier">{</span>
      <span class="Comment">// </span><span class="Todo">TODO</span><span class="Comment">(vojta): rewrite link when opening in new tab/window (in legacy browser)</span>
      <span class="Comment">// currently we open nice url link and redirect then</span>

      <span class="Statement">if</span> (<span class="Statement">event</span>.ctrlKey || <span class="Statement">event</span>.metaKey || <span class="Statement">event</span>.which == 2) <span class="Statement">return</span>;

      <span class="Identifier">var</span> elm = jqLite(<span class="Statement">event</span>.target);

      <span class="Comment">// traverse the DOM up to find first A tag</span>
      <span class="Statement">while</span> (lowercase(elm<span class="Identifier">[</span>0<span class="Identifier">]</span>.nodeName) !== <span class="Constant">'a'</span>) <span class="Identifier">{</span>
        <span class="Comment">// ignore rewriting if no A tag (reached root element, or no parent - removed from document)</span>
        <span class="Statement">if</span> (elm<span class="Identifier">[</span>0<span class="Identifier">]</span> === $rootElement<span class="Identifier">[</span>0<span class="Identifier">]</span> || !(elm = elm.<span class="Statement">parent</span>())<span class="Identifier">[</span>0<span class="Identifier">]</span>) <span class="Statement">return</span>;
      <span class="Identifier">}</span>

      <span class="Identifier">var</span> absHref = elm.prop(<span class="Constant">'href'</span>);
      <span class="Identifier">var</span> rewrittenUrl = $<span class="Statement">location</span>.$$rewrite(absHref);

      <span class="Statement">if</span> (absHref &amp;&amp; !elm.attr(<span class="Constant">'target'</span>) &amp;&amp; rewrittenUrl &amp;&amp; !<span class="Statement">event</span>.isDefaultPrevented()) <span class="Identifier">{</span>
        <span class="Statement">event</span>.preventDefault();
        <span class="Statement">if</span> (rewrittenUrl != $browser.url()) <span class="Identifier">{</span>
          <span class="Comment">// update location manually</span>
          $<span class="Statement">location</span>.$$parse(rewrittenUrl);
          $rootScope.$apply();
          <span class="Comment">// hack to work around FF6 bug 684208 when scenario runner clicks on links</span>
          <span class="Statement">window</span>.angular<span class="Identifier">[</span><span class="Constant">'ff-684208-preventDefault'</span><span class="Identifier">]</span> = <span class="Constant">true</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>);


    <span class="Comment">// rewrite hashbang url &lt;&gt; html5 url</span>
    <span class="Statement">if</span> ($<span class="Statement">location</span>.absUrl() != initialUrl) <span class="Identifier">{</span>
      $browser.url($<span class="Statement">location</span>.absUrl(), <span class="Constant">true</span>);
    <span class="Identifier">}</span>

    <span class="Comment">// update $location when $browser url changes</span>
    $browser.onUrlChange(<span class="Identifier">function</span>(newUrl) <span class="Identifier">{</span>
      <span class="Statement">if</span> ($<span class="Statement">location</span>.absUrl() != newUrl) <span class="Identifier">{</span>
        <span class="Statement">if</span> ($rootScope.$broadcast(<span class="Constant">'$locationChangeStart'</span>, newUrl,
                                  $<span class="Statement">location</span>.absUrl()).defaultPrevented) <span class="Identifier">{</span>
          $browser.url($<span class="Statement">location</span>.absUrl());
          <span class="Statement">return</span>;
        <span class="Identifier">}</span>
        $rootScope.$evalAsync(<span class="Identifier">function</span>() <span class="Identifier">{</span>
          <span class="Identifier">var</span> oldUrl = $<span class="Statement">location</span>.absUrl();

          $<span class="Statement">location</span>.$$parse(newUrl);
          afterLocationChange(oldUrl);
        <span class="Identifier">}</span>);
        <span class="Statement">if</span> (!$rootScope.$$phase) $rootScope.$digest();
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>);

    <span class="Comment">// update browser</span>
    <span class="Identifier">var</span> changeCounter = 0;
    $rootScope.$watch(<span class="Identifier">function</span> $locationWatch() <span class="Identifier">{</span>
      <span class="Identifier">var</span> oldUrl = $browser.url();
      <span class="Identifier">var</span> currentReplace = $<span class="Statement">location</span>.$$replace;

      <span class="Statement">if</span> (!changeCounter || oldUrl != $<span class="Statement">location</span>.absUrl()) <span class="Identifier">{</span>
        changeCounter++;
        $rootScope.$evalAsync(<span class="Identifier">function</span>() <span class="Identifier">{</span>
          <span class="Statement">if</span> ($rootScope.$broadcast(<span class="Constant">'$locationChangeStart'</span>, $<span class="Statement">location</span>.absUrl(), oldUrl).
              defaultPrevented) <span class="Identifier">{</span>
            $<span class="Statement">location</span>.$$parse(oldUrl);
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            $browser.url($<span class="Statement">location</span>.absUrl(), currentReplace);
            afterLocationChange(oldUrl);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>);
      <span class="Identifier">}</span>
      $<span class="Statement">location</span>.$$replace = <span class="Constant">false</span>;

      <span class="Statement">return</span> changeCounter;
    <span class="Identifier">}</span>);

    <span class="Statement">return</span> $<span class="Statement">location</span>;

    <span class="Identifier">function</span> afterLocationChange(oldUrl) <span class="Identifier">{</span>
      $rootScope.$broadcast(<span class="Constant">'$locationChangeSuccess'</span>, $<span class="Statement">location</span>.absUrl(), oldUrl);
    <span class="Identifier">}</span>
<span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$log</span>
<span class="Comment"> * @requires $window</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Simple service for logging. Default implementation safely writes the message</span>
<span class="Comment"> * into the browser's console (if present).</span>
<span class="Comment"> * </span>
<span class="Comment"> * The main purpose of this service is to simplify debugging and troubleshooting.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The default is to log `debug` messages. You can use</span>
<span class="Comment"> * {@link ng.$logProvider ng.$logProvider#debugEnabled} to change this.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;example&gt;</span>
<span class="Comment">     &lt;file name=&quot;script.js&quot;&gt;</span>
<span class="Comment">       function LogCtrl($scope, $log) {</span>
<span class="Comment">         $scope.$log = $log;</span>
<span class="Comment">         $scope.message = 'Hello World!';</span>
<span class="Comment">       }</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">     &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">       &lt;div ng-controller=&quot;LogCtrl&quot;&gt;</span>
<span class="Comment">         &lt;p&gt;Reload this page with open console, enter text and hit the log button...&lt;/p&gt;</span>
<span class="Comment">         Message:</span>
<span class="Comment">         &lt;input type=&quot;text&quot; ng-model=&quot;message&quot;/&gt;</span>
<span class="Comment">         &lt;button ng-click=&quot;$log.log(message)&quot;&gt;log&lt;/button&gt;</span>
<span class="Comment">         &lt;button ng-click=&quot;$log.warn(message)&quot;&gt;warn&lt;/button&gt;</span>
<span class="Comment">         &lt;button ng-click=&quot;$log.info(message)&quot;&gt;info&lt;/button&gt;</span>
<span class="Comment">         &lt;button ng-click=&quot;$log.error(message)&quot;&gt;error&lt;/button&gt;</span>
<span class="Comment">       &lt;/div&gt;</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">   &lt;/example&gt;</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$logProvider</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Use the `$logProvider` to configure how the application logs messages</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $LogProvider()<span class="Identifier">{</span>
  <span class="Identifier">var</span> debug = <span class="Constant">true</span>,
      <span class="Statement">self</span> = <span class="Identifier">this</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc property</span>
<span class="Comment">   * @name ng.$logProvider#debugEnabled</span>
<span class="Comment">   * @methodOf ng.$logProvider</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * @param {string=} flag enable or disable debug level messages</span>
<span class="Comment">   * @returns {*} current value if used as getter or itself (chaining) if used as setter</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.debugEnabled = <span class="Identifier">function</span>(flag) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isDefined(flag)) <span class="Identifier">{</span>
      debug = flag;
    <span class="Statement">return</span> <span class="Identifier">this</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> debug;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$window'</span>, <span class="Identifier">function</span>($<span class="Statement">window</span>)<span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">{</span>
      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc method</span>
<span class="Comment">       * @name ng.$log#log</span>
<span class="Comment">       * @methodOf ng.$log</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Write a log message</span>
<span class="Comment">       */</span>
      log: consoleLog(<span class="Constant">'log'</span>),

      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc method</span>
<span class="Comment">       * @name ng.$log#info</span>
<span class="Comment">       * @methodOf ng.$log</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Write an information message</span>
<span class="Comment">       */</span>
      info: consoleLog(<span class="Constant">'info'</span>),

      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc method</span>
<span class="Comment">       * @name ng.$log#warn</span>
<span class="Comment">       * @methodOf ng.$log</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Write a warning message</span>
<span class="Comment">       */</span>
      warn: consoleLog(<span class="Constant">'warn'</span>),

      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc method</span>
<span class="Comment">       * @name ng.$log#error</span>
<span class="Comment">       * @methodOf ng.$log</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Write an error message</span>
<span class="Comment">       */</span>
      error: consoleLog(<span class="Constant">'error'</span>),

      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc method</span>
<span class="Comment">       * @name ng.$log#debug</span>
<span class="Comment">       * @methodOf ng.$log</span>
<span class="Comment">       * </span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Write a debug message</span>
<span class="Comment">       */</span>
      debug: (<span class="Identifier">function</span> () <span class="Identifier">{</span>
        <span class="Identifier">var</span> fn = consoleLog(<span class="Constant">'debug'</span>);

        <span class="Statement">return</span> <span class="Identifier">function</span>() <span class="Identifier">{</span>
          <span class="Statement">if</span> (debug) <span class="Identifier">{</span>
            fn.apply(<span class="Statement">self</span>, <span class="Identifier">arguments</span>);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span>())
    <span class="Identifier">}</span>;

    <span class="Identifier">function</span> formatError(arg) <span class="Identifier">{</span>
      <span class="Statement">if</span> (arg <span class="Statement">instanceof</span> Error) <span class="Identifier">{</span>
        <span class="Statement">if</span> (arg.stack) <span class="Identifier">{</span>
          arg = (arg.message &amp;&amp; arg.stack.indexOf(arg.message) === -1)
              ? <span class="Constant">'Error: '</span> + arg.message + <span class="Special">'\n'</span> + arg.stack
              : arg.stack;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (arg.sourceURL) <span class="Identifier">{</span>
          arg = arg.message + <span class="Special">'\n'</span> + arg.sourceURL + <span class="Constant">':'</span> + arg.line;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
      <span class="Statement">return</span> arg;
    <span class="Identifier">}</span>

    <span class="Identifier">function</span> consoleLog(type) <span class="Identifier">{</span>
      <span class="Identifier">var</span> console = $<span class="Statement">window</span>.console || <span class="Identifier">{}</span>,
          logFn = console<span class="Identifier">[</span>type<span class="Identifier">]</span> || console.log || noop;

      <span class="Statement">if</span> (logFn.apply) <span class="Identifier">{</span>
        <span class="Statement">return</span> <span class="Identifier">function</span>() <span class="Identifier">{</span>
          <span class="Identifier">var</span> args = <span class="Identifier">[]</span>;
          forEach(<span class="Identifier">arguments</span>, <span class="Identifier">function</span>(arg) <span class="Identifier">{</span>
            args.push(formatError(arg));
          <span class="Identifier">}</span>);
          <span class="Statement">return</span> logFn.apply(console, args);
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span>

      <span class="Comment">// we are IE which either doesn't have window.console =&gt; this is noop and we do nothing,</span>
      <span class="Comment">// or we are IE where console.log doesn't have apply so we log at least first 2 args</span>
      <span class="Statement">return</span> <span class="Identifier">function</span>(arg1, arg2) <span class="Identifier">{</span>
        logFn(arg1, arg2 == <span class="Statement">null</span> ? <span class="Constant">''</span> : arg2);
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Identifier">var</span> $parseMinErr = minErr(<span class="Constant">'$parse'</span>);
<span class="Identifier">var</span> promiseWarningCache = <span class="Identifier">{}</span>;
<span class="Identifier">var</span> promiseWarning;

<span class="Comment">// Sandboxing Angular Expressions</span>
<span class="Comment">// ------------------------------</span>
<span class="Comment">// Angular expressions are generally considered safe because these expressions only have direct</span>
<span class="Comment">// access to $scope and locals. However, one can obtain the ability to execute arbitrary JS code by</span>
<span class="Comment">// obtaining a reference to native JS functions such as the Function constructor.</span>
<span class="Comment">//</span>
<span class="Comment">// As an example, consider the following Angular expression:</span>
<span class="Comment">//</span>
<span class="Comment">//   {}.toString.constructor(alert(&quot;evil JS code&quot;))</span>
<span class="Comment">//</span>
<span class="Comment">// We want to prevent this type of access. For the sake of performance, during the lexing phase we</span>
<span class="Comment">// disallow any &quot;dotted&quot; access to any member named &quot;constructor&quot;.</span>
<span class="Comment">//</span>
<span class="Comment">// For reflective calls (a[b]) we check that the value of the lookup is not the Function constructor</span>
<span class="Comment">// while evaluating the expression, which is a stronger but more expensive test. Since reflective</span>
<span class="Comment">// calls are expensive anyway, this is not such a big deal compared to static dereferencing.</span>
<span class="Comment">//</span>
<span class="Comment">// This sandboxing technique is not perfect and doesn't aim to be. The goal is to prevent exploits</span>
<span class="Comment">// against the expression language, but not to prevent exploits that were enabled by exposing</span>
<span class="Comment">// sensitive JavaScript or browser apis on Scope. Exposing such objects on a Scope is never a good</span>
<span class="Comment">// practice and therefore we are not even trying to protect against interaction with an object</span>
<span class="Comment">// explicitly exposed in this way.</span>
<span class="Comment">//</span>
<span class="Comment">// A developer could foil the name check by aliasing the Function constructor under a different</span>
<span class="Comment">// name on the scope.</span>
<span class="Comment">//</span>
<span class="Comment">// In general, it is not possible to access a Window object from an angular expression unless a</span>
<span class="Comment">// window or some DOM object that has a reference to window is published onto a Scope.</span>

<span class="Identifier">function</span> ensureSafeMemberName(name, fullExpression) <span class="Identifier">{</span>
  <span class="Statement">if</span> (name === <span class="Constant">&quot;constructor&quot;</span>) <span class="Identifier">{</span>
    <span class="Statement">throw</span> $parseMinErr(<span class="Constant">'isecfld'</span>,
        <span class="Constant">'Referencing &quot;constructor&quot; field in Angular expressions is disallowed! Expression: {0}'</span>,
        fullExpression);
  <span class="Identifier">}</span>
  <span class="Statement">return</span> name;
<span class="Identifier">}</span>

<span class="Identifier">function</span> ensureSafeObject(obj, fullExpression) <span class="Identifier">{</span>
  <span class="Comment">// nifty check if obj is Function that is fast and works across iframes and other contexts</span>
  <span class="Statement">if</span> (obj) <span class="Identifier">{</span>
    <span class="Statement">if</span> (obj.constructor === obj) <span class="Identifier">{</span>
      <span class="Statement">throw</span> $parseMinErr(<span class="Constant">'isecfn'</span>,
          <span class="Constant">'Referencing Function in Angular expressions is disallowed! Expression: {0}'</span>,
          fullExpression);
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Comment">// isWindow(obj)</span>
        obj.<span class="Statement">document</span> &amp;&amp; obj.<span class="Statement">location</span> &amp;&amp; obj.<span class="Statement">alert</span> &amp;&amp; obj.setInterval) <span class="Identifier">{</span>
      <span class="Statement">throw</span> $parseMinErr(<span class="Constant">'isecwindow'</span>,
          <span class="Constant">'Referencing the Window in Angular expressions is disallowed! Expression: {0}'</span>,
          fullExpression);
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Comment">// isElement(obj)</span>
        obj.children &amp;&amp; (obj.nodeName || (obj.on &amp;&amp; obj.find))) <span class="Identifier">{</span>
      <span class="Statement">throw</span> $parseMinErr(<span class="Constant">'isecdom'</span>,
          <span class="Constant">'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}'</span>,
          fullExpression);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>
  <span class="Statement">return</span> obj;
<span class="Identifier">}</span>

<span class="Identifier">var</span> OPERATORS = <span class="Identifier">{</span>
    <span class="Comment">/* jshint bitwise : false */</span>
    <span class="Constant">'null'</span>:<span class="Identifier">function</span>()<span class="Identifier">{</span><span class="Statement">return</span> <span class="Statement">null</span>;<span class="Identifier">}</span>,
    <span class="Constant">'true'</span>:<span class="Identifier">function</span>()<span class="Identifier">{</span><span class="Statement">return</span> <span class="Constant">true</span>;<span class="Identifier">}</span>,
    <span class="Constant">'false'</span>:<span class="Identifier">function</span>()<span class="Identifier">{</span><span class="Statement">return</span> <span class="Constant">false</span>;<span class="Identifier">}</span>,
    <span class="Statement">undefined</span>:noop,
    <span class="Constant">'+'</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span>
      a=a(<span class="Statement">self</span>, locals); b=b(<span class="Statement">self</span>, locals);
      <span class="Statement">if</span> (isDefined(a)) <span class="Identifier">{</span>
        <span class="Statement">if</span> (isDefined(b)) <span class="Identifier">{</span>
          <span class="Statement">return</span> a + b;
        <span class="Identifier">}</span>
        <span class="Statement">return</span> a;
      <span class="Identifier">}</span>
      <span class="Statement">return</span> isDefined(b)?b:<span class="Statement">undefined</span>;<span class="Identifier">}</span>,
    <span class="Constant">'-'</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span>
          a=a(<span class="Statement">self</span>, locals); b=b(<span class="Statement">self</span>, locals);
          <span class="Statement">return</span> (isDefined(a)?a:0)-(isDefined(b)?b:0);
        <span class="Identifier">}</span>,
    <span class="Constant">'*'</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)*b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
    <span class="Constant">'/'</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)/b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
    <span class="Constant">'%'</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)%b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
    <span class="Constant">'^'</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)^b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
    <span class="Constant">'='</span>:noop,
    <span class="Constant">'==='</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a, b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)===b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
    <span class="Constant">'!=='</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a, b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)!==b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
    <span class="Constant">'=='</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)==b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
    <span class="Constant">'!='</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)!=b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
    <span class="Constant">'&lt;'</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)&lt;b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
    <span class="Constant">'&gt;'</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)&gt;b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
    <span class="Constant">'&lt;='</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)&lt;=b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
    <span class="Constant">'&gt;='</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)&gt;=b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
    <span class="Constant">'&amp;&amp;'</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)&amp;&amp;b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
    <span class="Constant">'||'</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)||b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
    <span class="Constant">'&amp;'</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span><span class="Statement">return</span> a(<span class="Statement">self</span>, locals)&amp;b(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>,
<span class="Comment">//    '|':function(self, locals, a,b){return a|b;},</span>
    <span class="Constant">'|'</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a,b)<span class="Identifier">{</span><span class="Statement">return</span> b(<span class="Statement">self</span>, locals)(<span class="Statement">self</span>, locals, a(<span class="Statement">self</span>, locals));<span class="Identifier">}</span>,
    <span class="Constant">'!'</span>:<span class="Identifier">function</span>(<span class="Statement">self</span>, locals, a)<span class="Identifier">{</span><span class="Statement">return</span> !a(<span class="Statement">self</span>, locals);<span class="Identifier">}</span>
<span class="Identifier">}</span>;
<span class="Comment">/* jshint bitwise: true */</span>
<span class="Identifier">var</span> ESCAPE = <span class="Identifier">{</span><span class="Constant">&quot;n&quot;</span>:<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;f&quot;</span>:<span class="Constant">&quot;</span><span class="Special">\f</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;r&quot;</span>:<span class="Constant">&quot;</span><span class="Special">\r</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;t&quot;</span>:<span class="Constant">&quot;</span><span class="Special">\t</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;v&quot;</span>:<span class="Constant">&quot;</span><span class="Special">\v</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;'&quot;</span>:<span class="Constant">&quot;'&quot;</span>, <span class="Constant">'&quot;'</span>:<span class="Constant">'&quot;'</span><span class="Identifier">}</span>;


<span class="Comment">/////////////////////////////////////////</span>


<span class="Comment">/**</span>
<span class="Comment"> * @constructor</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> Lexer = <span class="Identifier">function</span> (options) <span class="Identifier">{</span>
  <span class="Identifier">this</span>.options = options;
<span class="Identifier">}</span>;

Lexer.prototype = <span class="Identifier">{</span>
  constructor: Lexer,

  lex: <span class="Identifier">function</span> (text) <span class="Identifier">{</span>
    <span class="Identifier">this</span>.text = text;

    <span class="Identifier">this</span>.index = 0;
    <span class="Identifier">this</span>.ch = <span class="Statement">undefined</span>;
    <span class="Identifier">this</span>.lastCh = <span class="Constant">':'</span>; <span class="Comment">// can start regexp</span>

    <span class="Identifier">this</span>.tokens = <span class="Identifier">[]</span>;

    <span class="Identifier">var</span> token;
    <span class="Identifier">var</span> json = <span class="Identifier">[]</span>;

    <span class="Statement">while</span> (<span class="Identifier">this</span>.index &lt; <span class="Identifier">this</span>.text.length) <span class="Identifier">{</span>
      <span class="Identifier">this</span>.ch = <span class="Identifier">this</span>.text.charAt(<span class="Identifier">this</span>.index);
      <span class="Statement">if</span> (<span class="Identifier">this</span>.is(<span class="Constant">'&quot;</span><span class="Special">\'</span><span class="Constant">'</span>)) <span class="Identifier">{</span>
        <span class="Identifier">this</span>.readString(<span class="Identifier">this</span>.ch);
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">this</span>.isNumber(<span class="Identifier">this</span>.ch) || <span class="Identifier">this</span>.is(<span class="Constant">'.'</span>) &amp;&amp; <span class="Identifier">this</span>.isNumber(<span class="Identifier">this</span>.peek())) <span class="Identifier">{</span>
        <span class="Identifier">this</span>.readNumber();
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">this</span>.isIdent(<span class="Identifier">this</span>.ch)) <span class="Identifier">{</span>
        <span class="Identifier">this</span>.readIdent();
        <span class="Comment">// identifiers can only be if the preceding char was a { or ,</span>
        <span class="Statement">if</span> (<span class="Identifier">this</span>.was(<span class="Constant">'{,'</span>) &amp;&amp; json<span class="Identifier">[</span>0<span class="Identifier">]</span> === <span class="Constant">'{'</span> &amp;&amp;
            (token = <span class="Identifier">this</span>.tokens<span class="Identifier">[</span><span class="Identifier">this</span>.tokens.length - 1<span class="Identifier">]</span>)) <span class="Identifier">{</span>
          token.json = token.text.indexOf(<span class="Constant">'.'</span>) === -1;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">this</span>.is(<span class="Constant">'(){}[].,;:?'</span>)) <span class="Identifier">{</span>
        <span class="Identifier">this</span>.tokens.push(<span class="Identifier">{</span>
          index: <span class="Identifier">this</span>.index,
          text: <span class="Identifier">this</span>.ch,
          json: (<span class="Identifier">this</span>.was(<span class="Constant">':[,'</span>) &amp;&amp; <span class="Identifier">this</span>.is(<span class="Constant">'{['</span>)) || <span class="Identifier">this</span>.is(<span class="Constant">'}]:,'</span>)
        <span class="Identifier">}</span>);
        <span class="Statement">if</span> (<span class="Identifier">this</span>.is(<span class="Constant">'{['</span>)) json.unshift(<span class="Identifier">this</span>.ch);
        <span class="Statement">if</span> (<span class="Identifier">this</span>.is(<span class="Constant">'}]'</span>)) json.shift();
        <span class="Identifier">this</span>.index++;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">this</span>.isWhitespace(<span class="Identifier">this</span>.ch)) <span class="Identifier">{</span>
        <span class="Identifier">this</span>.index++;
        <span class="Statement">continue</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Identifier">var</span> ch2 = <span class="Identifier">this</span>.ch + <span class="Identifier">this</span>.peek();
        <span class="Identifier">var</span> ch3 = ch2 + <span class="Identifier">this</span>.peek(2);
        <span class="Identifier">var</span> fn = OPERATORS<span class="Identifier">[</span><span class="Identifier">this</span>.ch<span class="Identifier">]</span>;
        <span class="Identifier">var</span> fn2 = OPERATORS<span class="Identifier">[</span>ch2<span class="Identifier">]</span>;
        <span class="Identifier">var</span> fn3 = OPERATORS<span class="Identifier">[</span>ch3<span class="Identifier">]</span>;
        <span class="Statement">if</span> (fn3) <span class="Identifier">{</span>
          <span class="Identifier">this</span>.tokens.push(<span class="Identifier">{</span>index: <span class="Identifier">this</span>.index, text: ch3, fn: fn3<span class="Identifier">}</span>);
          <span class="Identifier">this</span>.index += 3;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (fn2) <span class="Identifier">{</span>
          <span class="Identifier">this</span>.tokens.push(<span class="Identifier">{</span>index: <span class="Identifier">this</span>.index, text: ch2, fn: fn2<span class="Identifier">}</span>);
          <span class="Identifier">this</span>.index += 2;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (fn) <span class="Identifier">{</span>
          <span class="Identifier">this</span>.tokens.push(<span class="Identifier">{</span>
            index: <span class="Identifier">this</span>.index,
            text: <span class="Identifier">this</span>.ch,
            fn: fn,
            json: (<span class="Identifier">this</span>.was(<span class="Constant">'[,:'</span>) &amp;&amp; <span class="Identifier">this</span>.is(<span class="Constant">'+-'</span>))
          <span class="Identifier">}</span>);
          <span class="Identifier">this</span>.index += 1;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          <span class="Identifier">this</span>.throwError(<span class="Constant">'Unexpected next character '</span>, <span class="Identifier">this</span>.index, <span class="Identifier">this</span>.index + 1);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
      <span class="Identifier">this</span>.lastCh = <span class="Identifier">this</span>.ch;
    <span class="Identifier">}</span>
    <span class="Statement">return</span> <span class="Identifier">this</span>.tokens;
  <span class="Identifier">}</span>,

  is: <span class="Identifier">function</span>(chars) <span class="Identifier">{</span>
    <span class="Statement">return</span> chars.indexOf(<span class="Identifier">this</span>.ch) !== -1;
  <span class="Identifier">}</span>,

  was: <span class="Identifier">function</span>(chars) <span class="Identifier">{</span>
    <span class="Statement">return</span> chars.indexOf(<span class="Identifier">this</span>.lastCh) !== -1;
  <span class="Identifier">}</span>,

  peek: <span class="Identifier">function</span>(i) <span class="Identifier">{</span>
    <span class="Identifier">var</span> num = i || 1;
    <span class="Statement">return</span> (<span class="Identifier">this</span>.index + num &lt; <span class="Identifier">this</span>.text.length) ? <span class="Identifier">this</span>.text.charAt(<span class="Identifier">this</span>.index + num) : <span class="Constant">false</span>;
  <span class="Identifier">}</span>,

  isNumber: <span class="Identifier">function</span>(ch) <span class="Identifier">{</span>
    <span class="Statement">return</span> (<span class="Constant">'0'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="Constant">'9'</span>);
  <span class="Identifier">}</span>,

  isWhitespace: <span class="Identifier">function</span>(ch) <span class="Identifier">{</span>
    <span class="Comment">// IE treats non-breaking space as \u00A0</span>
    <span class="Statement">return</span> (ch === <span class="Constant">' '</span> || ch === <span class="Special">'\r'</span> || ch === <span class="Special">'\t'</span> ||
            ch === <span class="Special">'\n'</span> || ch === <span class="Special">'\v'</span> || ch === <span class="Constant">'</span><span class="Special">\u</span><span class="Constant">00A0'</span>);
  <span class="Identifier">}</span>,

  isIdent: <span class="Identifier">function</span>(ch) <span class="Identifier">{</span>
    <span class="Statement">return</span> (<span class="Constant">'a'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="Constant">'z'</span> ||
            <span class="Constant">'A'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="Constant">'Z'</span> ||
            <span class="Constant">'_'</span> === ch || ch === <span class="Constant">'$'</span>);
  <span class="Identifier">}</span>,

  isExpOperator: <span class="Identifier">function</span>(ch) <span class="Identifier">{</span>
    <span class="Statement">return</span> (ch === <span class="Constant">'-'</span> || ch === <span class="Constant">'+'</span> || <span class="Identifier">this</span>.isNumber(ch));
  <span class="Identifier">}</span>,

  throwError: <span class="Identifier">function</span>(error, start, end) <span class="Identifier">{</span>
    end = end || <span class="Identifier">this</span>.index;
    <span class="Identifier">var</span> colStr = (isDefined(start)
            ? <span class="Constant">'s '</span> + start +  <span class="Constant">'-'</span> + <span class="Identifier">this</span>.index + <span class="Constant">' ['</span> + <span class="Identifier">this</span>.text.substring(start, end) + <span class="Constant">']'</span>
            : <span class="Constant">' '</span> + end);
    <span class="Statement">throw</span> $parseMinErr(<span class="Constant">'lexerr'</span>, <span class="Constant">'Lexer Error: {0} at column{1} in expression [{2}].'</span>,
        error, colStr, <span class="Identifier">this</span>.text);
  <span class="Identifier">}</span>,

  readNumber: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> number = <span class="Constant">''</span>;
    <span class="Identifier">var</span> start = <span class="Identifier">this</span>.index;
    <span class="Statement">while</span> (<span class="Identifier">this</span>.index &lt; <span class="Identifier">this</span>.text.length) <span class="Identifier">{</span>
      <span class="Identifier">var</span> ch = lowercase(<span class="Identifier">this</span>.text.charAt(<span class="Identifier">this</span>.index));
      <span class="Statement">if</span> (ch == <span class="Constant">'.'</span> || <span class="Identifier">this</span>.isNumber(ch)) <span class="Identifier">{</span>
        number += ch;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Identifier">var</span> peekCh = <span class="Identifier">this</span>.peek();
        <span class="Statement">if</span> (ch == <span class="Constant">'e'</span> &amp;&amp; <span class="Identifier">this</span>.isExpOperator(peekCh)) <span class="Identifier">{</span>
          number += ch;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">this</span>.isExpOperator(ch) &amp;&amp;
            peekCh &amp;&amp; <span class="Identifier">this</span>.isNumber(peekCh) &amp;&amp;
            number.charAt(number.length - 1) == <span class="Constant">'e'</span>) <span class="Identifier">{</span>
          number += ch;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">this</span>.isExpOperator(ch) &amp;&amp;
            (!peekCh || !<span class="Identifier">this</span>.isNumber(peekCh)) &amp;&amp;
            number.charAt(number.length - 1) == <span class="Constant">'e'</span>) <span class="Identifier">{</span>
          <span class="Identifier">this</span>.throwError(<span class="Constant">'Invalid exponent'</span>);
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          <span class="Statement">break</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
      <span class="Identifier">this</span>.index++;
    <span class="Identifier">}</span>
    number = 1 * number;
    <span class="Identifier">this</span>.tokens.push(<span class="Identifier">{</span>
      index: start,
      text: number,
      json: <span class="Constant">true</span>,
      fn: <span class="Identifier">function</span>() <span class="Identifier">{</span> <span class="Statement">return</span> number; <span class="Identifier">}</span>
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>,

  readIdent: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> parser = <span class="Identifier">this</span>;

    <span class="Identifier">var</span> ident = <span class="Constant">''</span>;
    <span class="Identifier">var</span> start = <span class="Identifier">this</span>.index;

    <span class="Identifier">var</span> lastDot, peekIndex, methodName, ch;

    <span class="Statement">while</span> (<span class="Identifier">this</span>.index &lt; <span class="Identifier">this</span>.text.length) <span class="Identifier">{</span>
      ch = <span class="Identifier">this</span>.text.charAt(<span class="Identifier">this</span>.index);
      <span class="Statement">if</span> (ch === <span class="Constant">'.'</span> || <span class="Identifier">this</span>.isIdent(ch) || <span class="Identifier">this</span>.isNumber(ch)) <span class="Identifier">{</span>
        <span class="Statement">if</span> (ch === <span class="Constant">'.'</span>) lastDot = <span class="Identifier">this</span>.index;
        ident += ch;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">break</span>;
      <span class="Identifier">}</span>
      <span class="Identifier">this</span>.index++;
    <span class="Identifier">}</span>

    <span class="Comment">//check if this is not a method invocation and if it is back out to last dot</span>
    <span class="Statement">if</span> (lastDot) <span class="Identifier">{</span>
      peekIndex = <span class="Identifier">this</span>.index;
      <span class="Statement">while</span> (peekIndex &lt; <span class="Identifier">this</span>.text.length) <span class="Identifier">{</span>
        ch = <span class="Identifier">this</span>.text.charAt(peekIndex);
        <span class="Statement">if</span> (ch === <span class="Constant">'('</span>) <span class="Identifier">{</span>
          methodName = ident.substr(lastDot - start + 1);
          ident = ident.substr(0, lastDot - start);
          <span class="Identifier">this</span>.index = peekIndex;
          <span class="Statement">break</span>;
        <span class="Identifier">}</span>
        <span class="Statement">if</span> (<span class="Identifier">this</span>.isWhitespace(ch)) <span class="Identifier">{</span>
          peekIndex++;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          <span class="Statement">break</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>


    <span class="Identifier">var</span> token = <span class="Identifier">{</span>
      index: start,
      text: ident
    <span class="Identifier">}</span>;

    <span class="Comment">// OPERATORS is our own object so we don't need to use special hasOwnPropertyFn</span>
    <span class="Statement">if</span> (OPERATORS.hasOwnProperty(ident)) <span class="Identifier">{</span>
      token.fn = OPERATORS<span class="Identifier">[</span>ident<span class="Identifier">]</span>;
      token.json = OPERATORS<span class="Identifier">[</span>ident<span class="Identifier">]</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Identifier">var</span> getter = getterFn(ident, <span class="Identifier">this</span>.options, <span class="Identifier">this</span>.text);
      token.fn = extend(<span class="Identifier">function</span>(<span class="Statement">self</span>, locals) <span class="Identifier">{</span>
        <span class="Statement">return</span> (getter(<span class="Statement">self</span>, locals));
      <span class="Identifier">}</span>, <span class="Identifier">{</span>
        assign: <span class="Identifier">function</span>(<span class="Statement">self</span>, value) <span class="Identifier">{</span>
          <span class="Statement">return</span> setter(<span class="Statement">self</span>, ident, value, parser.text, parser.options);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>

    <span class="Identifier">this</span>.tokens.push(token);

    <span class="Statement">if</span> (methodName) <span class="Identifier">{</span>
      <span class="Identifier">this</span>.tokens.push(<span class="Identifier">{</span>
        index:lastDot,
        text: <span class="Constant">'.'</span>,
        json: <span class="Constant">false</span>
      <span class="Identifier">}</span>);
      <span class="Identifier">this</span>.tokens.push(<span class="Identifier">{</span>
        index: lastDot + 1,
        text: methodName,
        json: <span class="Constant">false</span>
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>,

  readString: <span class="Identifier">function</span>(quote) <span class="Identifier">{</span>
    <span class="Identifier">var</span> start = <span class="Identifier">this</span>.index;
    <span class="Identifier">this</span>.index++;
    <span class="Identifier">var</span> string = <span class="Constant">''</span>;
    <span class="Identifier">var</span> rawString = quote;
    <span class="Identifier">var</span> <span class="Statement">escape</span> = <span class="Constant">false</span>;
    <span class="Statement">while</span> (<span class="Identifier">this</span>.index &lt; <span class="Identifier">this</span>.text.length) <span class="Identifier">{</span>
      <span class="Identifier">var</span> ch = <span class="Identifier">this</span>.text.charAt(<span class="Identifier">this</span>.index);
      rawString += ch;
      <span class="Statement">if</span> (<span class="Statement">escape</span>) <span class="Identifier">{</span>
        <span class="Statement">if</span> (ch === <span class="Constant">'u'</span>) <span class="Identifier">{</span>
          <span class="Identifier">var</span> hex = <span class="Identifier">this</span>.text.substring(<span class="Identifier">this</span>.index + 1, <span class="Identifier">this</span>.index + 5);
          <span class="Statement">if</span> (!hex.match(<span class="Constant">/[\da-f]{4}/i</span>))
            <span class="Identifier">this</span>.throwError(<span class="Constant">'Invalid unicode escape [</span><span class="Special">\\</span><span class="Constant">u'</span> + hex + <span class="Constant">']'</span>);
          <span class="Identifier">this</span>.index += 4;
          string += <span class="Type">String</span>.fromCharCode(parseInt(hex, 16));
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          <span class="Identifier">var</span> rep = ESCAPE<span class="Identifier">[</span>ch<span class="Identifier">]</span>;
          <span class="Statement">if</span> (rep) <span class="Identifier">{</span>
            string += rep;
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            string += ch;
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
        <span class="Statement">escape</span> = <span class="Constant">false</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (ch === <span class="Special">'\\'</span>) <span class="Identifier">{</span>
        <span class="Statement">escape</span> = <span class="Constant">true</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (ch === quote) <span class="Identifier">{</span>
        <span class="Identifier">this</span>.index++;
        <span class="Identifier">this</span>.tokens.push(<span class="Identifier">{</span>
          index: start,
          text: rawString,
          string: string,
          json: <span class="Constant">true</span>,
          fn: <span class="Identifier">function</span>() <span class="Identifier">{</span> <span class="Statement">return</span> string; <span class="Identifier">}</span>
        <span class="Identifier">}</span>);
        <span class="Statement">return</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        string += ch;
      <span class="Identifier">}</span>
      <span class="Identifier">this</span>.index++;
    <span class="Identifier">}</span>
    <span class="Identifier">this</span>.throwError(<span class="Constant">'Unterminated quote'</span>, start);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>;


<span class="Comment">/**</span>
<span class="Comment"> * @constructor</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> Parser = <span class="Identifier">function</span> (lexer, $filter, options) <span class="Identifier">{</span>
  <span class="Identifier">this</span>.lexer = lexer;
  <span class="Identifier">this</span>.$filter = $filter;
  <span class="Identifier">this</span>.options = options;
<span class="Identifier">}</span>;

Parser.ZERO = <span class="Identifier">function</span> () <span class="Identifier">{</span> <span class="Statement">return</span> 0; <span class="Identifier">}</span>;

Parser.prototype = <span class="Identifier">{</span>
  constructor: Parser,

  parse: <span class="Identifier">function</span> (text, json) <span class="Identifier">{</span>
    <span class="Identifier">this</span>.text = text;

    <span class="Comment">//</span><span class="Todo">TODO</span><span class="Comment">(i): strip all the obsolte json stuff from this file</span>
    <span class="Identifier">this</span>.json = json;

    <span class="Identifier">this</span>.tokens = <span class="Identifier">this</span>.lexer.lex(text);

    <span class="Statement">if</span> (json) <span class="Identifier">{</span>
      <span class="Comment">// The extra level of aliasing is here, just in case the lexer misses something, so that</span>
      <span class="Comment">// we prevent any accidental execution in JSON.</span>
      <span class="Identifier">this</span>.assignment = <span class="Identifier">this</span>.logicalOR;

      <span class="Identifier">this</span>.functionCall =
      <span class="Identifier">this</span>.fieldAccess =
      <span class="Identifier">this</span>.objectIndex =
      <span class="Identifier">this</span>.filterChain = <span class="Identifier">function</span>() <span class="Identifier">{</span>
        <span class="Identifier">this</span>.throwError(<span class="Constant">'is not valid json'</span>, <span class="Identifier">{</span>text: text, index: 0<span class="Identifier">}</span>);
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>

    <span class="Identifier">var</span> value = json ? <span class="Identifier">this</span>.primary() : <span class="Identifier">this</span>.statements();

    <span class="Statement">if</span> (<span class="Identifier">this</span>.tokens.length !== 0) <span class="Identifier">{</span>
      <span class="Identifier">this</span>.throwError(<span class="Constant">'is an unexpected token'</span>, <span class="Identifier">this</span>.tokens<span class="Identifier">[</span>0<span class="Identifier">]</span>);
    <span class="Identifier">}</span>

    value.literal = !!value.literal;
    value.constant = !!value.constant;

    <span class="Statement">return</span> value;
  <span class="Identifier">}</span>,

  primary: <span class="Identifier">function</span> () <span class="Identifier">{</span>
    <span class="Identifier">var</span> primary;
    <span class="Statement">if</span> (<span class="Identifier">this</span>.expect(<span class="Constant">'('</span>)) <span class="Identifier">{</span>
      primary = <span class="Identifier">this</span>.filterChain();
      <span class="Identifier">this</span>.consume(<span class="Constant">')'</span>);
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">this</span>.expect(<span class="Constant">'['</span>)) <span class="Identifier">{</span>
      primary = <span class="Identifier">this</span>.arrayDeclaration();
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (<span class="Identifier">this</span>.expect(<span class="Constant">'{'</span>)) <span class="Identifier">{</span>
      primary = <span class="Identifier">this</span>.object();
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Identifier">var</span> token = <span class="Identifier">this</span>.expect();
      primary = token.fn;
      <span class="Statement">if</span> (!primary) <span class="Identifier">{</span>
        <span class="Identifier">this</span>.throwError(<span class="Constant">'not a primary expression'</span>, token);
      <span class="Identifier">}</span>
      <span class="Statement">if</span> (token.json) <span class="Identifier">{</span>
        primary.constant = <span class="Constant">true</span>;
        primary.literal = <span class="Constant">true</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Identifier">var</span> next, context;
    <span class="Statement">while</span> ((next = <span class="Identifier">this</span>.expect(<span class="Constant">'('</span>, <span class="Constant">'['</span>, <span class="Constant">'.'</span>))) <span class="Identifier">{</span>
      <span class="Statement">if</span> (next.text === <span class="Constant">'('</span>) <span class="Identifier">{</span>
        primary = <span class="Identifier">this</span>.functionCall(primary, context);
        context = <span class="Statement">null</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (next.text === <span class="Constant">'['</span>) <span class="Identifier">{</span>
        context = primary;
        primary = <span class="Identifier">this</span>.objectIndex(primary);
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (next.text === <span class="Constant">'.'</span>) <span class="Identifier">{</span>
        context = primary;
        primary = <span class="Identifier">this</span>.fieldAccess(primary);
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Identifier">this</span>.throwError(<span class="Constant">'IMPOSSIBLE'</span>);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
    <span class="Statement">return</span> primary;
  <span class="Identifier">}</span>,

  throwError: <span class="Identifier">function</span>(msg, token) <span class="Identifier">{</span>
    <span class="Statement">throw</span> $parseMinErr(<span class="Constant">'syntax'</span>,
        <span class="Constant">'Syntax Error: Token </span><span class="Special">\'</span><span class="Constant">{0}</span><span class="Special">\'</span><span class="Constant"> {1} at column {2} of the expression [{3}] starting at [{4}].'</span>,
          token.text, msg, (token.index + 1), <span class="Identifier">this</span>.text, <span class="Identifier">this</span>.text.substring(token.index));
  <span class="Identifier">}</span>,

  peekToken: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Statement">if</span> (<span class="Identifier">this</span>.tokens.length === 0)
      <span class="Statement">throw</span> $parseMinErr(<span class="Constant">'ueoe'</span>, <span class="Constant">'Unexpected end of expression: {0}'</span>, <span class="Identifier">this</span>.text);
    <span class="Statement">return</span> <span class="Identifier">this</span>.tokens<span class="Identifier">[</span>0<span class="Identifier">]</span>;
  <span class="Identifier">}</span>,

  peek: <span class="Identifier">function</span>(e1, e2, e3, e4) <span class="Identifier">{</span>
    <span class="Statement">if</span> (<span class="Identifier">this</span>.tokens.length &gt; 0) <span class="Identifier">{</span>
      <span class="Identifier">var</span> token = <span class="Identifier">this</span>.tokens<span class="Identifier">[</span>0<span class="Identifier">]</span>;
      <span class="Identifier">var</span> t = token.text;
      <span class="Statement">if</span> (t === e1 || t === e2 || t === e3 || t === e4 ||
          (!e1 &amp;&amp; !e2 &amp;&amp; !e3 &amp;&amp; !e4)) <span class="Identifier">{</span>
        <span class="Statement">return</span> token;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
    <span class="Statement">return</span> <span class="Constant">false</span>;
  <span class="Identifier">}</span>,

  expect: <span class="Identifier">function</span>(e1, e2, e3, e4)<span class="Identifier">{</span>
    <span class="Identifier">var</span> token = <span class="Identifier">this</span>.peek(e1, e2, e3, e4);
    <span class="Statement">if</span> (token) <span class="Identifier">{</span>
      <span class="Statement">if</span> (<span class="Identifier">this</span>.json &amp;&amp; !token.json) <span class="Identifier">{</span>
        <span class="Identifier">this</span>.throwError(<span class="Constant">'is not valid json'</span>, token);
      <span class="Identifier">}</span>
      <span class="Identifier">this</span>.tokens.shift();
      <span class="Statement">return</span> token;
    <span class="Identifier">}</span>
    <span class="Statement">return</span> <span class="Constant">false</span>;
  <span class="Identifier">}</span>,

  consume: <span class="Identifier">function</span>(e1)<span class="Identifier">{</span>
    <span class="Statement">if</span> (!<span class="Identifier">this</span>.expect(e1)) <span class="Identifier">{</span>
      <span class="Identifier">this</span>.throwError(<span class="Constant">'is unexpected, expecting ['</span> + e1 + <span class="Constant">']'</span>, <span class="Identifier">this</span>.peek());
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>,

  unaryFn: <span class="Identifier">function</span>(fn, right) <span class="Identifier">{</span>
    <span class="Statement">return</span> extend(<span class="Identifier">function</span>(<span class="Statement">self</span>, locals) <span class="Identifier">{</span>
      <span class="Statement">return</span> fn(<span class="Statement">self</span>, locals, right);
    <span class="Identifier">}</span>, <span class="Identifier">{</span>
      constant:right.constant
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>,

  ternaryFn: <span class="Identifier">function</span>(left, middle, right)<span class="Identifier">{</span>
    <span class="Statement">return</span> extend(<span class="Identifier">function</span>(<span class="Statement">self</span>, locals)<span class="Identifier">{</span>
      <span class="Statement">return</span> left(<span class="Statement">self</span>, locals) ? middle(<span class="Statement">self</span>, locals) : right(<span class="Statement">self</span>, locals);
    <span class="Identifier">}</span>, <span class="Identifier">{</span>
      constant: left.constant &amp;&amp; middle.constant &amp;&amp; right.constant
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>,

  binaryFn: <span class="Identifier">function</span>(left, fn, right) <span class="Identifier">{</span>
    <span class="Statement">return</span> extend(<span class="Identifier">function</span>(<span class="Statement">self</span>, locals) <span class="Identifier">{</span>
      <span class="Statement">return</span> fn(<span class="Statement">self</span>, locals, left, right);
    <span class="Identifier">}</span>, <span class="Identifier">{</span>
      constant:left.constant &amp;&amp; right.constant
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>,

  statements: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> statements = <span class="Identifier">[]</span>;
    <span class="Statement">while</span> (<span class="Constant">true</span>) <span class="Identifier">{</span>
      <span class="Statement">if</span> (<span class="Identifier">this</span>.tokens.length &gt; 0 &amp;&amp; !<span class="Identifier">this</span>.peek(<span class="Constant">'}'</span>, <span class="Constant">')'</span>, <span class="Constant">';'</span>, <span class="Constant">']'</span>))
        statements.push(<span class="Identifier">this</span>.filterChain());
      <span class="Statement">if</span> (!<span class="Identifier">this</span>.expect(<span class="Constant">';'</span>)) <span class="Identifier">{</span>
        <span class="Comment">// optimize for the common case where there is only one statement.</span>
        <span class="Comment">// </span><span class="Todo">TODO</span><span class="Comment">(size): maybe we should not support multiple statements?</span>
        <span class="Statement">return</span> (statements.length === 1)
            ? statements<span class="Identifier">[</span>0<span class="Identifier">]</span>
            : <span class="Identifier">function</span>(<span class="Statement">self</span>, locals) <span class="Identifier">{</span>
                <span class="Identifier">var</span> value;
                <span class="Statement">for</span> (<span class="Identifier">var</span> i = 0; i &lt; statements.length; i++) <span class="Identifier">{</span>
                  <span class="Identifier">var</span> statement = statements<span class="Identifier">[</span>i<span class="Identifier">]</span>;
                  <span class="Statement">if</span> (statement) <span class="Identifier">{</span>
                    value = statement(<span class="Statement">self</span>, locals);
                  <span class="Identifier">}</span>
                <span class="Identifier">}</span>
                <span class="Statement">return</span> value;
              <span class="Identifier">}</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>,

  filterChain: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> left = <span class="Identifier">this</span>.expression();
    <span class="Identifier">var</span> token;
    <span class="Statement">while</span> (<span class="Constant">true</span>) <span class="Identifier">{</span>
      <span class="Statement">if</span> ((token = <span class="Identifier">this</span>.expect(<span class="Constant">'|'</span>))) <span class="Identifier">{</span>
        left = <span class="Identifier">this</span>.binaryFn(left, token.fn, <span class="Identifier">this</span>.filter());
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">return</span> left;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>,

  filter: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> token = <span class="Identifier">this</span>.expect();
    <span class="Identifier">var</span> fn = <span class="Identifier">this</span>.$filter(token.text);
    <span class="Identifier">var</span> argsFn = <span class="Identifier">[]</span>;
    <span class="Statement">while</span> (<span class="Constant">true</span>) <span class="Identifier">{</span>
      <span class="Statement">if</span> ((token = <span class="Identifier">this</span>.expect(<span class="Constant">':'</span>))) <span class="Identifier">{</span>
        argsFn.push(<span class="Identifier">this</span>.expression());
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Identifier">var</span> fnInvoke = <span class="Identifier">function</span>(<span class="Statement">self</span>, locals, input) <span class="Identifier">{</span>
          <span class="Identifier">var</span> args = <span class="Identifier">[</span>input<span class="Identifier">]</span>;
          <span class="Statement">for</span> (<span class="Identifier">var</span> i = 0; i &lt; argsFn.length; i++) <span class="Identifier">{</span>
            args.push(argsFn<span class="Identifier">[</span>i<span class="Identifier">]</span>(<span class="Statement">self</span>, locals));
          <span class="Identifier">}</span>
          <span class="Statement">return</span> fn.apply(<span class="Statement">self</span>, args);
        <span class="Identifier">}</span>;
        <span class="Statement">return</span> <span class="Identifier">function</span>() <span class="Identifier">{</span>
          <span class="Statement">return</span> fnInvoke;
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>,

  expression: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">this</span>.assignment();
  <span class="Identifier">}</span>,

  assignment: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> left = <span class="Identifier">this</span>.ternary();
    <span class="Identifier">var</span> right;
    <span class="Identifier">var</span> token;
    <span class="Statement">if</span> ((token = <span class="Identifier">this</span>.expect(<span class="Constant">'='</span>))) <span class="Identifier">{</span>
      <span class="Statement">if</span> (!left.assign) <span class="Identifier">{</span>
        <span class="Identifier">this</span>.throwError(<span class="Constant">'implies assignment but ['</span> +
            <span class="Identifier">this</span>.text.substring(0, token.index) + <span class="Constant">'] can not be assigned to'</span>, token);
      <span class="Identifier">}</span>
      right = <span class="Identifier">this</span>.ternary();
      <span class="Statement">return</span> <span class="Identifier">function</span>(scope, locals) <span class="Identifier">{</span>
        <span class="Statement">return</span> left.assign(scope, right(scope, locals), locals);
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>
    <span class="Statement">return</span> left;
  <span class="Identifier">}</span>,

  ternary: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> left = <span class="Identifier">this</span>.logicalOR();
    <span class="Identifier">var</span> middle;
    <span class="Identifier">var</span> token;
    <span class="Statement">if</span> ((token = <span class="Identifier">this</span>.expect(<span class="Constant">'?'</span>))) <span class="Identifier">{</span>
      middle = <span class="Identifier">this</span>.ternary();
      <span class="Statement">if</span> ((token = <span class="Identifier">this</span>.expect(<span class="Constant">':'</span>))) <span class="Identifier">{</span>
        <span class="Statement">return</span> <span class="Identifier">this</span>.ternaryFn(left, middle, <span class="Identifier">this</span>.ternary());
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Identifier">this</span>.throwError(<span class="Constant">'expected :'</span>, token);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> left;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>,

  logicalOR: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> left = <span class="Identifier">this</span>.logicalAND();
    <span class="Identifier">var</span> token;
    <span class="Statement">while</span> (<span class="Constant">true</span>) <span class="Identifier">{</span>
      <span class="Statement">if</span> ((token = <span class="Identifier">this</span>.expect(<span class="Constant">'||'</span>))) <span class="Identifier">{</span>
        left = <span class="Identifier">this</span>.binaryFn(left, token.fn, <span class="Identifier">this</span>.logicalAND());
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">return</span> left;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>,

  logicalAND: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> left = <span class="Identifier">this</span>.equality();
    <span class="Identifier">var</span> token;
    <span class="Statement">if</span> ((token = <span class="Identifier">this</span>.expect(<span class="Constant">'&amp;&amp;'</span>))) <span class="Identifier">{</span>
      left = <span class="Identifier">this</span>.binaryFn(left, token.fn, <span class="Identifier">this</span>.logicalAND());
    <span class="Identifier">}</span>
    <span class="Statement">return</span> left;
  <span class="Identifier">}</span>,

  equality: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> left = <span class="Identifier">this</span>.relational();
    <span class="Identifier">var</span> token;
    <span class="Statement">if</span> ((token = <span class="Identifier">this</span>.expect(<span class="Constant">'=='</span>,<span class="Constant">'!='</span>,<span class="Constant">'==='</span>,<span class="Constant">'!=='</span>))) <span class="Identifier">{</span>
      left = <span class="Identifier">this</span>.binaryFn(left, token.fn, <span class="Identifier">this</span>.equality());
    <span class="Identifier">}</span>
    <span class="Statement">return</span> left;
  <span class="Identifier">}</span>,

  relational: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> left = <span class="Identifier">this</span>.additive();
    <span class="Identifier">var</span> token;
    <span class="Statement">if</span> ((token = <span class="Identifier">this</span>.expect(<span class="Constant">'&lt;'</span>, <span class="Constant">'&gt;'</span>, <span class="Constant">'&lt;='</span>, <span class="Constant">'&gt;='</span>))) <span class="Identifier">{</span>
      left = <span class="Identifier">this</span>.binaryFn(left, token.fn, <span class="Identifier">this</span>.relational());
    <span class="Identifier">}</span>
    <span class="Statement">return</span> left;
  <span class="Identifier">}</span>,

  additive: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> left = <span class="Identifier">this</span>.multiplicative();
    <span class="Identifier">var</span> token;
    <span class="Statement">while</span> ((token = <span class="Identifier">this</span>.expect(<span class="Constant">'+'</span>,<span class="Constant">'-'</span>))) <span class="Identifier">{</span>
      left = <span class="Identifier">this</span>.binaryFn(left, token.fn, <span class="Identifier">this</span>.multiplicative());
    <span class="Identifier">}</span>
    <span class="Statement">return</span> left;
  <span class="Identifier">}</span>,

  multiplicative: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> left = <span class="Identifier">this</span>.unary();
    <span class="Identifier">var</span> token;
    <span class="Statement">while</span> ((token = <span class="Identifier">this</span>.expect(<span class="Constant">'*'</span>,<span class="Constant">'/'</span>,<span class="Constant">'%'</span>))) <span class="Identifier">{</span>
      left = <span class="Identifier">this</span>.binaryFn(left, token.fn, <span class="Identifier">this</span>.unary());
    <span class="Identifier">}</span>
    <span class="Statement">return</span> left;
  <span class="Identifier">}</span>,

  unary: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> token;
    <span class="Statement">if</span> (<span class="Identifier">this</span>.expect(<span class="Constant">'+'</span>)) <span class="Identifier">{</span>
      <span class="Statement">return</span> <span class="Identifier">this</span>.primary();
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> ((token = <span class="Identifier">this</span>.expect(<span class="Constant">'-'</span>))) <span class="Identifier">{</span>
      <span class="Statement">return</span> <span class="Identifier">this</span>.binaryFn(Parser.ZERO, token.fn, <span class="Identifier">this</span>.unary());
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> ((token = <span class="Identifier">this</span>.expect(<span class="Constant">'!'</span>))) <span class="Identifier">{</span>
      <span class="Statement">return</span> <span class="Identifier">this</span>.unaryFn(token.fn, <span class="Identifier">this</span>.unary());
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> <span class="Identifier">this</span>.primary();
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>,

  fieldAccess: <span class="Identifier">function</span>(object) <span class="Identifier">{</span>
    <span class="Identifier">var</span> parser = <span class="Identifier">this</span>;
    <span class="Identifier">var</span> field = <span class="Identifier">this</span>.expect().text;
    <span class="Identifier">var</span> getter = getterFn(field, <span class="Identifier">this</span>.options, <span class="Identifier">this</span>.text);

    <span class="Statement">return</span> extend(<span class="Identifier">function</span>(scope, locals, <span class="Statement">self</span>) <span class="Identifier">{</span>
      <span class="Statement">return</span> getter(<span class="Statement">self</span> || object(scope, locals), locals);
    <span class="Identifier">}</span>, <span class="Identifier">{</span>
      assign: <span class="Identifier">function</span>(scope, value, locals) <span class="Identifier">{</span>
        <span class="Statement">return</span> setter(object(scope, locals), field, value, parser.text, parser.options);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>,

  objectIndex: <span class="Identifier">function</span>(obj) <span class="Identifier">{</span>
    <span class="Identifier">var</span> parser = <span class="Identifier">this</span>;

    <span class="Identifier">var</span> indexFn = <span class="Identifier">this</span>.expression();
    <span class="Identifier">this</span>.consume(<span class="Constant">']'</span>);

    <span class="Statement">return</span> extend(<span class="Identifier">function</span>(<span class="Statement">self</span>, locals) <span class="Identifier">{</span>
      <span class="Identifier">var</span> o = obj(<span class="Statement">self</span>, locals),
          i = indexFn(<span class="Statement">self</span>, locals),
          v, p;

      <span class="Statement">if</span> (!o) <span class="Statement">return</span> <span class="Statement">undefined</span>;
      v = ensureSafeObject(o<span class="Identifier">[</span>i<span class="Identifier">]</span>, parser.text);
      <span class="Statement">if</span> (v &amp;&amp; v.then &amp;&amp; parser.options.unwrapPromises) <span class="Identifier">{</span>
        p = v;
        <span class="Statement">if</span> (!(<span class="Constant">'$$v'</span> <span class="Statement">in</span> v)) <span class="Identifier">{</span>
          p.$$v = <span class="Statement">undefined</span>;
          p.then(<span class="Identifier">function</span>(val) <span class="Identifier">{</span> p.$$v = val; <span class="Identifier">}</span>);
        <span class="Identifier">}</span>
        v = v.$$v;
      <span class="Identifier">}</span>
      <span class="Statement">return</span> v;
    <span class="Identifier">}</span>, <span class="Identifier">{</span>
      assign: <span class="Identifier">function</span>(<span class="Statement">self</span>, value, locals) <span class="Identifier">{</span>
        <span class="Identifier">var</span> key = indexFn(<span class="Statement">self</span>, locals);
        <span class="Comment">// prevent overwriting of Function.constructor which would break ensureSafeObject check</span>
        <span class="Identifier">var</span> safe = ensureSafeObject(obj(<span class="Statement">self</span>, locals), parser.text);
        <span class="Statement">return</span> safe<span class="Identifier">[</span>key<span class="Identifier">]</span> = value;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>,

  functionCall: <span class="Identifier">function</span>(fn, contextGetter) <span class="Identifier">{</span>
    <span class="Identifier">var</span> argsFn = <span class="Identifier">[]</span>;
    <span class="Statement">if</span> (<span class="Identifier">this</span>.peekToken().text !== <span class="Constant">')'</span>) <span class="Identifier">{</span>
      <span class="Statement">do</span> <span class="Identifier">{</span>
        argsFn.push(<span class="Identifier">this</span>.expression());
      <span class="Identifier">}</span> <span class="Statement">while</span> (<span class="Identifier">this</span>.expect(<span class="Constant">','</span>));
    <span class="Identifier">}</span>
    <span class="Identifier">this</span>.consume(<span class="Constant">')'</span>);

    <span class="Identifier">var</span> parser = <span class="Identifier">this</span>;

    <span class="Statement">return</span> <span class="Identifier">function</span>(scope, locals) <span class="Identifier">{</span>
      <span class="Identifier">var</span> args = <span class="Identifier">[]</span>;
      <span class="Identifier">var</span> context = contextGetter ? contextGetter(scope, locals) : scope;

      <span class="Statement">for</span> (<span class="Identifier">var</span> i = 0; i &lt; argsFn.length; i++) <span class="Identifier">{</span>
        args.push(argsFn<span class="Identifier">[</span>i<span class="Identifier">]</span>(scope, locals));
      <span class="Identifier">}</span>
      <span class="Identifier">var</span> fnPtr = fn(scope, locals, context) || noop;

      ensureSafeObject(context, parser.text);
      ensureSafeObject(fnPtr, parser.text);

      <span class="Comment">// IE stupidity! (IE doesn't have apply for some native functions)</span>
      <span class="Identifier">var</span> v = fnPtr.apply
            ? fnPtr.apply(context, args)
            : fnPtr(args<span class="Identifier">[</span>0<span class="Identifier">]</span>, args<span class="Identifier">[</span>1<span class="Identifier">]</span>, args<span class="Identifier">[</span>2<span class="Identifier">]</span>, args<span class="Identifier">[</span>3<span class="Identifier">]</span>, args<span class="Identifier">[</span>4<span class="Identifier">]</span>);

      <span class="Statement">return</span> ensureSafeObject(v, parser.text);
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>,

  <span class="Comment">// This is used with json array declaration</span>
  arrayDeclaration: <span class="Identifier">function</span> () <span class="Identifier">{</span>
    <span class="Identifier">var</span> elementFns = <span class="Identifier">[]</span>;
    <span class="Identifier">var</span> allConstant = <span class="Constant">true</span>;
    <span class="Statement">if</span> (<span class="Identifier">this</span>.peekToken().text !== <span class="Constant">']'</span>) <span class="Identifier">{</span>
      <span class="Statement">do</span> <span class="Identifier">{</span>
        <span class="Identifier">var</span> elementFn = <span class="Identifier">this</span>.expression();
        elementFns.push(elementFn);
        <span class="Statement">if</span> (!elementFn.constant) <span class="Identifier">{</span>
          allConstant = <span class="Constant">false</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span> <span class="Statement">while</span> (<span class="Identifier">this</span>.expect(<span class="Constant">','</span>));
    <span class="Identifier">}</span>
    <span class="Identifier">this</span>.consume(<span class="Constant">']'</span>);

    <span class="Statement">return</span> extend(<span class="Identifier">function</span>(<span class="Statement">self</span>, locals) <span class="Identifier">{</span>
      <span class="Identifier">var</span> array = <span class="Identifier">[]</span>;
      <span class="Statement">for</span> (<span class="Identifier">var</span> i = 0; i &lt; elementFns.length; i++) <span class="Identifier">{</span>
        array.push(elementFns<span class="Identifier">[</span>i<span class="Identifier">]</span>(<span class="Statement">self</span>, locals));
      <span class="Identifier">}</span>
      <span class="Statement">return</span> array;
    <span class="Identifier">}</span>, <span class="Identifier">{</span>
      literal: <span class="Constant">true</span>,
      constant: allConstant
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>,

  object: <span class="Identifier">function</span> () <span class="Identifier">{</span>
    <span class="Identifier">var</span> keyValues = <span class="Identifier">[]</span>;
    <span class="Identifier">var</span> allConstant = <span class="Constant">true</span>;
    <span class="Statement">if</span> (<span class="Identifier">this</span>.peekToken().text !== <span class="Constant">'}'</span>) <span class="Identifier">{</span>
      <span class="Statement">do</span> <span class="Identifier">{</span>
        <span class="Identifier">var</span> token = <span class="Identifier">this</span>.expect(),
        key = token.string || token.text;
        <span class="Identifier">this</span>.consume(<span class="Constant">':'</span>);
        <span class="Identifier">var</span> value = <span class="Identifier">this</span>.expression();
        keyValues.push(<span class="Identifier">{</span>key: key, value: value<span class="Identifier">}</span>);
        <span class="Statement">if</span> (!value.constant) <span class="Identifier">{</span>
          allConstant = <span class="Constant">false</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span> <span class="Statement">while</span> (<span class="Identifier">this</span>.expect(<span class="Constant">','</span>));
    <span class="Identifier">}</span>
    <span class="Identifier">this</span>.consume(<span class="Constant">'}'</span>);

    <span class="Statement">return</span> extend(<span class="Identifier">function</span>(<span class="Statement">self</span>, locals) <span class="Identifier">{</span>
      <span class="Identifier">var</span> object = <span class="Identifier">{}</span>;
      <span class="Statement">for</span> (<span class="Identifier">var</span> i = 0; i &lt; keyValues.length; i++) <span class="Identifier">{</span>
        <span class="Identifier">var</span> keyValue = keyValues<span class="Identifier">[</span>i<span class="Identifier">]</span>;
        object<span class="Identifier">[</span>keyValue.key<span class="Identifier">]</span> = keyValue.value(<span class="Statement">self</span>, locals);
      <span class="Identifier">}</span>
      <span class="Statement">return</span> object;
    <span class="Identifier">}</span>, <span class="Identifier">{</span>
      literal: <span class="Constant">true</span>,
      constant: allConstant
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>;


<span class="Comment">//////////////////////////////////////////////////</span>
<span class="Comment">// Parser helper functions</span>
<span class="Comment">//////////////////////////////////////////////////</span>

<span class="Identifier">function</span> setter(obj, path, setValue, fullExp, options) <span class="Identifier">{</span>
  <span class="Comment">//needed?</span>
  options = options || <span class="Identifier">{}</span>;

  <span class="Identifier">var</span> element = path.split(<span class="Constant">'.'</span>), key;
  <span class="Statement">for</span> (<span class="Identifier">var</span> i = 0; element.length &gt; 1; i++) <span class="Identifier">{</span>
    key = ensureSafeMemberName(element.shift(), fullExp);
    <span class="Identifier">var</span> propertyObj = obj<span class="Identifier">[</span>key<span class="Identifier">]</span>;
    <span class="Statement">if</span> (!propertyObj) <span class="Identifier">{</span>
      propertyObj = <span class="Identifier">{}</span>;
      obj<span class="Identifier">[</span>key<span class="Identifier">]</span> = propertyObj;
    <span class="Identifier">}</span>
    obj = propertyObj;
    <span class="Statement">if</span> (obj.then &amp;&amp; options.unwrapPromises) <span class="Identifier">{</span>
      promiseWarning(fullExp);
      <span class="Statement">if</span> (!(<span class="Constant">&quot;$$v&quot;</span> <span class="Statement">in</span> obj)) <span class="Identifier">{</span>
        (<span class="Identifier">function</span>(promise) <span class="Identifier">{</span>
          promise.then(<span class="Identifier">function</span>(val) <span class="Identifier">{</span> promise.$$v = val; <span class="Identifier">}</span>); <span class="Identifier">}</span>
        )(obj);
      <span class="Identifier">}</span>
      <span class="Statement">if</span> (obj.$$v === <span class="Statement">undefined</span>) <span class="Identifier">{</span>
        obj.$$v = <span class="Identifier">{}</span>;
      <span class="Identifier">}</span>
      obj = obj.$$v;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>
  key = ensureSafeMemberName(element.shift(), fullExp);
  obj<span class="Identifier">[</span>key<span class="Identifier">]</span> = setValue;
  <span class="Statement">return</span> setValue;
<span class="Identifier">}</span>

<span class="Identifier">var</span> getterFnCache = <span class="Identifier">{}</span>;

<span class="Comment">/**</span>
<span class="Comment"> * Implementation of the &quot;Black Hole&quot; variant from:</span>
<span class="Comment"> * - <a href="http://jsperf.com/angularjs-parse-getter/4">http://jsperf.com/angularjs-parse-getter/4</a></span>
<span class="Comment"> * - <a href="http://jsperf.com/path-evaluation-simplified/7">http://jsperf.com/path-evaluation-simplified/7</a></span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, options) <span class="Identifier">{</span>
  ensureSafeMemberName(key0, fullExp);
  ensureSafeMemberName(key1, fullExp);
  ensureSafeMemberName(key2, fullExp);
  ensureSafeMemberName(key3, fullExp);
  ensureSafeMemberName(key4, fullExp);

  <span class="Statement">return</span> !options.unwrapPromises
      ? <span class="Identifier">function</span> cspSafeGetter(scope, locals) <span class="Identifier">{</span>
          <span class="Identifier">var</span> pathVal = (locals &amp;&amp; locals.hasOwnProperty(key0)) ? locals : scope;

          <span class="Statement">if</span> (pathVal === <span class="Statement">null</span> || pathVal === <span class="Statement">undefined</span>) <span class="Statement">return</span> pathVal;
          pathVal = pathVal<span class="Identifier">[</span>key0<span class="Identifier">]</span>;

          <span class="Statement">if</span> (!key1 || pathVal === <span class="Statement">null</span> || pathVal === <span class="Statement">undefined</span>) <span class="Statement">return</span> pathVal;
          pathVal = pathVal<span class="Identifier">[</span>key1<span class="Identifier">]</span>;

          <span class="Statement">if</span> (!key2 || pathVal === <span class="Statement">null</span> || pathVal === <span class="Statement">undefined</span>) <span class="Statement">return</span> pathVal;
          pathVal = pathVal<span class="Identifier">[</span>key2<span class="Identifier">]</span>;

          <span class="Statement">if</span> (!key3 || pathVal === <span class="Statement">null</span> || pathVal === <span class="Statement">undefined</span>) <span class="Statement">return</span> pathVal;
          pathVal = pathVal<span class="Identifier">[</span>key3<span class="Identifier">]</span>;

          <span class="Statement">if</span> (!key4 || pathVal === <span class="Statement">null</span> || pathVal === <span class="Statement">undefined</span>) <span class="Statement">return</span> pathVal;
          pathVal = pathVal<span class="Identifier">[</span>key4<span class="Identifier">]</span>;

          <span class="Statement">return</span> pathVal;
        <span class="Identifier">}</span>
      : <span class="Identifier">function</span> cspSafePromiseEnabledGetter(scope, locals) <span class="Identifier">{</span>
          <span class="Identifier">var</span> pathVal = (locals &amp;&amp; locals.hasOwnProperty(key0)) ? locals : scope,
              promise;

          <span class="Statement">if</span> (pathVal === <span class="Statement">null</span> || pathVal === <span class="Statement">undefined</span>) <span class="Statement">return</span> pathVal;

          pathVal = pathVal<span class="Identifier">[</span>key0<span class="Identifier">]</span>;
          <span class="Statement">if</span> (pathVal &amp;&amp; pathVal.then) <span class="Identifier">{</span>
            promiseWarning(fullExp);
            <span class="Statement">if</span> (!(<span class="Constant">&quot;$$v&quot;</span> <span class="Statement">in</span> pathVal)) <span class="Identifier">{</span>
              promise = pathVal;
              promise.$$v = <span class="Statement">undefined</span>;
              promise.then(<span class="Identifier">function</span>(val) <span class="Identifier">{</span> promise.$$v = val; <span class="Identifier">}</span>);
            <span class="Identifier">}</span>
            pathVal = pathVal.$$v;
          <span class="Identifier">}</span>
          <span class="Statement">if</span> (!key1 || pathVal === <span class="Statement">null</span> || pathVal === <span class="Statement">undefined</span>) <span class="Statement">return</span> pathVal;

          pathVal = pathVal<span class="Identifier">[</span>key1<span class="Identifier">]</span>;
          <span class="Statement">if</span> (pathVal &amp;&amp; pathVal.then) <span class="Identifier">{</span>
            promiseWarning(fullExp);
            <span class="Statement">if</span> (!(<span class="Constant">&quot;$$v&quot;</span> <span class="Statement">in</span> pathVal)) <span class="Identifier">{</span>
              promise = pathVal;
              promise.$$v = <span class="Statement">undefined</span>;
              promise.then(<span class="Identifier">function</span>(val) <span class="Identifier">{</span> promise.$$v = val; <span class="Identifier">}</span>);
            <span class="Identifier">}</span>
            pathVal = pathVal.$$v;
          <span class="Identifier">}</span>
          <span class="Statement">if</span> (!key2 || pathVal === <span class="Statement">null</span> || pathVal === <span class="Statement">undefined</span>) <span class="Statement">return</span> pathVal;

          pathVal = pathVal<span class="Identifier">[</span>key2<span class="Identifier">]</span>;
          <span class="Statement">if</span> (pathVal &amp;&amp; pathVal.then) <span class="Identifier">{</span>
            promiseWarning(fullExp);
            <span class="Statement">if</span> (!(<span class="Constant">&quot;$$v&quot;</span> <span class="Statement">in</span> pathVal)) <span class="Identifier">{</span>
              promise = pathVal;
              promise.$$v = <span class="Statement">undefined</span>;
              promise.then(<span class="Identifier">function</span>(val) <span class="Identifier">{</span> promise.$$v = val; <span class="Identifier">}</span>);
            <span class="Identifier">}</span>
            pathVal = pathVal.$$v;
          <span class="Identifier">}</span>
          <span class="Statement">if</span> (!key3 || pathVal === <span class="Statement">null</span> || pathVal === <span class="Statement">undefined</span>) <span class="Statement">return</span> pathVal;

          pathVal = pathVal<span class="Identifier">[</span>key3<span class="Identifier">]</span>;
          <span class="Statement">if</span> (pathVal &amp;&amp; pathVal.then) <span class="Identifier">{</span>
            promiseWarning(fullExp);
            <span class="Statement">if</span> (!(<span class="Constant">&quot;$$v&quot;</span> <span class="Statement">in</span> pathVal)) <span class="Identifier">{</span>
              promise = pathVal;
              promise.$$v = <span class="Statement">undefined</span>;
              promise.then(<span class="Identifier">function</span>(val) <span class="Identifier">{</span> promise.$$v = val; <span class="Identifier">}</span>);
            <span class="Identifier">}</span>
            pathVal = pathVal.$$v;
          <span class="Identifier">}</span>
          <span class="Statement">if</span> (!key4 || pathVal === <span class="Statement">null</span> || pathVal === <span class="Statement">undefined</span>) <span class="Statement">return</span> pathVal;

          pathVal = pathVal<span class="Identifier">[</span>key4<span class="Identifier">]</span>;
          <span class="Statement">if</span> (pathVal &amp;&amp; pathVal.then) <span class="Identifier">{</span>
            promiseWarning(fullExp);
            <span class="Statement">if</span> (!(<span class="Constant">&quot;$$v&quot;</span> <span class="Statement">in</span> pathVal)) <span class="Identifier">{</span>
              promise = pathVal;
              promise.$$v = <span class="Statement">undefined</span>;
              promise.then(<span class="Identifier">function</span>(val) <span class="Identifier">{</span> promise.$$v = val; <span class="Identifier">}</span>);
            <span class="Identifier">}</span>
            pathVal = pathVal.$$v;
          <span class="Identifier">}</span>
          <span class="Statement">return</span> pathVal;
        <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Identifier">function</span> getterFn(path, options, fullExp) <span class="Identifier">{</span>
  <span class="Comment">// Check whether the cache has this getter already.</span>
  <span class="Comment">// We can use hasOwnProperty directly on the cache because we ensure,</span>
  <span class="Comment">// see below, that the cache never stores a path called 'hasOwnProperty'</span>
  <span class="Statement">if</span> (getterFnCache.hasOwnProperty(path)) <span class="Identifier">{</span>
    <span class="Statement">return</span> getterFnCache<span class="Identifier">[</span>path<span class="Identifier">]</span>;
  <span class="Identifier">}</span>

  <span class="Identifier">var</span> pathKeys = path.split(<span class="Constant">'.'</span>),
      pathKeysLength = pathKeys.length,
      fn;

  <span class="Statement">if</span> (options.csp) <span class="Identifier">{</span>
    <span class="Statement">if</span> (pathKeysLength &lt; 6) <span class="Identifier">{</span>
      fn = cspSafeGetterFn(pathKeys<span class="Identifier">[</span>0<span class="Identifier">]</span>, pathKeys<span class="Identifier">[</span>1<span class="Identifier">]</span>, pathKeys<span class="Identifier">[</span>2<span class="Identifier">]</span>, pathKeys<span class="Identifier">[</span>3<span class="Identifier">]</span>, pathKeys<span class="Identifier">[</span>4<span class="Identifier">]</span>, fullExp,
                          options);
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      fn = <span class="Identifier">function</span>(scope, locals) <span class="Identifier">{</span>
        <span class="Identifier">var</span> i = 0, val;
        <span class="Statement">do</span> <span class="Identifier">{</span>
          val = cspSafeGetterFn(pathKeys<span class="Identifier">[</span>i++<span class="Identifier">]</span>, pathKeys<span class="Identifier">[</span>i++<span class="Identifier">]</span>, pathKeys<span class="Identifier">[</span>i++<span class="Identifier">]</span>, pathKeys<span class="Identifier">[</span>i++<span class="Identifier">]</span>,
                                pathKeys<span class="Identifier">[</span>i++<span class="Identifier">]</span>, fullExp, options)(scope, locals);

          locals = <span class="Statement">undefined</span>; <span class="Comment">// clear after first iteration</span>
          scope = val;
        <span class="Identifier">}</span> <span class="Statement">while</span> (i &lt; pathKeysLength);
        <span class="Statement">return</span> val;
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
    <span class="Identifier">var</span> code = <span class="Constant">'var l, fn, p;</span><span class="Special">\n</span><span class="Constant">'</span>;
    forEach(pathKeys, <span class="Identifier">function</span>(key, index) <span class="Identifier">{</span>
      ensureSafeMemberName(key, fullExp);
      code += <span class="Constant">'if(s === null || s === undefined) return s;</span><span class="Special">\n</span><span class="Constant">'</span> +
              <span class="Constant">'l=s;</span><span class="Special">\n</span><span class="Constant">'</span> +
              <span class="Constant">'s='</span>+ (index
                      <span class="Comment">// we simply dereference 's' on any .dot notation</span>
                      ? <span class="Constant">'s'</span>
                      <span class="Comment">// but if we are first then we check locals first, and if so read it first</span>
                      : <span class="Constant">'((k&amp;&amp;k.hasOwnProperty(&quot;'</span> + key + <span class="Constant">'&quot;))?k:s)'</span>) + <span class="Constant">'[&quot;'</span> + key + <span class="Constant">'&quot;]'</span> + <span class="Constant">';</span><span class="Special">\n</span><span class="Constant">'</span> +
              (options.unwrapPromises
                ? <span class="Constant">'if (s &amp;&amp; s.then) {</span><span class="Special">\n</span><span class="Constant">'</span> +
                  <span class="Constant">' pw(&quot;'</span> + fullExp.replace(<span class="Constant">/([&quot;\r\n])/g</span>, <span class="Constant">'</span><span class="Special">\\</span><span class="Constant">$1'</span>) + <span class="Constant">'&quot;);</span><span class="Special">\n</span><span class="Constant">'</span> +
                  <span class="Constant">' if (!(&quot;$$v&quot; in s)) {</span><span class="Special">\n</span><span class="Constant">'</span> +
                    <span class="Constant">' p=s;</span><span class="Special">\n</span><span class="Constant">'</span> +
                    <span class="Constant">' p.$$v = undefined;</span><span class="Special">\n</span><span class="Constant">'</span> +
                    <span class="Constant">' p.then(function(v) {p.$$v=v;});</span><span class="Special">\n</span><span class="Constant">'</span> +
                    <span class="Constant">'}</span><span class="Special">\n</span><span class="Constant">'</span> +
                  <span class="Constant">' s=s.$$v</span><span class="Special">\n</span><span class="Constant">'</span> +
                <span class="Constant">'}</span><span class="Special">\n</span><span class="Constant">'</span>
                : <span class="Constant">''</span>);
    <span class="Identifier">}</span>);
    code += <span class="Constant">'return s;'</span>;

    <span class="Comment">/* jshint -W054 */</span>
    <span class="Identifier">var</span> evaledFnGetter = <span class="Statement">new</span> <span class="Type">Function</span>(<span class="Constant">'s'</span>, <span class="Constant">'k'</span>, <span class="Constant">'pw'</span>, code); <span class="Comment">// s=scope, k=locals, pw=promiseWarning</span>
    <span class="Comment">/* jshint +W054 */</span>
    evaledFnGetter.toString = <span class="Identifier">function</span>() <span class="Identifier">{</span> <span class="Statement">return</span> code; <span class="Identifier">}</span>;
    fn = <span class="Identifier">function</span>(scope, locals) <span class="Identifier">{</span>
      <span class="Statement">return</span> evaledFnGetter(scope, locals, promiseWarning);
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>

  <span class="Comment">// Only cache the value if it's not going to mess up the cache object</span>
  <span class="Comment">// This is more performant that using Object.prototype.hasOwnProperty.call</span>
  <span class="Statement">if</span> (path !== <span class="Constant">'hasOwnProperty'</span>) <span class="Identifier">{</span>
    getterFnCache<span class="Identifier">[</span>path<span class="Identifier">]</span> = fn;
  <span class="Identifier">}</span>
  <span class="Statement">return</span> fn;
<span class="Identifier">}</span>

<span class="Comment">///////////////////////////////////</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name ng.$parse</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Converts Angular {@link guide/expression expression} into a function.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   var getter = $parse('user.name');</span>
<span class="Comment"> *   var setter = getter.assign;</span>
<span class="Comment"> *   var context = {user:{name:'angular'}};</span>
<span class="Comment"> *   var locals = {user:{name:'local'}};</span>
<span class="Comment"> *</span>
<span class="Comment"> *   expect(getter(context)).toEqual('angular');</span>
<span class="Comment"> *   setter(context, 'newValue');</span>
<span class="Comment"> *   expect(context.user.name).toEqual('newValue');</span>
<span class="Comment"> *   expect(getter(context, locals)).toEqual('local');</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} expression String expression to compile.</span>
<span class="Comment"> * @returns {function(context, locals)} a function which represents the compiled expression:</span>
<span class="Comment"> *</span>
<span class="Comment"> *    * `context` – `{object}` – an object against which any expressions embedded in the strings</span>
<span class="Comment"> *      are evaluated against (typically a scope object).</span>
<span class="Comment"> *    * `locals` – `{object=}` – local variables context object, useful for overriding values in</span>
<span class="Comment"> *      `context`.</span>
<span class="Comment"> *</span>
<span class="Comment"> *    The returned function also has the following properties:</span>
<span class="Comment"> *      * `literal` – `{boolean}` – whether the expression's top-level node is a JavaScript</span>
<span class="Comment"> *        literal.</span>
<span class="Comment"> *      * `constant` – `{boolean}` – whether the expression is made entirely of JavaScript</span>
<span class="Comment"> *        constant literals.</span>
<span class="Comment"> *      * `assign` – `{?function(context, value)}` – if the expression is assignable, this will be</span>
<span class="Comment"> *        set to a function to change its value on the given context.</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$parseProvider</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}</span>
<span class="Comment"> *  service.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $ParseProvider() <span class="Identifier">{</span>
  <span class="Identifier">var</span> cache = <span class="Identifier">{}</span>;

  <span class="Identifier">var</span> $parseOptions = <span class="Identifier">{</span>
    csp: <span class="Constant">false</span>,
    unwrapPromises: <span class="Constant">false</span>,
    logPromiseWarnings: <span class="Constant">true</span>
  <span class="Identifier">}</span>;


  <span class="Comment">/**</span>
<span class="Comment">   * @deprecated Promise unwrapping via $parse is deprecated and will be removed in the future.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$parseProvider#unwrapPromises</span>
<span class="Comment">   * @methodOf ng.$parseProvider</span>
<span class="Comment">   * @description</span>
<span class="Comment">   *</span>
<span class="Comment">   * **This feature is deprecated, see deprecation notes below for more info**</span>
<span class="Comment">   *</span>
<span class="Comment">   * If set to true (default is false), $parse will unwrap promises automatically when a promise is</span>
<span class="Comment">   * found at any part of the expression. In other words, if set to true, the expression will always</span>
<span class="Comment">   * result in a non-promise value.</span>
<span class="Comment">   *</span>
<span class="Comment">   * While the promise is unresolved, it's treated as undefined, but once resolved and fulfilled,</span>
<span class="Comment">   * the fulfillment value is used in place of the promise while evaluating the expression.</span>
<span class="Comment">   *</span>
<span class="Comment">   * **Deprecation notice**</span>
<span class="Comment">   *</span>
<span class="Comment">   * This is a feature that didn't prove to be wildly useful or popular, primarily because of the</span>
<span class="Comment">   * dichotomy between data access in templates (accessed as raw values) and controller code</span>
<span class="Comment">   * (accessed as promises).</span>
<span class="Comment">   *</span>
<span class="Comment">   * In most code we ended up resolving promises manually in controllers anyway and thus unifying</span>
<span class="Comment">   * the model access there.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Other downsides of automatic promise unwrapping:</span>
<span class="Comment">   *</span>
<span class="Comment">   * - when building components it's often desirable to receive the raw promises</span>
<span class="Comment">   * - adds complexity and slows down expression evaluation</span>
<span class="Comment">   * - makes expression code pre-generation unattractive due to the amount of code that needs to be</span>
<span class="Comment">   *   generated</span>
<span class="Comment">   * - makes IDE auto-completion and tool support hard</span>
<span class="Comment">   *</span>
<span class="Comment">   * **Warning Logs**</span>
<span class="Comment">   *</span>
<span class="Comment">   * If the unwrapping is enabled, Angular will log a warning about each expression that unwraps a</span>
<span class="Comment">   * promise (to reduce the noise, each expression is logged only once). To disable this logging use</span>
<span class="Comment">   * `$parseProvider.logPromiseWarnings(false)` api.</span>
<span class="Comment">   *</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {boolean=} value New value.</span>
<span class="Comment">   * @returns {boolean|self} Returns the current setting when used as getter and self if used as</span>
<span class="Comment">   *                         setter.</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.unwrapPromises = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isDefined(value)) <span class="Identifier">{</span>
      $parseOptions.unwrapPromises = !!value;
      <span class="Statement">return</span> <span class="Identifier">this</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> $parseOptions.unwrapPromises;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;


  <span class="Comment">/**</span>
<span class="Comment">   * @deprecated Promise unwrapping via $parse is deprecated and will be removed in the future.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @ngdoc method</span>
<span class="Comment">   * @name ng.$parseProvider#logPromiseWarnings</span>
<span class="Comment">   * @methodOf ng.$parseProvider</span>
<span class="Comment">   * @description</span>
<span class="Comment">   *</span>
<span class="Comment">   * Controls whether Angular should log a warning on any encounter of a promise in an expression.</span>
<span class="Comment">   *</span>
<span class="Comment">   * The default is set to `true`.</span>
<span class="Comment">   *</span>
<span class="Comment">   * This setting applies only if `$parseProvider.unwrapPromises` setting is set to true as well.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {boolean=} value New value.</span>
<span class="Comment">   * @returns {boolean|self} Returns the current setting when used as getter and self if used as</span>
<span class="Comment">   *                         setter.</span>
<span class="Comment">   */</span>
 <span class="Identifier">this</span>.logPromiseWarnings = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isDefined(value)) <span class="Identifier">{</span>
      $parseOptions.logPromiseWarnings = value;
      <span class="Statement">return</span> <span class="Identifier">this</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> $parseOptions.logPromiseWarnings;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;


  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$filter'</span>, <span class="Constant">'$sniffer'</span>, <span class="Constant">'$log'</span>, <span class="Identifier">function</span>($filter, $sniffer, $log) <span class="Identifier">{</span>
    $parseOptions.csp = $sniffer.csp;

    promiseWarning = <span class="Identifier">function</span> promiseWarningFn(fullExp) <span class="Identifier">{</span>
      <span class="Statement">if</span> (!$parseOptions.logPromiseWarnings || promiseWarningCache.hasOwnProperty(fullExp)) <span class="Statement">return</span>;
      promiseWarningCache<span class="Identifier">[</span>fullExp<span class="Identifier">]</span> = <span class="Constant">true</span>;
      $log.warn(<span class="Constant">'[$parse] Promise found in the expression `'</span> + fullExp + <span class="Constant">'`. '</span> +
          <span class="Constant">'Automatic unwrapping of promises in Angular expressions is deprecated.'</span>);
    <span class="Identifier">}</span>;

    <span class="Statement">return</span> <span class="Identifier">function</span>(exp) <span class="Identifier">{</span>
      <span class="Identifier">var</span> parsedExpression;

      <span class="Statement">switch</span> (<span class="Statement">typeof</span> exp) <span class="Identifier">{</span>
        <span class="Statement">case</span> <span class="Constant">'string'</span>:

          <span class="Statement">if</span> (cache.hasOwnProperty(exp)) <span class="Identifier">{</span>
            <span class="Statement">return</span> cache<span class="Identifier">[</span>exp<span class="Identifier">]</span>;
          <span class="Identifier">}</span>

          <span class="Identifier">var</span> lexer = <span class="Statement">new</span> Lexer($parseOptions);
          <span class="Identifier">var</span> parser = <span class="Statement">new</span> Parser(lexer, $filter, $parseOptions);
          parsedExpression = parser.parse(exp, <span class="Constant">false</span>);

          <span class="Statement">if</span> (exp !== <span class="Constant">'hasOwnProperty'</span>) <span class="Identifier">{</span>
            <span class="Comment">// Only cache the value if it's not going to mess up the cache object</span>
            <span class="Comment">// This is more performant that using Object.prototype.hasOwnProperty.call</span>
            cache<span class="Identifier">[</span>exp<span class="Identifier">]</span> = parsedExpression;
          <span class="Identifier">}</span>

          <span class="Statement">return</span> parsedExpression;

        <span class="Statement">case</span> <span class="Constant">'function'</span>:
          <span class="Statement">return</span> exp;

        <span class="Statement">default</span>:
          <span class="Statement">return</span> noop;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc service</span>
<span class="Comment"> * @name ng.$q</span>
<span class="Comment"> * @requires $rootScope</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * A promise/deferred implementation inspired by [Kris Kowal's Q](<a href="https://github.com/kriskowal/q).">https://github.com/kriskowal/q).</a></span>
<span class="Comment"> *</span>
<span class="Comment"> * [The CommonJS Promise proposal](<a href="http://wiki.commonjs.org/wiki/Promises)">http://wiki.commonjs.org/wiki/Promises)</a> describes a promise as an</span>
<span class="Comment"> * interface for interacting with an object that represents the result of an action that is</span>
<span class="Comment"> * performed asynchronously, and may or may not be finished at any given point in time.</span>
<span class="Comment"> *</span>
<span class="Comment"> * From the perspective of dealing with error handling, deferred and promise APIs are to</span>
<span class="Comment"> * asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   // for the purpose of this example let's assume that variables `$q` and `scope` are</span>
<span class="Comment"> *   // available in the current lexical scope (they could have been injected or passed in).</span>
<span class="Comment"> *</span>
<span class="Comment"> *   function asyncGreet(name) {</span>
<span class="Comment"> *     var deferred = $q.defer();</span>
<span class="Comment"> *</span>
<span class="Comment"> *     setTimeout(function() {</span>
<span class="Comment"> *       // since this fn executes async in a future turn of the event loop, we need to wrap</span>
<span class="Comment"> *       // our code into an $apply call so that the model changes are properly observed.</span>
<span class="Comment"> *       scope.$apply(function() {</span>
<span class="Comment"> *         deferred.notify('About to greet ' + name + '.');</span>
<span class="Comment"> *</span>
<span class="Comment"> *         if (okToGreet(name)) {</span>
<span class="Comment"> *           deferred.resolve('Hello, ' + name + '!');</span>
<span class="Comment"> *         } else {</span>
<span class="Comment"> *           deferred.reject('Greeting ' + name + ' is not allowed.');</span>
<span class="Comment"> *         }</span>
<span class="Comment"> *       });</span>
<span class="Comment"> *     }, 1000);</span>
<span class="Comment"> *</span>
<span class="Comment"> *     return deferred.promise;</span>
<span class="Comment"> *   }</span>
<span class="Comment"> *</span>
<span class="Comment"> *   var promise = asyncGreet('Robin Hood');</span>
<span class="Comment"> *   promise.then(function(greeting) {</span>
<span class="Comment"> *     alert('Success: ' + greeting);</span>
<span class="Comment"> *   }, function(reason) {</span>
<span class="Comment"> *     alert('Failed: ' + reason);</span>
<span class="Comment"> *   }, function(update) {</span>
<span class="Comment"> *     alert('Got notification: ' + update);</span>
<span class="Comment"> *   });</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * At first it might not be obvious why this extra complexity is worth the trouble. The payoff</span>
<span class="Comment"> * comes in the way of guarantees that promise and deferred APIs make, see</span>
<span class="Comment"> * <a href="https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md.">https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md.</a></span>
<span class="Comment"> *</span>
<span class="Comment"> * Additionally the promise api allows for composition that is very hard to do with the</span>
<span class="Comment"> * traditional callback ([CPS](<a href="http://en.wikipedia.org/wiki/Continuation-passing_style))">http://en.wikipedia.org/wiki/Continuation-passing_style))</a> approach.</span>
<span class="Comment"> * For more on this please see the [Q documentation](<a href="https://github.com/kriskowal/q)">https://github.com/kriskowal/q)</a> especially the</span>
<span class="Comment"> * section on serial or parallel joining of promises.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * # The Deferred API</span>
<span class="Comment"> *</span>
<span class="Comment"> * A new instance of deferred is constructed by calling `$q.defer()`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The purpose of the deferred object is to expose the associated Promise instance as well as APIs</span>
<span class="Comment"> * that can be used for signaling the successful or unsuccessful completion, as well as the status</span>
<span class="Comment"> * of the task.</span>
<span class="Comment"> *</span>
<span class="Comment"> * **Methods**</span>
<span class="Comment"> *</span>
<span class="Comment"> * - `resolve(value)` – resolves the derived promise with the `value`. If the value is a rejection</span>
<span class="Comment"> *   constructed via `$q.reject`, the promise will be rejected instead.</span>
<span class="Comment"> * - `reject(reason)` – rejects the derived promise with the `reason`. This is equivalent to</span>
<span class="Comment"> *   resolving it with a rejection constructed via `$q.reject`.</span>
<span class="Comment"> * - `notify(value)` - provides updates on the status of the promises execution. This may be called</span>
<span class="Comment"> *   multiple times before the promise is either resolved or rejected.</span>
<span class="Comment"> *</span>
<span class="Comment"> * **Properties**</span>
<span class="Comment"> *</span>
<span class="Comment"> * - promise – `{Promise}` – promise object associated with this deferred.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * # The Promise API</span>
<span class="Comment"> *</span>
<span class="Comment"> * A new promise instance is created when a deferred instance is created and can be retrieved by</span>
<span class="Comment"> * calling `deferred.promise`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The purpose of the promise object is to allow for interested parties to get access to the result</span>
<span class="Comment"> * of the deferred task when it completes.</span>
<span class="Comment"> *</span>
<span class="Comment"> * **Methods**</span>
<span class="Comment"> *</span>
<span class="Comment"> * - `then(successCallback, errorCallback, notifyCallback)` – regardless of when the promise was or</span>
<span class="Comment"> *   will be resolved or rejected, `then` calls one of the success or error callbacks asynchronously</span>
<span class="Comment"> *   as soon as the result is available. The callbacks are called with a single argument: the result</span>
<span class="Comment"> *   or rejection reason. Additionally, the notify callback may be called zero or more times to</span>
<span class="Comment"> *   provide a progress indication, before the promise is resolved or rejected.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   This method *returns a new promise* which is resolved or rejected via the return value of the</span>
<span class="Comment"> *   `successCallback`, `errorCallback`. It also notifies via the return value of the</span>
<span class="Comment"> *   `notifyCallback` method. The promise can not be resolved or rejected from the notifyCallback</span>
<span class="Comment"> *   method.</span>
<span class="Comment"> *</span>
<span class="Comment"> * - `catch(errorCallback)` – shorthand for `promise.then(null, errorCallback)`</span>
<span class="Comment"> *</span>
<span class="Comment"> * - `finally(callback)` – allows you to observe either the fulfillment or rejection of a promise,</span>
<span class="Comment"> *   but to do so without modifying the final value. This is useful to release resources or do some</span>
<span class="Comment"> *   clean-up that needs to be done whether the promise was rejected or resolved. See the [full</span>
<span class="Comment"> *   specification](<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback)">https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback)</a> for</span>
<span class="Comment"> *   more information.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   Because `finally` is a reserved word in JavaScript and reserved keywords are not supported as</span>
<span class="Comment"> *   property names by ES3, you'll need to invoke the method like `promise['finally'](callback)` to</span>
<span class="Comment"> *   make your code IE8 compatible.</span>
<span class="Comment"> *</span>
<span class="Comment"> * # Chaining promises</span>
<span class="Comment"> *</span>
<span class="Comment"> * Because calling the `then` method of a promise returns a new derived promise, it is easily</span>
<span class="Comment"> * possible to create a chain of promises:</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   promiseB = promiseA.then(function(result) {</span>
<span class="Comment"> *     return result + 1;</span>
<span class="Comment"> *   });</span>
<span class="Comment"> *</span>
<span class="Comment"> *   // promiseB will be resolved immediately after promiseA is resolved and its value</span>
<span class="Comment"> *   // will be the result of promiseA incremented by 1</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * It is possible to create chains of any length and since a promise can be resolved with another</span>
<span class="Comment"> * promise (which will defer its resolution further), it is possible to pause/defer resolution of</span>
<span class="Comment"> * the promises at any point in the chain. This makes it possible to implement powerful APIs like</span>
<span class="Comment"> * $http's response interceptors.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * # Differences between Kris Kowal's Q and $q</span>
<span class="Comment"> *</span>
<span class="Comment"> *  There are three main differences:</span>
<span class="Comment"> *</span>
<span class="Comment"> * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation</span>
<span class="Comment"> *   mechanism in angular, which means faster propagation of resolution or rejection into your</span>
<span class="Comment"> *   models and avoiding unnecessary browser repaints, which would result in flickering UI.</span>
<span class="Comment"> * - Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains</span>
<span class="Comment"> *   all the important functionality needed for common async tasks.</span>
<span class="Comment"> *</span>
<span class="Comment"> *  # Testing</span>
<span class="Comment"> *</span>
<span class="Comment"> *  &lt;pre&gt;</span>
<span class="Comment"> *    it('should simulate promise', inject(function($q, $rootScope) {</span>
<span class="Comment"> *      var deferred = $q.defer();</span>
<span class="Comment"> *      var promise = deferred.promise;</span>
<span class="Comment"> *      var resolvedValue;</span>
<span class="Comment"> *</span>
<span class="Comment"> *      promise.then(function(value) { resolvedValue = value; });</span>
<span class="Comment"> *      expect(resolvedValue).toBeUndefined();</span>
<span class="Comment"> *</span>
<span class="Comment"> *      // Simulate resolving of promise</span>
<span class="Comment"> *      deferred.resolve(123);</span>
<span class="Comment"> *      // Note that the 'then' function does not get called synchronously.</span>
<span class="Comment"> *      // This is because we want the promise API to always be async, whether or not</span>
<span class="Comment"> *      // it got called synchronously or asynchronously.</span>
<span class="Comment"> *      expect(resolvedValue).toBeUndefined();</span>
<span class="Comment"> *</span>
<span class="Comment"> *      // Propagate promise resolution to 'then' functions using $apply().</span>
<span class="Comment"> *      $rootScope.$apply();</span>
<span class="Comment"> *      expect(resolvedValue).toEqual(123);</span>
<span class="Comment"> *    }));</span>
<span class="Comment"> *  &lt;/pre&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $QProvider() <span class="Identifier">{</span>

  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$rootScope'</span>, <span class="Constant">'$exceptionHandler'</span>, <span class="Identifier">function</span>($rootScope, $exceptionHandler) <span class="Identifier">{</span>
    <span class="Statement">return</span> qFactory(<span class="Identifier">function</span>(callback) <span class="Identifier">{</span>
      $rootScope.$evalAsync(callback);
    <span class="Identifier">}</span>, $exceptionHandler);
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * Constructs a promise manager.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {function(function)} nextTick Function for executing functions in the next turn.</span>
<span class="Comment"> * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for</span>
<span class="Comment"> *     debugging purposes.</span>
<span class="Comment"> * @returns {object} Promise manager.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> qFactory(nextTick, exceptionHandler) <span class="Identifier">{</span>

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc</span>
<span class="Comment">   * @name ng.$q#defer</span>
<span class="Comment">   * @methodOf ng.$q</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Creates a `Deferred` object which represents a task which will finish in the future.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @returns {Deferred} Returns a new instance of deferred.</span>
<span class="Comment">   */</span>
  <span class="Identifier">var</span> defer = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> pending = <span class="Identifier">[]</span>,
        value, deferred;

    deferred = <span class="Identifier">{</span>

      resolve: <span class="Identifier">function</span>(val) <span class="Identifier">{</span>
        <span class="Statement">if</span> (pending) <span class="Identifier">{</span>
          <span class="Identifier">var</span> callbacks = pending;
          pending = <span class="Statement">undefined</span>;
          value = ref(val);

          <span class="Statement">if</span> (callbacks.length) <span class="Identifier">{</span>
            nextTick(<span class="Identifier">function</span>() <span class="Identifier">{</span>
              <span class="Identifier">var</span> callback;
              <span class="Statement">for</span> (<span class="Identifier">var</span> i = 0, ii = callbacks.length; i &lt; ii; i++) <span class="Identifier">{</span>
                callback = callbacks<span class="Identifier">[</span>i<span class="Identifier">]</span>;
                value.then(callback<span class="Identifier">[</span>0<span class="Identifier">]</span>, callback<span class="Identifier">[</span>1<span class="Identifier">]</span>, callback<span class="Identifier">[</span>2<span class="Identifier">]</span>);
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>,


      reject: <span class="Identifier">function</span>(reason) <span class="Identifier">{</span>
        deferred.resolve(reject(reason));
      <span class="Identifier">}</span>,


      notify: <span class="Identifier">function</span>(progress) <span class="Identifier">{</span>
        <span class="Statement">if</span> (pending) <span class="Identifier">{</span>
          <span class="Identifier">var</span> callbacks = pending;

          <span class="Statement">if</span> (pending.length) <span class="Identifier">{</span>
            nextTick(<span class="Identifier">function</span>() <span class="Identifier">{</span>
              <span class="Identifier">var</span> callback;
              <span class="Statement">for</span> (<span class="Identifier">var</span> i = 0, ii = callbacks.length; i &lt; ii; i++) <span class="Identifier">{</span>
                callback = callbacks<span class="Identifier">[</span>i<span class="Identifier">]</span>;
                callback<span class="Identifier">[</span>2<span class="Identifier">]</span>(progress);
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>,


      promise: <span class="Identifier">{</span>
        then: <span class="Identifier">function</span>(callback, errback, progressback) <span class="Identifier">{</span>
          <span class="Identifier">var</span> result = defer();

          <span class="Identifier">var</span> wrappedCallback = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
            <span class="Statement">try</span> <span class="Identifier">{</span>
              result.resolve((isFunction(callback) ? callback : defaultCallback)(value));
            <span class="Identifier">}</span> <span class="Statement">catch</span>(e) <span class="Identifier">{</span>
              result.reject(e);
              exceptionHandler(e);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>;

          <span class="Identifier">var</span> wrappedErrback = <span class="Identifier">function</span>(reason) <span class="Identifier">{</span>
            <span class="Statement">try</span> <span class="Identifier">{</span>
              result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
            <span class="Identifier">}</span> <span class="Statement">catch</span>(e) <span class="Identifier">{</span>
              result.reject(e);
              exceptionHandler(e);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>;

          <span class="Identifier">var</span> wrappedProgressback = <span class="Identifier">function</span>(progress) <span class="Identifier">{</span>
            <span class="Statement">try</span> <span class="Identifier">{</span>
              result.notify((isFunction(progressback) ? progressback : defaultCallback)(progress));
            <span class="Identifier">}</span> <span class="Statement">catch</span>(e) <span class="Identifier">{</span>
              exceptionHandler(e);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>;

          <span class="Statement">if</span> (pending) <span class="Identifier">{</span>
            pending.push(<span class="Identifier">[</span>wrappedCallback, wrappedErrback, wrappedProgressback<span class="Identifier">]</span>);
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            value.then(wrappedCallback, wrappedErrback, wrappedProgressback);
          <span class="Identifier">}</span>

          <span class="Statement">return</span> result.promise;
        <span class="Identifier">}</span>,

        <span class="Constant">&quot;catch&quot;</span>: <span class="Identifier">function</span>(callback) <span class="Identifier">{</span>
          <span class="Statement">return</span> <span class="Identifier">this</span>.then(<span class="Statement">null</span>, callback);
        <span class="Identifier">}</span>,

        <span class="Constant">&quot;finally&quot;</span>: <span class="Identifier">function</span>(callback) <span class="Identifier">{</span>

          <span class="Identifier">function</span> makePromise(value, resolved) <span class="Identifier">{</span>
            <span class="Identifier">var</span> result = defer();
            <span class="Statement">if</span> (resolved) <span class="Identifier">{</span>
              result.resolve(value);
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
              result.reject(value);
            <span class="Identifier">}</span>
            <span class="Statement">return</span> result.promise;
          <span class="Identifier">}</span>

          <span class="Identifier">function</span> handleCallback(value, isResolved) <span class="Identifier">{</span>
            <span class="Identifier">var</span> callbackOutput = <span class="Statement">null</span>;
            <span class="Statement">try</span> <span class="Identifier">{</span>
              callbackOutput = (callback ||defaultCallback)();
            <span class="Identifier">}</span> <span class="Statement">catch</span>(e) <span class="Identifier">{</span>
              <span class="Statement">return</span> makePromise(e, <span class="Constant">false</span>);
            <span class="Identifier">}</span>
            <span class="Statement">if</span> (callbackOutput &amp;&amp; isFunction(callbackOutput.then)) <span class="Identifier">{</span>
              <span class="Statement">return</span> callbackOutput.then(<span class="Identifier">function</span>() <span class="Identifier">{</span>
                <span class="Statement">return</span> makePromise(value, isResolved);
              <span class="Identifier">}</span>, <span class="Identifier">function</span>(error) <span class="Identifier">{</span>
                <span class="Statement">return</span> makePromise(error, <span class="Constant">false</span>);
              <span class="Identifier">}</span>);
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
              <span class="Statement">return</span> makePromise(value, isResolved);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>

          <span class="Statement">return</span> <span class="Identifier">this</span>.then(<span class="Identifier">function</span>(value) <span class="Identifier">{</span>
            <span class="Statement">return</span> handleCallback(value, <span class="Constant">true</span>);
          <span class="Identifier">}</span>, <span class="Identifier">function</span>(error) <span class="Identifier">{</span>
            <span class="Statement">return</span> handleCallback(error, <span class="Constant">false</span>);
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;

    <span class="Statement">return</span> deferred;
  <span class="Identifier">}</span>;


  <span class="Identifier">var</span> ref = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Statement">if</span> (value &amp;&amp; isFunction(value.then)) <span class="Statement">return</span> value;
    <span class="Statement">return</span> <span class="Identifier">{</span>
      then: <span class="Identifier">function</span>(callback) <span class="Identifier">{</span>
        <span class="Identifier">var</span> result = defer();
        nextTick(<span class="Identifier">function</span>() <span class="Identifier">{</span>
          result.resolve(callback(value));
        <span class="Identifier">}</span>);
        <span class="Statement">return</span> result.promise;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>;


  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc</span>
<span class="Comment">   * @name ng.$q#reject</span>
<span class="Comment">   * @methodOf ng.$q</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Creates a promise that is resolved as rejected with the specified `reason`. This api should be</span>
<span class="Comment">   * used to forward rejection in a chain of promises. If you are dealing with the last promise in</span>
<span class="Comment">   * a promise chain, you don't need to worry about it.</span>
<span class="Comment">   *</span>
<span class="Comment">   * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of</span>
<span class="Comment">   * `reject` as the `throw` keyword in JavaScript. This also means that if you &quot;catch&quot; an error via</span>
<span class="Comment">   * a promise error callback and you want to forward the error to the promise derived from the</span>
<span class="Comment">   * current promise, you have to &quot;rethrow&quot; the error by returning a rejection constructed via</span>
<span class="Comment">   * `reject`.</span>
<span class="Comment">   *</span>
<span class="Comment">   * &lt;pre&gt;</span>
<span class="Comment">   *   promiseB = promiseA.then(function(result) {</span>
<span class="Comment">   *     // success: do something and resolve promiseB</span>
<span class="Comment">   *     //          with the old or a new result</span>
<span class="Comment">   *     return result;</span>
<span class="Comment">   *   }, function(reason) {</span>
<span class="Comment">   *     // error: handle the error if possible and</span>
<span class="Comment">   *     //        resolve promiseB with newPromiseOrValue,</span>
<span class="Comment">   *     //        otherwise forward the rejection to promiseB</span>
<span class="Comment">   *     if (canHandle(reason)) {</span>
<span class="Comment">   *      // handle the error and recover</span>
<span class="Comment">   *      return newPromiseOrValue;</span>
<span class="Comment">   *     }</span>
<span class="Comment">   *     return $q.reject(reason);</span>
<span class="Comment">   *   });</span>
<span class="Comment">   * &lt;/pre&gt;</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {*} reason Constant, message, exception or an object representing the rejection reason.</span>
<span class="Comment">   * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.</span>
<span class="Comment">   */</span>
  <span class="Identifier">var</span> reject = <span class="Identifier">function</span>(reason) <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">{</span>
      then: <span class="Identifier">function</span>(callback, errback) <span class="Identifier">{</span>
        <span class="Identifier">var</span> result = defer();
        nextTick(<span class="Identifier">function</span>() <span class="Identifier">{</span>
          <span class="Statement">try</span> <span class="Identifier">{</span>
            result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
          <span class="Identifier">}</span> <span class="Statement">catch</span>(e) <span class="Identifier">{</span>
            result.reject(e);
            exceptionHandler(e);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>);
        <span class="Statement">return</span> result.promise;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>;


  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc</span>
<span class="Comment">   * @name ng.$q#when</span>
<span class="Comment">   * @methodOf ng.$q</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.</span>
<span class="Comment">   * This is useful when you are dealing with an object that might or might not be a promise, or if</span>
<span class="Comment">   * the promise comes from a source that can't be trusted.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {*} value Value or a promise</span>
<span class="Comment">   * @returns {Promise} Returns a promise of the passed value or promise</span>
<span class="Comment">   */</span>
  <span class="Identifier">var</span> when = <span class="Identifier">function</span>(value, callback, errback, progressback) <span class="Identifier">{</span>
    <span class="Identifier">var</span> result = defer(),
        done;

    <span class="Identifier">var</span> wrappedCallback = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
      <span class="Statement">try</span> <span class="Identifier">{</span>
        <span class="Statement">return</span> (isFunction(callback) ? callback : defaultCallback)(value);
      <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
        exceptionHandler(e);
        <span class="Statement">return</span> reject(e);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;

    <span class="Identifier">var</span> wrappedErrback = <span class="Identifier">function</span>(reason) <span class="Identifier">{</span>
      <span class="Statement">try</span> <span class="Identifier">{</span>
        <span class="Statement">return</span> (isFunction(errback) ? errback : defaultErrback)(reason);
      <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
        exceptionHandler(e);
        <span class="Statement">return</span> reject(e);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;

    <span class="Identifier">var</span> wrappedProgressback = <span class="Identifier">function</span>(progress) <span class="Identifier">{</span>
      <span class="Statement">try</span> <span class="Identifier">{</span>
        <span class="Statement">return</span> (isFunction(progressback) ? progressback : defaultCallback)(progress);
      <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
        exceptionHandler(e);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;

    nextTick(<span class="Identifier">function</span>() <span class="Identifier">{</span>
      ref(value).then(<span class="Identifier">function</span>(value) <span class="Identifier">{</span>
        <span class="Statement">if</span> (done) <span class="Statement">return</span>;
        done = <span class="Constant">true</span>;
        result.resolve(ref(value).then(wrappedCallback, wrappedErrback, wrappedProgressback));
      <span class="Identifier">}</span>, <span class="Identifier">function</span>(reason) <span class="Identifier">{</span>
        <span class="Statement">if</span> (done) <span class="Statement">return</span>;
        done = <span class="Constant">true</span>;
        result.resolve(wrappedErrback(reason));
      <span class="Identifier">}</span>, <span class="Identifier">function</span>(progress) <span class="Identifier">{</span>
        <span class="Statement">if</span> (done) <span class="Statement">return</span>;
        result.notify(wrappedProgressback(progress));
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>);

    <span class="Statement">return</span> result.promise;
  <span class="Identifier">}</span>;


  <span class="Identifier">function</span> defaultCallback(value) <span class="Identifier">{</span>
    <span class="Statement">return</span> value;
  <span class="Identifier">}</span>


  <span class="Identifier">function</span> defaultErrback(reason) <span class="Identifier">{</span>
    <span class="Statement">return</span> reject(reason);
  <span class="Identifier">}</span>


  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc</span>
<span class="Comment">   * @name ng.$q#all</span>
<span class="Comment">   * @methodOf ng.$q</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Combines multiple promises into a single promise that is resolved when all of the input</span>
<span class="Comment">   * promises are resolved.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {Array.&lt;Promise&gt;|Object.&lt;Promise&gt;} promises An array or hash of promises.</span>
<span class="Comment">   * @returns {Promise} Returns a single promise that will be resolved with an array/hash of values,</span>
<span class="Comment">   *   each value corresponding to the promise at the same index/key in the `promises` array/hash.</span>
<span class="Comment">   *   If any of the promises is resolved with a rejection, this resulting promise will be rejected</span>
<span class="Comment">   *   with the same rejection value.</span>
<span class="Comment">   */</span>
  <span class="Identifier">function</span> all(promises) <span class="Identifier">{</span>
    <span class="Identifier">var</span> deferred = defer(),
        counter = 0,
        results = isArray(promises) ? <span class="Identifier">[]</span> : <span class="Identifier">{}</span>;

    forEach(promises, <span class="Identifier">function</span>(promise, key) <span class="Identifier">{</span>
      counter++;
      ref(promise).then(<span class="Identifier">function</span>(value) <span class="Identifier">{</span>
        <span class="Statement">if</span> (results.hasOwnProperty(key)) <span class="Statement">return</span>;
        results<span class="Identifier">[</span>key<span class="Identifier">]</span> = value;
        <span class="Statement">if</span> (!(--counter)) deferred.resolve(results);
      <span class="Identifier">}</span>, <span class="Identifier">function</span>(reason) <span class="Identifier">{</span>
        <span class="Statement">if</span> (results.hasOwnProperty(key)) <span class="Statement">return</span>;
        deferred.reject(reason);
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>);

    <span class="Statement">if</span> (counter === 0) <span class="Identifier">{</span>
      deferred.resolve(results);
    <span class="Identifier">}</span>

    <span class="Statement">return</span> deferred.promise;
  <span class="Identifier">}</span>

  <span class="Statement">return</span> <span class="Identifier">{</span>
    defer: defer,
    reject: reject,
    when: when,
    all: all
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * DESIGN NOTES</span>
<span class="Comment"> *</span>
<span class="Comment"> * The design decisions behind the scope are heavily favored for speed and memory consumption.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The typical use of scope is to watch the expressions, which most of the time return the same</span>
<span class="Comment"> * value as last time so we optimize the operation.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Closures construction is expensive in terms of speed as well as memory:</span>
<span class="Comment"> *   - No closures, instead use prototypical inheritance for API</span>
<span class="Comment"> *   - Internal state needs to be stored on scope directly, which means that private state is</span>
<span class="Comment"> *     exposed as $$____ properties</span>
<span class="Comment"> *</span>
<span class="Comment"> * Loop operations are optimized by using while(count--) { ... }</span>
<span class="Comment"> *   - this means that in order to keep the same order of execution as addition we have to add</span>
<span class="Comment"> *     items to the array at the beginning (shift) instead of at the end (push)</span>
<span class="Comment"> *</span>
<span class="Comment"> * Child scopes are created and removed often</span>
<span class="Comment"> *   - Using an array would be slow since inserts in middle are expensive so we use linked list</span>
<span class="Comment"> *</span>
<span class="Comment"> * There are few watches then a lot of observers. This is why you don't want the observer to be</span>
<span class="Comment"> * implemented in the same way as watch. Watch requires return of initialization function which</span>
<span class="Comment"> * are expensive to construct.</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$rootScopeProvider</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Provider for the $rootScope service.</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name ng.$rootScopeProvider#digestTtl</span>
<span class="Comment"> * @methodOf ng.$rootScopeProvider</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Sets the number of `$digest` iterations the scope should attempt to execute before giving up and</span>
<span class="Comment"> * assuming that the model is unstable.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The current default is 10 iterations.</span>
<span class="Comment"> *</span>
<span class="Comment"> * In complex applications it's possible that the dependencies between `$watch`s will result in</span>
<span class="Comment"> * several digest iterations. However if an application needs more than the default 10 digest</span>
<span class="Comment"> * iterations for its model to stabilize then you should investigate what is causing the model to</span>
<span class="Comment"> * continuously change during the digest.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Increasing the TTL could have performance implications, so you should not change it without</span>
<span class="Comment"> * proper justification.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {number} limit The number of digest iterations.</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$rootScope</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Every application has a single root {@link ng.$rootScope.Scope scope}.</span>
<span class="Comment"> * All other scopes are descendant scopes of the root scope. Scopes provide separation</span>
<span class="Comment"> * between the model and the view, via a mechanism for watching the model for changes.</span>
<span class="Comment"> * They also provide an event emission/broadcast and subscription facility. See the</span>
<span class="Comment"> * {@link guide/scope developer guide on scopes}.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $RootScopeProvider()<span class="Identifier">{</span>
  <span class="Identifier">var</span> TTL = 10;
  <span class="Identifier">var</span> $rootScopeMinErr = minErr(<span class="Constant">'$rootScope'</span>);
  <span class="Identifier">var</span> lastDirtyWatch = <span class="Statement">null</span>;

  <span class="Identifier">this</span>.digestTtl = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Statement">if</span> (<span class="Identifier">arguments</span>.length) <span class="Identifier">{</span>
      TTL = value;
    <span class="Identifier">}</span>
    <span class="Statement">return</span> TTL;
  <span class="Identifier">}</span>;

  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$injector'</span>, <span class="Constant">'$exceptionHandler'</span>, <span class="Constant">'$parse'</span>, <span class="Constant">'$browser'</span>,
      <span class="Identifier">function</span>( $injector,   $exceptionHandler,   $parse,   $browser) <span class="Identifier">{</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc function</span>
<span class="Comment">     * @name ng.$rootScope.Scope</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the</span>
<span class="Comment">     * {@link AUTO.$injector $injector}. Child scopes are created using the</span>
<span class="Comment">     * {@link ng.$rootScope.Scope#methods_$new $new()} method. (Most scopes are created automatically when</span>
<span class="Comment">     * compiled HTML template is executed.)</span>
<span class="Comment">     *</span>
<span class="Comment">     * Here is a simple scope snippet to show how you can interact with the scope.</span>
<span class="Comment">     * &lt;pre&gt;</span>
<span class="Comment">     * &lt;file src=&quot;./test/ng/rootScopeSpec.js&quot; tag=&quot;docs1&quot; /&gt;</span>
<span class="Comment">     * &lt;/pre&gt;</span>
<span class="Comment">     *</span>
<span class="Comment">     * # Inheritance</span>
<span class="Comment">     * A scope can inherit from a parent scope, as in this example:</span>
<span class="Comment">     * &lt;pre&gt;</span>
<span class="Comment">         var parent = $rootScope;</span>
<span class="Comment">         var child = parent.$new();</span>

<span class="Comment">         parent.salutation = &quot;Hello&quot;;</span>
<span class="Comment">         child.name = &quot;World&quot;;</span>
<span class="Comment">         expect(child.salutation).toEqual('Hello');</span>

<span class="Comment">         child.salutation = &quot;Welcome&quot;;</span>
<span class="Comment">         expect(child.salutation).toEqual('Welcome');</span>
<span class="Comment">         expect(parent.salutation).toEqual('Hello');</span>
<span class="Comment">     * &lt;/pre&gt;</span>
<span class="Comment">     *</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {Object.&lt;string, function()&gt;=} providers Map of service factory which need to be</span>
<span class="Comment">     *                                       provided for the current scope. Defaults to {@link ng}.</span>
<span class="Comment">     * @param {Object.&lt;string, *&gt;=} instanceCache Provides pre-instantiated services which should</span>
<span class="Comment">     *                              append/override services provided by `providers`. This is handy</span>
<span class="Comment">     *                              when unit-testing and having the need to override a default</span>
<span class="Comment">     *                              service.</span>
<span class="Comment">     * @returns {Object} Newly created scope.</span>
<span class="Comment">     *</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> Scope() <span class="Identifier">{</span>
      <span class="Identifier">this</span>.$id = nextUid();
      <span class="Identifier">this</span>.$$phase = <span class="Identifier">this</span>.$<span class="Statement">parent</span> = <span class="Identifier">this</span>.$$watchers =
                     <span class="Identifier">this</span>.$$nextSibling = <span class="Identifier">this</span>.$$prevSibling =
                     <span class="Identifier">this</span>.$$childHead = <span class="Identifier">this</span>.$$childTail = <span class="Statement">null</span>;
      <span class="Identifier">this</span><span class="Identifier">[</span><span class="Constant">'this'</span><span class="Identifier">]</span> = <span class="Identifier">this</span>.$root =  <span class="Identifier">this</span>;
      <span class="Identifier">this</span>.$$destroyed = <span class="Constant">false</span>;
      <span class="Identifier">this</span>.$$asyncQueue = <span class="Identifier">[]</span>;
      <span class="Identifier">this</span>.$$postDigestQueue = <span class="Identifier">[]</span>;
      <span class="Identifier">this</span>.$$listeners = <span class="Identifier">{}</span>;
      <span class="Identifier">this</span>.$$isolateBindings = <span class="Identifier">{}</span>;
    <span class="Identifier">}</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc property</span>
<span class="Comment">     * @name ng.$rootScope.Scope#$id</span>
<span class="Comment">     * @propertyOf ng.$rootScope.Scope</span>
<span class="Comment">     * @returns {number} Unique scope ID (monotonically increasing alphanumeric sequence) useful for</span>
<span class="Comment">     *   debugging.</span>
<span class="Comment">     */</span>


    Scope.prototype = <span class="Identifier">{</span>
      constructor: Scope,
      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$rootScope.Scope#$new</span>
<span class="Comment">       * @methodOf ng.$rootScope.Scope</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Creates a new child {@link ng.$rootScope.Scope scope}.</span>
<span class="Comment">       *</span>
<span class="Comment">       * The parent scope will propagate the {@link ng.$rootScope.Scope#$digest $digest()} and</span>
<span class="Comment">       * {@link ng.$rootScope.Scope#$digest $digest()} events. The scope can be removed from the</span>
<span class="Comment">       * scope hierarchy using {@link ng.$rootScope.Scope#$destroy $destroy()}.</span>
<span class="Comment">       *</span>
<span class="Comment">       * {@link ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is</span>
<span class="Comment">       * desired for the scope and its child scopes to be permanently detached from the parent and</span>
<span class="Comment">       * thus stop participating in model change detection and listener notification by invoking.</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {boolean} isolate If true, then the scope does not prototypically inherit from the</span>
<span class="Comment">       *         parent scope. The scope is isolated, as it can not see parent scope properties.</span>
<span class="Comment">       *         When creating widgets, it is useful for the widget to not accidentally read parent</span>
<span class="Comment">       *         state.</span>
<span class="Comment">       *</span>
<span class="Comment">       * @returns {Object} The newly created child scope.</span>
<span class="Comment">       *</span>
<span class="Comment">       */</span>
      $<span class="Statement">new</span>: <span class="Identifier">function</span>(isolate) <span class="Identifier">{</span>
        <span class="Identifier">var</span> ChildScope,
            child;

        <span class="Statement">if</span> (isolate) <span class="Identifier">{</span>
          child = <span class="Statement">new</span> Scope();
          child.$root = <span class="Identifier">this</span>.$root;
          <span class="Comment">// ensure that there is just one async queue per $rootScope and its children</span>
          child.$$asyncQueue = <span class="Identifier">this</span>.$$asyncQueue;
          child.$$postDigestQueue = <span class="Identifier">this</span>.$$postDigestQueue;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          ChildScope = <span class="Identifier">function</span>() <span class="Identifier">{}</span>; <span class="Comment">// should be anonymous; This is so that when the minifier munges</span>
            <span class="Comment">// the name it does not become random set of chars. This will then show up as class</span>
            <span class="Comment">// name in the debugger.</span>
          ChildScope.prototype = <span class="Identifier">this</span>;
          child = <span class="Statement">new</span> ChildScope();
          child.$id = nextUid();
        <span class="Identifier">}</span>
        child<span class="Identifier">[</span><span class="Constant">'this'</span><span class="Identifier">]</span> = child;
        child.$$listeners = <span class="Identifier">{}</span>;
        child.$<span class="Statement">parent</span> = <span class="Identifier">this</span>;
        child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = <span class="Statement">null</span>;
        child.$$prevSibling = <span class="Identifier">this</span>.$$childTail;
        <span class="Statement">if</span> (<span class="Identifier">this</span>.$$childHead) <span class="Identifier">{</span>
          <span class="Identifier">this</span>.$$childTail.$$nextSibling = child;
          <span class="Identifier">this</span>.$$childTail = child;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          <span class="Identifier">this</span>.$$childHead = <span class="Identifier">this</span>.$$childTail = child;
        <span class="Identifier">}</span>
        <span class="Statement">return</span> child;
      <span class="Identifier">}</span>,

      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$rootScope.Scope#$watch</span>
<span class="Comment">       * @methodOf ng.$rootScope.Scope</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Registers a `listener` callback to be executed whenever the `watchExpression` changes.</span>
<span class="Comment">       *</span>
<span class="Comment">       * - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest</span>
<span class="Comment">       *   $digest()} and should return the value that will be watched. (Since</span>
<span class="Comment">       *   {@link ng.$rootScope.Scope#$digest $digest()} reruns when it detects changes the</span>
<span class="Comment">       *   `watchExpression` can execute multiple times per</span>
<span class="Comment">       *   {@link ng.$rootScope.Scope#$digest $digest()} and should be idempotent.)</span>
<span class="Comment">       * - The `listener` is called only when the value from the current `watchExpression` and the</span>
<span class="Comment">       *   previous call to `watchExpression` are not equal (with the exception of the initial run,</span>
<span class="Comment">       *   see below). The inequality is determined according to</span>
<span class="Comment">       *   {@link angular.equals} function. To save the value of the object for later comparison,</span>
<span class="Comment">       *   the {@link angular.copy} function is used. It also means that watching complex options</span>
<span class="Comment">       *   will have adverse memory and performance implications.</span>
<span class="Comment">       * - The watch `listener` may change the model, which may trigger other `listener`s to fire.</span>
<span class="Comment">       *   This is achieved by rerunning the watchers until no changes are detected. The rerun</span>
<span class="Comment">       *   iteration limit is 10 to prevent an infinite loop deadlock.</span>
<span class="Comment">       *</span>
<span class="Comment">       *</span>
<span class="Comment">       * If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called,</span>
<span class="Comment">       * you can register a `watchExpression` function with no `listener`. (Since `watchExpression`</span>
<span class="Comment">       * can execute multiple times per {@link ng.$rootScope.Scope#$digest $digest} cycle when a</span>
<span class="Comment">       * change is detected, be prepared for multiple calls to your listener.)</span>
<span class="Comment">       *</span>
<span class="Comment">       * After a watcher is registered with the scope, the `listener` fn is called asynchronously</span>
<span class="Comment">       * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the</span>
<span class="Comment">       * watcher. In rare cases, this is undesirable because the listener is called when the result</span>
<span class="Comment">       * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you</span>
<span class="Comment">       * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the</span>
<span class="Comment">       * listener was called due to initialization.</span>
<span class="Comment">       *</span>
<span class="Comment">       * The example below contains an illustration of using a function as your $watch listener</span>
<span class="Comment">       *</span>
<span class="Comment">       *</span>
<span class="Comment">       * # Example</span>
<span class="Comment">       * &lt;pre&gt;</span>
<span class="Comment">           // let's assume that scope was dependency injected as the $rootScope</span>
<span class="Comment">           var scope = $rootScope;</span>
<span class="Comment">           scope.name = 'misko';</span>
<span class="Comment">           scope.counter = 0;</span>

<span class="Comment">           expect(scope.counter).toEqual(0);</span>
<span class="Comment">           scope.$watch('name', function(newValue, oldValue) {</span>
<span class="Comment">             scope.counter = scope.counter + 1;</span>
<span class="Comment">           });</span>
<span class="Comment">           expect(scope.counter).toEqual(0);</span>

<span class="Comment">           scope.$digest();</span>
<span class="Comment">           // no variable change</span>
<span class="Comment">           expect(scope.counter).toEqual(0);</span>

<span class="Comment">           scope.name = 'adam';</span>
<span class="Comment">           scope.$digest();</span>
<span class="Comment">           expect(scope.counter).toEqual(1);</span>



<span class="Comment">           // Using a listener function</span>
<span class="Comment">           var food;</span>
<span class="Comment">           scope.foodCounter = 0;</span>
<span class="Comment">           expect(scope.foodCounter).toEqual(0);</span>
<span class="Comment">           scope.$watch(</span>
<span class="Comment">             // This is the listener function</span>
<span class="Comment">             function() { return food; },</span>
<span class="Comment">             // This is the change handler</span>
<span class="Comment">             function(newValue, oldValue) {</span>
<span class="Comment">               if ( newValue !== oldValue ) {</span>
<span class="Comment">                 // Only increment the counter if the value changed</span>
<span class="Comment">                 scope.foodCounter = scope.foodCounter + 1;</span>
<span class="Comment">               }</span>
<span class="Comment">             }</span>
<span class="Comment">           );</span>
<span class="Comment">           // No digest has been run so the counter will be zero</span>
<span class="Comment">           expect(scope.foodCounter).toEqual(0);</span>

<span class="Comment">           // Run the digest but since food has not changed cout will still be zero</span>
<span class="Comment">           scope.$digest();</span>
<span class="Comment">           expect(scope.foodCounter).toEqual(0);</span>

<span class="Comment">           // Update food and run digest.  Now the counter will increment</span>
<span class="Comment">           food = 'cheeseburger';</span>
<span class="Comment">           scope.$digest();</span>
<span class="Comment">           expect(scope.foodCounter).toEqual(1);</span>

<span class="Comment">       * &lt;/pre&gt;</span>
<span class="Comment">       *</span>
<span class="Comment">       *</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {(function()|string)} watchExpression Expression that is evaluated on each</span>
<span class="Comment">       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers</span>
<span class="Comment">       *    a call to the `listener`.</span>
<span class="Comment">       *</span>
<span class="Comment">       *    - `string`: Evaluated as {@link guide/expression expression}</span>
<span class="Comment">       *    - `function(scope)`: called with current `scope` as a parameter.</span>
<span class="Comment">       * @param {(function()|string)=} listener Callback called whenever the return value of</span>
<span class="Comment">       *   the `watchExpression` changes.</span>
<span class="Comment">       *</span>
<span class="Comment">       *    - `string`: Evaluated as {@link guide/expression expression}</span>
<span class="Comment">       *    - `function(newValue, oldValue, scope)`: called with current and previous values as</span>
<span class="Comment">       *      parameters.</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {boolean=} objectEquality Compare object for equality rather than for reference.</span>
<span class="Comment">       * @returns {function()} Returns a deregistration function for this listener.</span>
<span class="Comment">       */</span>
      $watch: <span class="Identifier">function</span>(watchExp, listener, objectEquality) <span class="Identifier">{</span>
        <span class="Identifier">var</span> scope = <span class="Identifier">this</span>,
            get = compileToFn(watchExp, <span class="Constant">'watch'</span>),
            array = scope.$$watchers,
            watcher = <span class="Identifier">{</span>
              fn: listener,
              last: initWatchVal,
              get: get,
              exp: watchExp,
              eq: !!objectEquality
            <span class="Identifier">}</span>;

        lastDirtyWatch = <span class="Statement">null</span>;

        <span class="Comment">// in the case user pass string, we need to compile it, do we really need this ?</span>
        <span class="Statement">if</span> (!isFunction(listener)) <span class="Identifier">{</span>
          <span class="Identifier">var</span> listenFn = compileToFn(listener || noop, <span class="Constant">'listener'</span>);
          watcher.fn = <span class="Identifier">function</span>(newVal, oldVal, scope) <span class="Identifier">{</span>listenFn(scope);<span class="Identifier">}</span>;
        <span class="Identifier">}</span>

        <span class="Statement">if</span> (<span class="Statement">typeof</span> watchExp == <span class="Constant">'string'</span> &amp;&amp; get.constant) <span class="Identifier">{</span>
          <span class="Identifier">var</span> originalFn = watcher.fn;
          watcher.fn = <span class="Identifier">function</span>(newVal, oldVal, scope) <span class="Identifier">{</span>
            originalFn.call(<span class="Identifier">this</span>, newVal, oldVal, scope);
            arrayRemove(array, watcher);
          <span class="Identifier">}</span>;
        <span class="Identifier">}</span>

        <span class="Statement">if</span> (!array) <span class="Identifier">{</span>
          array = scope.$$watchers = <span class="Identifier">[]</span>;
        <span class="Identifier">}</span>
        <span class="Comment">// we use unshift since we use a while loop in $digest for speed.</span>
        <span class="Comment">// the while loop reads in reverse order.</span>
        array.unshift(watcher);

        <span class="Statement">return</span> <span class="Identifier">function</span>() <span class="Identifier">{</span>
          arrayRemove(array, watcher);
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span>,


      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$rootScope.Scope#$watchCollection</span>
<span class="Comment">       * @methodOf ng.$rootScope.Scope</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Shallow watches the properties of an object and fires whenever any of the properties change</span>
<span class="Comment">       * (for arrays, this implies watching the array items; for object maps, this implies watching</span>
<span class="Comment">       * the properties). If a change is detected, the `listener` callback is fired.</span>
<span class="Comment">       *</span>
<span class="Comment">       * - The `obj` collection is observed via standard $watch operation and is examined on every</span>
<span class="Comment">       *   call to $digest() to see if any items have been added, removed, or moved.</span>
<span class="Comment">       * - The `listener` is called whenever anything within the `obj` has changed. Examples include</span>
<span class="Comment">       *   adding, removing, and moving items belonging to an object or array.</span>
<span class="Comment">       *</span>
<span class="Comment">       *</span>
<span class="Comment">       * # Example</span>
<span class="Comment">       * &lt;pre&gt;</span>
<span class="Comment">          $scope.names = ['igor', 'matias', 'misko', 'james'];</span>
<span class="Comment">          $scope.dataCount = 4;</span>

<span class="Comment">          $scope.$watchCollection('names', function(newNames, oldNames) {</span>
<span class="Comment">            $scope.dataCount = newNames.length;</span>
<span class="Comment">          });</span>

<span class="Comment">          expect($scope.dataCount).toEqual(4);</span>
<span class="Comment">          $scope.$digest();</span>

<span class="Comment">          //still at 4 ... no changes</span>
<span class="Comment">          expect($scope.dataCount).toEqual(4);</span>

<span class="Comment">          $scope.names.pop();</span>
<span class="Comment">          $scope.$digest();</span>

<span class="Comment">          //now there's been a change</span>
<span class="Comment">          expect($scope.dataCount).toEqual(3);</span>
<span class="Comment">       * &lt;/pre&gt;</span>
<span class="Comment">       *</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {string|Function(scope)} obj Evaluated as {@link guide/expression expression}. The</span>
<span class="Comment">       *    expression value should evaluate to an object or an array which is observed on each</span>
<span class="Comment">       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the</span>
<span class="Comment">       *    collection will trigger a call to the `listener`.</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {function(newCollection, oldCollection, scope)} listener a callback function that is</span>
<span class="Comment">       *    fired with both the `newCollection` and `oldCollection` as parameters.</span>
<span class="Comment">       *    The `newCollection` object is the newly modified data obtained from the `obj` expression</span>
<span class="Comment">       *    and the `oldCollection` object is a copy of the former collection data.</span>
<span class="Comment">       *    The `scope` refers to the current scope.</span>
<span class="Comment">       *</span>
<span class="Comment">       * @returns {function()} Returns a de-registration function for this listener. When the</span>
<span class="Comment">       *    de-registration function is executed, the internal watch operation is terminated.</span>
<span class="Comment">       */</span>
      $watchCollection: <span class="Identifier">function</span>(obj, listener) <span class="Identifier">{</span>
        <span class="Identifier">var</span> <span class="Statement">self</span> = <span class="Identifier">this</span>;
        <span class="Identifier">var</span> oldValue;
        <span class="Identifier">var</span> newValue;
        <span class="Identifier">var</span> changeDetected = 0;
        <span class="Identifier">var</span> objGetter = $parse(obj);
        <span class="Identifier">var</span> internalArray = <span class="Identifier">[]</span>;
        <span class="Identifier">var</span> internalObject = <span class="Identifier">{}</span>;
        <span class="Identifier">var</span> oldLength = 0;

        <span class="Identifier">function</span> $watchCollectionWatch() <span class="Identifier">{</span>
          newValue = objGetter(<span class="Statement">self</span>);
          <span class="Identifier">var</span> newLength, key;

          <span class="Statement">if</span> (!isObject(newValue)) <span class="Identifier">{</span>
            <span class="Statement">if</span> (oldValue !== newValue) <span class="Identifier">{</span>
              oldValue = newValue;
              changeDetected++;
            <span class="Identifier">}</span>
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isArrayLike(newValue)) <span class="Identifier">{</span>
            <span class="Statement">if</span> (oldValue !== internalArray) <span class="Identifier">{</span>
              <span class="Comment">// we are transitioning from something which was not an array into array.</span>
              oldValue = internalArray;
              oldLength = oldValue.length = 0;
              changeDetected++;
            <span class="Identifier">}</span>

            newLength = newValue.length;

            <span class="Statement">if</span> (oldLength !== newLength) <span class="Identifier">{</span>
              <span class="Comment">// if lengths do not match we need to trigger change notification</span>
              changeDetected++;
              oldValue.length = oldLength = newLength;
            <span class="Identifier">}</span>
            <span class="Comment">// copy the items to oldValue and look for changes.</span>
            <span class="Statement">for</span> (<span class="Identifier">var</span> i = 0; i &lt; newLength; i++) <span class="Identifier">{</span>
              <span class="Statement">if</span> (oldValue<span class="Identifier">[</span>i<span class="Identifier">]</span> !== newValue<span class="Identifier">[</span>i<span class="Identifier">]</span>) <span class="Identifier">{</span>
                changeDetected++;
                oldValue<span class="Identifier">[</span>i<span class="Identifier">]</span> = newValue<span class="Identifier">[</span>i<span class="Identifier">]</span>;
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            <span class="Statement">if</span> (oldValue !== internalObject) <span class="Identifier">{</span>
              <span class="Comment">// we are transitioning from something which was not an object into object.</span>
              oldValue = internalObject = <span class="Identifier">{}</span>;
              oldLength = 0;
              changeDetected++;
            <span class="Identifier">}</span>
            <span class="Comment">// copy the items to oldValue and look for changes.</span>
            newLength = 0;
            <span class="Statement">for</span> (key <span class="Statement">in</span> newValue) <span class="Identifier">{</span>
              <span class="Statement">if</span> (newValue.hasOwnProperty(key)) <span class="Identifier">{</span>
                newLength++;
                <span class="Statement">if</span> (oldValue.hasOwnProperty(key)) <span class="Identifier">{</span>
                  <span class="Statement">if</span> (oldValue<span class="Identifier">[</span>key<span class="Identifier">]</span> !== newValue<span class="Identifier">[</span>key<span class="Identifier">]</span>) <span class="Identifier">{</span>
                    changeDetected++;
                    oldValue<span class="Identifier">[</span>key<span class="Identifier">]</span> = newValue<span class="Identifier">[</span>key<span class="Identifier">]</span>;
                  <span class="Identifier">}</span>
                <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
                  oldLength++;
                  oldValue<span class="Identifier">[</span>key<span class="Identifier">]</span> = newValue<span class="Identifier">[</span>key<span class="Identifier">]</span>;
                  changeDetected++;
                <span class="Identifier">}</span>
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>
            <span class="Statement">if</span> (oldLength &gt; newLength) <span class="Identifier">{</span>
              <span class="Comment">// we used to have more keys, need to find them and destroy them.</span>
              changeDetected++;
              <span class="Statement">for</span>(key <span class="Statement">in</span> oldValue) <span class="Identifier">{</span>
                <span class="Statement">if</span> (oldValue.hasOwnProperty(key) &amp;&amp; !newValue.hasOwnProperty(key)) <span class="Identifier">{</span>
                  oldLength--;
                  <span class="Statement">delete</span> oldValue<span class="Identifier">[</span>key<span class="Identifier">]</span>;
                <span class="Identifier">}</span>
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
          <span class="Statement">return</span> changeDetected;
        <span class="Identifier">}</span>

        <span class="Identifier">function</span> $watchCollectionAction() <span class="Identifier">{</span>
          listener(newValue, oldValue, <span class="Statement">self</span>);
        <span class="Identifier">}</span>

        <span class="Statement">return</span> <span class="Identifier">this</span>.$watch($watchCollectionWatch, $watchCollectionAction);
      <span class="Identifier">}</span>,

      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$rootScope.Scope#$digest</span>
<span class="Comment">       * @methodOf ng.$rootScope.Scope</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Processes all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and</span>
<span class="Comment">       * its children. Because a {@link ng.$rootScope.Scope#$watch watcher}'s listener can change</span>
<span class="Comment">       * the model, the `$digest()` keeps calling the {@link ng.$rootScope.Scope#$watch watchers}</span>
<span class="Comment">       * until no more listeners are firing. This means that it is possible to get into an infinite</span>
<span class="Comment">       * loop. This function will throw `'Maximum iteration limit exceeded.'` if the number of</span>
<span class="Comment">       * iterations exceeds 10.</span>
<span class="Comment">       *</span>
<span class="Comment">       * Usually, you don't call `$digest()` directly in</span>
<span class="Comment">       * {@link ng.directive:ngController controllers} or in</span>
<span class="Comment">       * {@link ng.$compileProvider#methods_directive directives}.</span>
<span class="Comment">       * Instead, you should call {@link ng.$rootScope.Scope#$apply $apply()} (typically from within</span>
<span class="Comment">       * a {@link ng.$compileProvider#methods_directive directives}), which will force a `$digest()`.</span>
<span class="Comment">       *</span>
<span class="Comment">       * If you want to be notified whenever `$digest()` is called,</span>
<span class="Comment">       * you can register a `watchExpression` function with</span>
<span class="Comment">       * {@link ng.$rootScope.Scope#$watch $watch()} with no `listener`.</span>
<span class="Comment">       *</span>
<span class="Comment">       * In unit tests, you may need to call `$digest()` to simulate the scope life cycle.</span>
<span class="Comment">       *</span>
<span class="Comment">       * # Example</span>
<span class="Comment">       * &lt;pre&gt;</span>
<span class="Comment">           var scope = ...;</span>
<span class="Comment">           scope.name = 'misko';</span>
<span class="Comment">           scope.counter = 0;</span>

<span class="Comment">           expect(scope.counter).toEqual(0);</span>
<span class="Comment">           scope.$watch('name', function(newValue, oldValue) {</span>
<span class="Comment">             scope.counter = scope.counter + 1;</span>
<span class="Comment">           });</span>
<span class="Comment">           expect(scope.counter).toEqual(0);</span>

<span class="Comment">           scope.$digest();</span>
<span class="Comment">           // no variable change</span>
<span class="Comment">           expect(scope.counter).toEqual(0);</span>

<span class="Comment">           scope.name = 'adam';</span>
<span class="Comment">           scope.$digest();</span>
<span class="Comment">           expect(scope.counter).toEqual(1);</span>
<span class="Comment">       * &lt;/pre&gt;</span>
<span class="Comment">       *</span>
<span class="Comment">       */</span>
      $digest: <span class="Identifier">function</span>() <span class="Identifier">{</span>
        <span class="Identifier">var</span> watch, value, last,
            watchers,
            asyncQueue = <span class="Identifier">this</span>.$$asyncQueue,
            postDigestQueue = <span class="Identifier">this</span>.$$postDigestQueue,
            length,
            dirty, ttl = TTL,
            next, current, target = <span class="Identifier">this</span>,
            watchLog = <span class="Identifier">[]</span>,
            logIdx, logMsg, asyncTask;

        beginPhase(<span class="Constant">'$digest'</span>);

        lastDirtyWatch = <span class="Statement">null</span>;

        <span class="Statement">do</span> <span class="Identifier">{</span> <span class="Comment">// &quot;while dirty&quot; loop</span>
          dirty = <span class="Constant">false</span>;
          current = target;

          <span class="Statement">while</span>(asyncQueue.length) <span class="Identifier">{</span>
            <span class="Statement">try</span> <span class="Identifier">{</span>
              asyncTask = asyncQueue.shift();
              asyncTask.scope.$eval(asyncTask.expression);
            <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
              clearPhase();
              $exceptionHandler(e);
            <span class="Identifier">}</span>
            lastDirtyWatch = <span class="Statement">null</span>;
          <span class="Identifier">}</span>

          traverseScopesLoop:
          <span class="Statement">do</span> <span class="Identifier">{</span> <span class="Comment">// &quot;traverse the scopes&quot; loop</span>
            <span class="Statement">if</span> ((watchers = current.$$watchers)) <span class="Identifier">{</span>
              <span class="Comment">// process our watches</span>
              length = watchers.length;
              <span class="Statement">while</span> (length--) <span class="Identifier">{</span>
                <span class="Statement">try</span> <span class="Identifier">{</span>
                  watch = watchers<span class="Identifier">[</span>length<span class="Identifier">]</span>;
                  <span class="Comment">// Most common watches are on primitives, in which case we can short</span>
                  <span class="Comment">// circuit it with === operator, only when === fails do we use .equals</span>
                  <span class="Statement">if</span> (watch) <span class="Identifier">{</span>
                    <span class="Statement">if</span> ((value = watch.get(current)) !== (last = watch.last) &amp;&amp;
                        !(watch.eq
                            ? equals(value, last)
                            : (<span class="Statement">typeof</span> value == <span class="Constant">'number'</span> &amp;&amp; <span class="Statement">typeof</span> last == <span class="Constant">'number'</span>
                               &amp;&amp; isNaN(value) &amp;&amp; isNaN(last)))) <span class="Identifier">{</span>
                      dirty = <span class="Constant">true</span>;
                      lastDirtyWatch = watch;
                      watch.last = watch.eq ? copy(value) : value;
                      watch.fn(value, ((last === initWatchVal) ? value : last), current);
                      <span class="Statement">if</span> (ttl &lt; 5) <span class="Identifier">{</span>
                        logIdx = 4 - ttl;
                        <span class="Statement">if</span> (!watchLog<span class="Identifier">[</span>logIdx<span class="Identifier">]</span>) watchLog<span class="Identifier">[</span>logIdx<span class="Identifier">]</span> = <span class="Identifier">[]</span>;
                        logMsg = (isFunction(watch.exp))
                            ? <span class="Constant">'fn: '</span> + (watch.exp.name || watch.exp.toString())
                            : watch.exp;
                        logMsg += <span class="Constant">'; newVal: '</span> + toJson(value) + <span class="Constant">'; oldVal: '</span> + toJson(last);
                        watchLog<span class="Identifier">[</span>logIdx<span class="Identifier">]</span>.push(logMsg);
                      <span class="Identifier">}</span>
                    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (watch === lastDirtyWatch) <span class="Identifier">{</span>
                      <span class="Comment">// If the most recently dirty watcher is now clean, short circuit since the remaining watchers</span>
                      <span class="Comment">// have already been tested.</span>
                      dirty = <span class="Constant">false</span>;
                      <span class="Statement">break</span> traverseScopesLoop;
                    <span class="Identifier">}</span>
                  <span class="Identifier">}</span>
                <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
                  clearPhase();
                  $exceptionHandler(e);
                <span class="Identifier">}</span>
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>

            <span class="Comment">// Insanity Warning: scope depth-first traversal</span>
            <span class="Comment">// yes, this code is a bit crazy, but it works and we have tests to prove it!</span>
            <span class="Comment">// this piece should be kept in sync with the traversal in $broadcast</span>
            <span class="Statement">if</span> (!(next = (current.$$childHead ||
                (current !== target &amp;&amp; current.$$nextSibling)))) <span class="Identifier">{</span>
              <span class="Statement">while</span>(current !== target &amp;&amp; !(next = current.$$nextSibling)) <span class="Identifier">{</span>
                current = current.$<span class="Statement">parent</span>;
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>
          <span class="Identifier">}</span> <span class="Statement">while</span> ((current = next));

          <span class="Comment">// `break traverseScopesLoop;` takes us to here</span>

          <span class="Statement">if</span>(dirty &amp;&amp; !(ttl--)) <span class="Identifier">{</span>
            clearPhase();
            <span class="Statement">throw</span> $rootScopeMinErr(<span class="Constant">'infdig'</span>,
                <span class="Constant">'{0} $digest() iterations reached. Aborting!</span><span class="Special">\n</span><span class="Constant">'</span> +
                <span class="Constant">'Watchers fired in the last 5 iterations: {1}'</span>,
                TTL, toJson(watchLog));
          <span class="Identifier">}</span>

        <span class="Identifier">}</span> <span class="Statement">while</span> (dirty || asyncQueue.length);

        clearPhase();

        <span class="Statement">while</span>(postDigestQueue.length) <span class="Identifier">{</span>
          <span class="Statement">try</span> <span class="Identifier">{</span>
            postDigestQueue.shift()();
          <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
            $exceptionHandler(e);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>,


      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc event</span>
<span class="Comment">       * @name ng.$rootScope.Scope#$destroy</span>
<span class="Comment">       * @eventOf ng.$rootScope.Scope</span>
<span class="Comment">       * @eventType broadcast on scope being destroyed</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Broadcasted when a scope and its children are being destroyed.</span>
<span class="Comment">       *</span>
<span class="Comment">       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to</span>
<span class="Comment">       * clean up DOM bindings before an element is removed from the DOM.</span>
<span class="Comment">       */</span>

      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$rootScope.Scope#$destroy</span>
<span class="Comment">       * @methodOf ng.$rootScope.Scope</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Removes the current scope (and all of its children) from the parent scope. Removal implies</span>
<span class="Comment">       * that calls to {@link ng.$rootScope.Scope#$digest $digest()} will no longer</span>
<span class="Comment">       * propagate to the current scope and its children. Removal also implies that the current</span>
<span class="Comment">       * scope is eligible for garbage collection.</span>
<span class="Comment">       *</span>
<span class="Comment">       * The `$destroy()` is usually used by directives such as</span>
<span class="Comment">       * {@link ng.directive:ngRepeat ngRepeat} for managing the</span>
<span class="Comment">       * unrolling of the loop.</span>
<span class="Comment">       *</span>
<span class="Comment">       * Just before a scope is destroyed, a `$destroy` event is broadcasted on this scope.</span>
<span class="Comment">       * Application code can register a `$destroy` event handler that will give it a chance to</span>
<span class="Comment">       * perform any necessary cleanup.</span>
<span class="Comment">       *</span>
<span class="Comment">       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to</span>
<span class="Comment">       * clean up DOM bindings before an element is removed from the DOM.</span>
<span class="Comment">       */</span>
      $destroy: <span class="Identifier">function</span>() <span class="Identifier">{</span>
        <span class="Comment">// we can't destroy the root scope or a scope that has been already destroyed</span>
        <span class="Statement">if</span> (<span class="Identifier">this</span>.$$destroyed) <span class="Statement">return</span>;
        <span class="Identifier">var</span> <span class="Statement">parent</span> = <span class="Identifier">this</span>.$<span class="Statement">parent</span>;

        <span class="Identifier">this</span>.$broadcast(<span class="Constant">'$destroy'</span>);
        <span class="Identifier">this</span>.$$destroyed = <span class="Constant">true</span>;
        <span class="Statement">if</span> (<span class="Identifier">this</span> === $rootScope) <span class="Statement">return</span>;

        <span class="Statement">if</span> (<span class="Statement">parent</span>.$$childHead == <span class="Identifier">this</span>) <span class="Statement">parent</span>.$$childHead = <span class="Identifier">this</span>.$$nextSibling;
        <span class="Statement">if</span> (<span class="Statement">parent</span>.$$childTail == <span class="Identifier">this</span>) <span class="Statement">parent</span>.$$childTail = <span class="Identifier">this</span>.$$prevSibling;
        <span class="Statement">if</span> (<span class="Identifier">this</span>.$$prevSibling) <span class="Identifier">this</span>.$$prevSibling.$$nextSibling = <span class="Identifier">this</span>.$$nextSibling;
        <span class="Statement">if</span> (<span class="Identifier">this</span>.$$nextSibling) <span class="Identifier">this</span>.$$nextSibling.$$prevSibling = <span class="Identifier">this</span>.$$prevSibling;

        <span class="Comment">// This is bogus code that works around Chrome's GC leak</span>
        <span class="Comment">// see: <a href="https://github.com/angular/angular.js/issues/1313#issuecomment-10378451">https://github.com/angular/angular.js/issues/1313#issuecomment-10378451</a></span>
        <span class="Identifier">this</span>.$<span class="Statement">parent</span> = <span class="Identifier">this</span>.$$nextSibling = <span class="Identifier">this</span>.$$prevSibling = <span class="Identifier">this</span>.$$childHead =
            <span class="Identifier">this</span>.$$childTail = <span class="Statement">null</span>;
      <span class="Identifier">}</span>,

      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$rootScope.Scope#$eval</span>
<span class="Comment">       * @methodOf ng.$rootScope.Scope</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Executes the `expression` on the current scope and returns the result. Any exceptions in</span>
<span class="Comment">       * the expression are propagated (uncaught). This is useful when evaluating Angular</span>
<span class="Comment">       * expressions.</span>
<span class="Comment">       *</span>
<span class="Comment">       * # Example</span>
<span class="Comment">       * &lt;pre&gt;</span>
<span class="Comment">           var scope = ng.$rootScope.Scope();</span>
<span class="Comment">           scope.a = 1;</span>
<span class="Comment">           scope.b = 2;</span>

<span class="Comment">           expect(scope.$eval('a+b')).toEqual(3);</span>
<span class="Comment">           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);</span>
<span class="Comment">       * &lt;/pre&gt;</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {(string|function())=} expression An angular expression to be executed.</span>
<span class="Comment">       *</span>
<span class="Comment">       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.</span>
<span class="Comment">       *    - `function(scope)`: execute the function with the current `scope` parameter.</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {(object)=} locals Local variables object, useful for overriding values in scope.</span>
<span class="Comment">       * @returns {*} The result of evaluating the expression.</span>
<span class="Comment">       */</span>
      $eval: <span class="Identifier">function</span>(expr, locals) <span class="Identifier">{</span>
        <span class="Statement">return</span> $parse(expr)(<span class="Identifier">this</span>, locals);
      <span class="Identifier">}</span>,

      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$rootScope.Scope#$evalAsync</span>
<span class="Comment">       * @methodOf ng.$rootScope.Scope</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Executes the expression on the current scope at a later point in time.</span>
<span class="Comment">       *</span>
<span class="Comment">       * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only</span>
<span class="Comment">       * that:</span>
<span class="Comment">       *</span>
<span class="Comment">       *   - it will execute after the function that scheduled the evaluation (preferably before DOM</span>
<span class="Comment">       *     rendering).</span>
<span class="Comment">       *   - at least one {@link ng.$rootScope.Scope#$digest $digest cycle} will be performed after</span>
<span class="Comment">       *     `expression` execution.</span>
<span class="Comment">       *</span>
<span class="Comment">       * Any exceptions from the execution of the expression are forwarded to the</span>
<span class="Comment">       * {@link ng.$exceptionHandler $exceptionHandler} service.</span>
<span class="Comment">       *</span>
<span class="Comment">       * __Note:__ if this function is called outside of a `$digest` cycle, a new `$digest` cycle</span>
<span class="Comment">       * will be scheduled. However, it is encouraged to always call code that changes the model</span>
<span class="Comment">       * from within an `$apply` call. That includes code evaluated via `$evalAsync`.</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {(string|function())=} expression An angular expression to be executed.</span>
<span class="Comment">       *</span>
<span class="Comment">       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.</span>
<span class="Comment">       *    - `function(scope)`: execute the function with the current `scope` parameter.</span>
<span class="Comment">       *</span>
<span class="Comment">       */</span>
      $evalAsync: <span class="Identifier">function</span>(expr) <span class="Identifier">{</span>
        <span class="Comment">// if we are outside of an $digest loop and this is the first time we are scheduling async</span>
        <span class="Comment">// task also schedule async auto-flush</span>
        <span class="Statement">if</span> (!$rootScope.$$phase &amp;&amp; !$rootScope.$$asyncQueue.length) <span class="Identifier">{</span>
          $browser.defer(<span class="Identifier">function</span>() <span class="Identifier">{</span>
            <span class="Statement">if</span> ($rootScope.$$asyncQueue.length) <span class="Identifier">{</span>
              $rootScope.$digest();
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>

        <span class="Identifier">this</span>.$$asyncQueue.push(<span class="Identifier">{</span>scope: <span class="Identifier">this</span>, expression: expr<span class="Identifier">}</span>);
      <span class="Identifier">}</span>,

      $$postDigest : <span class="Identifier">function</span>(fn) <span class="Identifier">{</span>
        <span class="Identifier">this</span>.$$postDigestQueue.push(fn);
      <span class="Identifier">}</span>,

      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$rootScope.Scope#$apply</span>
<span class="Comment">       * @methodOf ng.$rootScope.Scope</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * `$apply()` is used to execute an expression in angular from outside of the angular</span>
<span class="Comment">       * framework. (For example from browser DOM events, setTimeout, XHR or third party libraries).</span>
<span class="Comment">       * Because we are calling into the angular framework we need to perform proper scope life</span>
<span class="Comment">       * cycle of {@link ng.$exceptionHandler exception handling},</span>
<span class="Comment">       * {@link ng.$rootScope.Scope#$digest executing watches}.</span>
<span class="Comment">       *</span>
<span class="Comment">       * ## Life cycle</span>
<span class="Comment">       *</span>
<span class="Comment">       * # Pseudo-Code of `$apply()`</span>
<span class="Comment">       * &lt;pre&gt;</span>
<span class="Comment">           function $apply(expr) {</span>
<span class="Comment">             try {</span>
<span class="Comment">               return $eval(expr);</span>
<span class="Comment">             } catch (e) {</span>
<span class="Comment">               $exceptionHandler(e);</span>
<span class="Comment">             } finally {</span>
<span class="Comment">               $root.$digest();</span>
<span class="Comment">             }</span>
<span class="Comment">           }</span>
<span class="Comment">       * &lt;/pre&gt;</span>
<span class="Comment">       *</span>
<span class="Comment">       *</span>
<span class="Comment">       * Scope's `$apply()` method transitions through the following stages:</span>
<span class="Comment">       *</span>
<span class="Comment">       * 1. The {@link guide/expression expression} is executed using the</span>
<span class="Comment">       *    {@link ng.$rootScope.Scope#$eval $eval()} method.</span>
<span class="Comment">       * 2. Any exceptions from the execution of the expression are forwarded to the</span>
<span class="Comment">       *    {@link ng.$exceptionHandler $exceptionHandler} service.</span>
<span class="Comment">       * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the</span>
<span class="Comment">       *    expression was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method.</span>
<span class="Comment">       *</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {(string|function())=} exp An angular expression to be executed.</span>
<span class="Comment">       *</span>
<span class="Comment">       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.</span>
<span class="Comment">       *    - `function(scope)`: execute the function with current `scope` parameter.</span>
<span class="Comment">       *</span>
<span class="Comment">       * @returns {*} The result of evaluating the expression.</span>
<span class="Comment">       */</span>
      $apply: <span class="Identifier">function</span>(expr) <span class="Identifier">{</span>
        <span class="Statement">try</span> <span class="Identifier">{</span>
          beginPhase(<span class="Constant">'$apply'</span>);
          <span class="Statement">return</span> <span class="Identifier">this</span>.$eval(expr);
        <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
          $exceptionHandler(e);
        <span class="Identifier">}</span> <span class="Statement">finally</span> <span class="Identifier">{</span>
          clearPhase();
          <span class="Statement">try</span> <span class="Identifier">{</span>
            $rootScope.$digest();
          <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
            $exceptionHandler(e);
            <span class="Statement">throw</span> e;
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>,

      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$rootScope.Scope#$on</span>
<span class="Comment">       * @methodOf ng.$rootScope.Scope</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for</span>
<span class="Comment">       * discussion of event life cycle.</span>
<span class="Comment">       *</span>
<span class="Comment">       * The event listener function format is: `function(event, args...)`. The `event` object</span>
<span class="Comment">       * passed into the listener has the following attributes:</span>
<span class="Comment">       *</span>
<span class="Comment">       *   - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or</span>
<span class="Comment">       *     `$broadcast`-ed.</span>
<span class="Comment">       *   - `currentScope` - `{Scope}`: the current scope which is handling the event.</span>
<span class="Comment">       *   - `name` - `{string}`: name of the event.</span>
<span class="Comment">       *   - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel</span>
<span class="Comment">       *     further event propagation (available only for events that were `$emit`-ed).</span>
<span class="Comment">       *   - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag</span>
<span class="Comment">       *     to true.</span>
<span class="Comment">       *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {string} name Event name to listen on.</span>
<span class="Comment">       * @param {function(event, args...)} listener Function to call when the event is emitted.</span>
<span class="Comment">       * @returns {function()} Returns a deregistration function for this listener.</span>
<span class="Comment">       */</span>
      $on: <span class="Identifier">function</span>(name, listener) <span class="Identifier">{</span>
        <span class="Identifier">var</span> namedListeners = <span class="Identifier">this</span>.$$listeners<span class="Identifier">[</span>name<span class="Identifier">]</span>;
        <span class="Statement">if</span> (!namedListeners) <span class="Identifier">{</span>
          <span class="Identifier">this</span>.$$listeners<span class="Identifier">[</span>name<span class="Identifier">]</span> = namedListeners = <span class="Identifier">[]</span>;
        <span class="Identifier">}</span>
        namedListeners.push(listener);

        <span class="Statement">return</span> <span class="Identifier">function</span>() <span class="Identifier">{</span>
          namedListeners<span class="Identifier">[</span>indexOf(namedListeners, listener)<span class="Identifier">]</span> = <span class="Statement">null</span>;
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span>,


      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$rootScope.Scope#$emit</span>
<span class="Comment">       * @methodOf ng.$rootScope.Scope</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Dispatches an event `name` upwards through the scope hierarchy notifying the</span>
<span class="Comment">       * registered {@link ng.$rootScope.Scope#$on} listeners.</span>
<span class="Comment">       *</span>
<span class="Comment">       * The event life cycle starts at the scope on which `$emit` was called. All</span>
<span class="Comment">       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get</span>
<span class="Comment">       * notified. Afterwards, the event traverses upwards toward the root scope and calls all</span>
<span class="Comment">       * registered listeners along the way. The event will stop propagating if one of the listeners</span>
<span class="Comment">       * cancels it.</span>
<span class="Comment">       *</span>
<span class="Comment">       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed</span>
<span class="Comment">       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {string} name Event name to emit.</span>
<span class="Comment">       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.</span>
<span class="Comment">       * @return {Object} Event object (see {@link ng.$rootScope.Scope#$on}).</span>
<span class="Comment">       */</span>
      $emit: <span class="Identifier">function</span>(name, args) <span class="Identifier">{</span>
        <span class="Identifier">var</span> empty = <span class="Identifier">[]</span>,
            namedListeners,
            scope = <span class="Identifier">this</span>,
            stopPropagation = <span class="Constant">false</span>,
            <span class="Statement">event</span> = <span class="Identifier">{</span>
              name: name,
              targetScope: scope,
              stopPropagation: <span class="Identifier">function</span>() <span class="Identifier">{</span>stopPropagation = <span class="Constant">true</span>;<span class="Identifier">}</span>,
              preventDefault: <span class="Identifier">function</span>() <span class="Identifier">{</span>
                <span class="Statement">event</span>.defaultPrevented = <span class="Constant">true</span>;
              <span class="Identifier">}</span>,
              defaultPrevented: <span class="Constant">false</span>
            <span class="Identifier">}</span>,
            listenerArgs = concat(<span class="Identifier">[</span><span class="Statement">event</span><span class="Identifier">]</span>, <span class="Identifier">arguments</span>, 1),
            i, length;

        <span class="Statement">do</span> <span class="Identifier">{</span>
          namedListeners = scope.$$listeners<span class="Identifier">[</span>name<span class="Identifier">]</span> || empty;
          <span class="Statement">event</span>.currentScope = scope;
          <span class="Statement">for</span> (i=0, length=namedListeners.length; i&lt;length; i++) <span class="Identifier">{</span>

            <span class="Comment">// if listeners were deregistered, defragment the array</span>
            <span class="Statement">if</span> (!namedListeners<span class="Identifier">[</span>i<span class="Identifier">]</span>) <span class="Identifier">{</span>
              namedListeners.splice(i, 1);
              i--;
              length--;
              <span class="Statement">continue</span>;
            <span class="Identifier">}</span>
            <span class="Statement">try</span> <span class="Identifier">{</span>
              <span class="Comment">//allow all listeners attached to the current scope to run</span>
              namedListeners<span class="Identifier">[</span>i<span class="Identifier">]</span>.apply(<span class="Statement">null</span>, listenerArgs);
            <span class="Identifier">}</span> <span class="Statement">catch</span> (e) <span class="Identifier">{</span>
              $exceptionHandler(e);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
          <span class="Comment">//if any listener on the current scope stops propagation, prevent bubbling</span>
          <span class="Statement">if</span> (stopPropagation) <span class="Statement">return</span> <span class="Statement">event</span>;
          <span class="Comment">//traverse upwards</span>
          scope = scope.$<span class="Statement">parent</span>;
        <span class="Identifier">}</span> <span class="Statement">while</span> (scope);

        <span class="Statement">return</span> <span class="Statement">event</span>;
      <span class="Identifier">}</span>,


      <span class="Comment">/**</span>
<span class="Comment">       * @ngdoc function</span>
<span class="Comment">       * @name ng.$rootScope.Scope#$broadcast</span>
<span class="Comment">       * @methodOf ng.$rootScope.Scope</span>
<span class="Comment">       * @function</span>
<span class="Comment">       *</span>
<span class="Comment">       * @description</span>
<span class="Comment">       * Dispatches an event `name` downwards to all child scopes (and their children) notifying the</span>
<span class="Comment">       * registered {@link ng.$rootScope.Scope#$on} listeners.</span>
<span class="Comment">       *</span>
<span class="Comment">       * The event life cycle starts at the scope on which `$broadcast` was called. All</span>
<span class="Comment">       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get</span>
<span class="Comment">       * notified. Afterwards, the event propagates to all direct and indirect scopes of the current</span>
<span class="Comment">       * scope and calls all registered listeners along the way. The event cannot be canceled.</span>
<span class="Comment">       *</span>
<span class="Comment">       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed</span>
<span class="Comment">       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.</span>
<span class="Comment">       *</span>
<span class="Comment">       * @param {string} name Event name to broadcast.</span>
<span class="Comment">       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.</span>
<span class="Comment">       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}</span>
<span class="Comment">       */</span>
      $broadcast: <span class="Identifier">function</span>(name, args) <span class="Identifier">{</span>
        <span class="Identifier">var</span> target = <span class="Identifier">this</span>,
            current = target,
            next = target,
            <span class="Statement">event</span> = <span class="Identifier">{</span>
              name: name,
              targetScope: target,
              preventDefault: <span class="Identifier">function</span>() <span class="Identifier">{</span>
                <span class="Statement">event</span>.defaultPrevented = <span class="Constant">true</span>;
              <span class="Identifier">}</span>,
              defaultPrevented: <span class="Constant">false</span>
            <span class="Identifier">}</span>,
            listenerArgs = concat(<span class="Identifier">[</span><span class="Statement">event</span><span class="Identifier">]</span>, <span class="Identifier">arguments</span>, 1),
            listeners, i, length;

        <span class="Comment">//down while you can, then up and next sibling or up and next sibling until back at root</span>
        <span class="Statement">do</span> <span class="Identifier">{</span>
          current = next;
          <span class="Statement">event</span>.currentScope = current;
          listeners = current.$$listeners<span class="Identifier">[</span>name<span class="Identifier">]</span> || <span class="Identifier">[]</span>;
          <span class="Statement">for</span> (i=0, length = listeners.length; i&lt;length; i++) <span class="Identifier">{</span>
            <span class="Comment">// if listeners were deregistered, defragment the array</span>
            <span class="Statement">if</span> (!listeners<span class="Identifier">[</span>i<span class="Identifier">]</span>) <span class="Identifier">{</span>
              listeners.splice(i, 1);
              i--;
              length--;
              <span class="Statement">continue</span>;
            <span class="Identifier">}</span>

            <span class="Statement">try</span> <span class="Identifier">{</span>
              listeners<span class="Identifier">[</span>i<span class="Identifier">]</span>.apply(<span class="Statement">null</span>, listenerArgs);
            <span class="Identifier">}</span> <span class="Statement">catch</span>(e) <span class="Identifier">{</span>
              $exceptionHandler(e);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>

          <span class="Comment">// Insanity Warning: scope depth-first traversal</span>
          <span class="Comment">// yes, this code is a bit crazy, but it works and we have tests to prove it!</span>
          <span class="Comment">// this piece should be kept in sync with the traversal in $digest</span>
          <span class="Statement">if</span> (!(next = (current.$$childHead || (current !== target &amp;&amp; current.$$nextSibling)))) <span class="Identifier">{</span>
            <span class="Statement">while</span>(current !== target &amp;&amp; !(next = current.$$nextSibling)) <span class="Identifier">{</span>
              current = current.$<span class="Statement">parent</span>;
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
        <span class="Identifier">}</span> <span class="Statement">while</span> ((current = next));

        <span class="Statement">return</span> <span class="Statement">event</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;

    <span class="Identifier">var</span> $rootScope = <span class="Statement">new</span> Scope();

    <span class="Statement">return</span> $rootScope;


    <span class="Identifier">function</span> beginPhase(phase) <span class="Identifier">{</span>
      <span class="Statement">if</span> ($rootScope.$$phase) <span class="Identifier">{</span>
        <span class="Statement">throw</span> $rootScopeMinErr(<span class="Constant">'inprog'</span>, <span class="Constant">'{0} already in progress'</span>, $rootScope.$$phase);
      <span class="Identifier">}</span>

      $rootScope.$$phase = phase;
    <span class="Identifier">}</span>

    <span class="Identifier">function</span> clearPhase() <span class="Identifier">{</span>
      $rootScope.$$phase = <span class="Statement">null</span>;
    <span class="Identifier">}</span>

    <span class="Identifier">function</span> compileToFn(exp, name) <span class="Identifier">{</span>
      <span class="Identifier">var</span> fn = $parse(exp);
      assertArgFn(fn, name);
      <span class="Statement">return</span> fn;
    <span class="Identifier">}</span>

    <span class="Comment">/**</span>
<span class="Comment">     * function used as an initial value for watchers.</span>
<span class="Comment">     * because it's unique we can easily tell it apart from other values</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> initWatchVal() <span class="Identifier">{}</span>
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Private service to sanitize uris for links and images. Used by $compile and $sanitize.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $$SanitizeUriProvider() <span class="Identifier">{</span>
  <span class="Identifier">var</span> aHrefSanitizationWhitelist = <span class="Constant">/^\s*(https?|ftp|mailto|tel|file):/</span>,
    imgSrcSanitizationWhitelist = <span class="Constant">/^\s*(https?|ftp|file):|data:image\//</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Retrieves or overrides the default regular expression that is used for whitelisting of safe</span>
<span class="Comment">   * urls during a[href] sanitization.</span>
<span class="Comment">   *</span>
<span class="Comment">   * The sanitization is a security measure aimed at prevent XSS attacks via html links.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into</span>
<span class="Comment">   * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`</span>
<span class="Comment">   * regular expression. If a match is found, the original url is written into the dom. Otherwise,</span>
<span class="Comment">   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {RegExp=} regexp New regexp to whitelist urls with.</span>
<span class="Comment">   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for</span>
<span class="Comment">   *    chaining otherwise.</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.aHrefSanitizationWhitelist = <span class="Identifier">function</span>(regexp) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isDefined(regexp)) <span class="Identifier">{</span>
      aHrefSanitizationWhitelist = regexp;
      <span class="Statement">return</span> <span class="Identifier">this</span>;
    <span class="Identifier">}</span>
    <span class="Statement">return</span> aHrefSanitizationWhitelist;
  <span class="Identifier">}</span>;


  <span class="Comment">/**</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Retrieves or overrides the default regular expression that is used for whitelisting of safe</span>
<span class="Comment">   * urls during img[src] sanitization.</span>
<span class="Comment">   *</span>
<span class="Comment">   * The sanitization is a security measure aimed at prevent XSS attacks via html links.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Any url about to be assigned to img[src] via data-binding is first normalized and turned into</span>
<span class="Comment">   * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist`</span>
<span class="Comment">   * regular expression. If a match is found, the original url is written into the dom. Otherwise,</span>
<span class="Comment">   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {RegExp=} regexp New regexp to whitelist urls with.</span>
<span class="Comment">   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for</span>
<span class="Comment">   *    chaining otherwise.</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.imgSrcSanitizationWhitelist = <span class="Identifier">function</span>(regexp) <span class="Identifier">{</span>
    <span class="Statement">if</span> (isDefined(regexp)) <span class="Identifier">{</span>
      imgSrcSanitizationWhitelist = regexp;
      <span class="Statement">return</span> <span class="Identifier">this</span>;
    <span class="Identifier">}</span>
    <span class="Statement">return</span> imgSrcSanitizationWhitelist;
  <span class="Identifier">}</span>;

  <span class="Identifier">this</span>.$get = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">function</span> sanitizeUri(uri, isImage) <span class="Identifier">{</span>
      <span class="Identifier">var</span> regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
      <span class="Identifier">var</span> normalizedVal;
      <span class="Comment">// NOTE: urlResolve() doesn't support IE &lt; 8 so we don't sanitize for that case.</span>
      <span class="Statement">if</span> (!msie || msie &gt;= 8 ) <span class="Identifier">{</span>
        normalizedVal = urlResolve(uri).href;
        <span class="Statement">if</span> (normalizedVal !== <span class="Constant">''</span> &amp;&amp; !normalizedVal.match(regex)) <span class="Identifier">{</span>
          <span class="Statement">return</span> <span class="Constant">'unsafe:'</span>+normalizedVal;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
      <span class="Statement">return</span> uri;
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Identifier">var</span> $sceMinErr = minErr(<span class="Constant">'$sce'</span>);

<span class="Identifier">var</span> SCE_CONTEXTS = <span class="Identifier">{</span>
  HTML: <span class="Constant">'html'</span>,
  CSS: <span class="Constant">'css'</span>,
  URL: <span class="Constant">'url'</span>,
  <span class="Comment">// RESOURCE_URL is a subtype of URL used in contexts where a privileged resource is sourced from a</span>
  <span class="Comment">// url.  (e.g. ng-include, script src, templateUrl)</span>
  RESOURCE_URL: <span class="Constant">'resourceUrl'</span>,
  JS: <span class="Constant">'js'</span>
<span class="Identifier">}</span>;

<span class="Comment">// Helper functions follow.</span>

<span class="Comment">// Copied from:</span>
<span class="Comment">// <a href="http://docs.closure-library.googlecode.com/git/closure_goog_string_string.js.source.html#line962">http://docs.closure-library.googlecode.com/git/closure_goog_string_string.js.source.html#line962</a></span>
<span class="Comment">// Prereq: s is a string.</span>
<span class="Identifier">function</span> escapeForRegexp(s) <span class="Identifier">{</span>
  <span class="Statement">return</span> s.replace(<span class="Constant">/([-()\[\]{}+?*.$\^|,:#&lt;!\\])/g</span>, <span class="Constant">'</span><span class="Special">\\</span><span class="Constant">$1'</span>).
           replace(<span class="Constant">/\x08/g</span>, <span class="Constant">'</span><span class="Special">\\</span><span class="Constant">x08'</span>);
<span class="Identifier">}</span>


<span class="Identifier">function</span> adjustMatcher(matcher) <span class="Identifier">{</span>
  <span class="Statement">if</span> (matcher === <span class="Constant">'self'</span>) <span class="Identifier">{</span>
    <span class="Statement">return</span> matcher;
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isString(matcher)) <span class="Identifier">{</span>
    <span class="Comment">// Strings match exactly except for 2 wildcards - '*' and '**'.</span>
    <span class="Comment">// '*' matches any character except those from the set ':/.?&amp;'.</span>
    <span class="Comment">// '**' matches any character (like .* in a RegExp).</span>
    <span class="Comment">// More than 2 *'s raises an error as it's ill defined.</span>
    <span class="Statement">if</span> (matcher.indexOf(<span class="Constant">'***'</span>) &gt; -1) <span class="Identifier">{</span>
      <span class="Statement">throw</span> $sceMinErr(<span class="Constant">'iwcard'</span>,
          <span class="Constant">'Illegal sequence *** in string matcher.  String: {0}'</span>, matcher);
    <span class="Identifier">}</span>
    matcher = escapeForRegexp(matcher).
                  replace(<span class="Constant">'</span><span class="Special">\\</span><span class="Constant">*</span><span class="Special">\\</span><span class="Constant">*'</span>, <span class="Constant">'.*'</span>).
                  replace(<span class="Constant">'</span><span class="Special">\\</span><span class="Constant">*'</span>, <span class="Constant">'[^:/.?&amp;;]*'</span>);
    <span class="Statement">return</span> <span class="Statement">new</span> <span class="Type">RegExp</span>(<span class="Constant">'^'</span> + matcher + <span class="Constant">'$'</span>);
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isRegExp(matcher)) <span class="Identifier">{</span>
    <span class="Comment">// The only other type of matcher allowed is a Regexp.</span>
    <span class="Comment">// Match entire URL / disallow partial matches.</span>
    <span class="Comment">// Flags are reset (i.e. no global, ignoreCase or multiline)</span>
    <span class="Statement">return</span> <span class="Statement">new</span> <span class="Type">RegExp</span>(<span class="Constant">'^'</span> + matcher.source + <span class="Constant">'$'</span>);
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
    <span class="Statement">throw</span> $sceMinErr(<span class="Constant">'imatcher'</span>,
        <span class="Constant">'Matchers may only be &quot;self&quot;, string patterns or RegExp objects'</span>);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>


<span class="Identifier">function</span> adjustMatchers(matchers) <span class="Identifier">{</span>
  <span class="Identifier">var</span> adjustedMatchers = <span class="Identifier">[]</span>;
  <span class="Statement">if</span> (isDefined(matchers)) <span class="Identifier">{</span>
    forEach(matchers, <span class="Identifier">function</span>(matcher) <span class="Identifier">{</span>
      adjustedMatchers.push(adjustMatcher(matcher));
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>
  <span class="Statement">return</span> adjustedMatchers;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc service</span>
<span class="Comment"> * @name ng.$sceDelegate</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * `$sceDelegate` is a service that is used by the `$sce` service to provide {@link ng.$sce Strict</span>
<span class="Comment"> * Contextual Escaping (SCE)} services to AngularJS.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Typically, you would configure or override the {@link ng.$sceDelegate $sceDelegate} instead of</span>
<span class="Comment"> * the `$sce` service to customize the way Strict Contextual Escaping works in AngularJS.  This is</span>
<span class="Comment"> * because, while the `$sce` provides numerous shorthand methods, etc., you really only need to</span>
<span class="Comment"> * override 3 core functions (`trustAs`, `getTrusted` and `valueOf`) to replace the way things</span>
<span class="Comment"> * work because `$sce` delegates to `$sceDelegate` for these operations.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} to configure this service.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The default instance of `$sceDelegate` should work out of the box with little pain.  While you</span>
<span class="Comment"> * can override it completely to change the behavior of `$sce`, the common case would</span>
<span class="Comment"> * involve configuring the {@link ng.$sceDelegateProvider $sceDelegateProvider} instead by setting</span>
<span class="Comment"> * your own whitelists and blacklists for trusting URLs used for loading AngularJS resources such as</span>
<span class="Comment"> * templates.  Refer {@link ng.$sceDelegateProvider#methods_resourceUrlWhitelist</span>
<span class="Comment"> * $sceDelegateProvider.resourceUrlWhitelist} and {@link</span>
<span class="Comment"> * ng.$sceDelegateProvider#methods_resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$sceDelegateProvider</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * The `$sceDelegateProvider` provider allows developers to configure the {@link ng.$sceDelegate</span>
<span class="Comment"> * $sceDelegate} service.  This allows one to get/set the whitelists and blacklists used to ensure</span>
<span class="Comment"> * that the URLs used for sourcing Angular templates are safe.  Refer {@link</span>
<span class="Comment"> * ng.$sceDelegateProvider#methods_resourceUrlWhitelist $sceDelegateProvider.resourceUrlWhitelist} and</span>
<span class="Comment"> * {@link ng.$sceDelegateProvider#methods_resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}</span>
<span class="Comment"> *</span>
<span class="Comment"> * For the general details about this service in Angular, read the main page for {@link ng.$sce</span>
<span class="Comment"> * Strict Contextual Escaping (SCE)}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * **Example**:  Consider the following case. &lt;a name=&quot;example&quot;&gt;&lt;/a&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * - your app is hosted at url `<a href="http://myapp.example.com/`">http://myapp.example.com/`</a></span>
<span class="Comment"> * - but some of your templates are hosted on other domains you control such as</span>
<span class="Comment"> *   `<a href="http://srv01.assets.example.com/`, ">http://srv01.assets.example.com/`, </a> `<a href="http://srv02.assets.example.com/`">http://srv02.assets.example.com/`</a>, etc.</span>
<span class="Comment"> * - and you have an open redirect at `<a href="http://myapp.example.com/clickThru?...`.">http://myapp.example.com/clickThru?...`.</a></span>
<span class="Comment"> *</span>
<span class="Comment"> * Here is what a secure configuration for this scenario might look like:</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre class=&quot;prettyprint&quot;&gt;</span>
<span class="Comment"> *    angular.module('myApp', []).config(function($sceDelegateProvider) {</span>
<span class="Comment"> *      $sceDelegateProvider.resourceUrlWhitelist([</span>
<span class="Comment"> *        // Allow same origin resource loads.</span>
<span class="Comment"> *        'self',</span>
<span class="Comment"> *        // Allow loading from our assets domain.  Notice the difference between * and **.</span>
<span class="Comment"> *        '<a href="http://srv*.assets.example.com/**">http://srv*.assets.example.com/**</a>']);</span>
<span class="Comment"> *</span>
<span class="Comment"> *      // The blacklist overrides the whitelist so the open redirect here is blocked.</span>
<span class="Comment"> *      $sceDelegateProvider.resourceUrlBlacklist([</span>
<span class="Comment"> *        '<a href="http://myapp.example.com/clickThru**">http://myapp.example.com/clickThru**</a>']);</span>
<span class="Comment"> *      });</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> */</span>

<span class="Identifier">function</span> $SceDelegateProvider() <span class="Identifier">{</span>
  <span class="Identifier">this</span>.SCE_CONTEXTS = SCE_CONTEXTS;

  <span class="Comment">// Resource URLs can also be trusted by policy.</span>
  <span class="Identifier">var</span> resourceUrlWhitelist = <span class="Identifier">[</span><span class="Constant">'self'</span><span class="Identifier">]</span>,
      resourceUrlBlacklist = <span class="Identifier">[]</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.sceDelegateProvider#resourceUrlWhitelist</span>
<span class="Comment">   * @methodOf ng.$sceDelegateProvider</span>
<span class="Comment">   * @function</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {Array=} whitelist When provided, replaces the resourceUrlWhitelist with the value</span>
<span class="Comment">   *     provided.  This must be an array or null.  A snapshot of this array is used so further</span>
<span class="Comment">   *     changes to the array are ignored.</span>
<span class="Comment">   *</span>
<span class="Comment">   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items</span>
<span class="Comment">   *     allowed in this array.</span>
<span class="Comment">   *</span>
<span class="Comment">   *     Note: **an empty whitelist array will block all URLs**!</span>
<span class="Comment">   *</span>
<span class="Comment">   * @return {Array} the currently set whitelist array.</span>
<span class="Comment">   *</span>
<span class="Comment">   * The **default value** when no whitelist has been explicitly set is `['self']` allowing only</span>
<span class="Comment">   * same origin resource requests.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Sets/Gets the whitelist of trusted resource URLs.</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.resourceUrlWhitelist = <span class="Identifier">function</span> (value) <span class="Identifier">{</span>
    <span class="Statement">if</span> (<span class="Identifier">arguments</span>.length) <span class="Identifier">{</span>
      resourceUrlWhitelist = adjustMatchers(value);
    <span class="Identifier">}</span>
    <span class="Statement">return</span> resourceUrlWhitelist;
  <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.sceDelegateProvider#resourceUrlBlacklist</span>
<span class="Comment">   * @methodOf ng.$sceDelegateProvider</span>
<span class="Comment">   * @function</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {Array=} blacklist When provided, replaces the resourceUrlBlacklist with the value</span>
<span class="Comment">   *     provided.  This must be an array or null.  A snapshot of this array is used so further</span>
<span class="Comment">   *     changes to the array are ignored.</span>
<span class="Comment">   *</span>
<span class="Comment">   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items</span>
<span class="Comment">   *     allowed in this array.</span>
<span class="Comment">   *</span>
<span class="Comment">   *     The typical usage for the blacklist is to **block</span>
<span class="Comment">   *     [open redirects](<a href="http://cwe.mitre.org/data/definitions/601.html)**">http://cwe.mitre.org/data/definitions/601.html)**</a> served by your domain as</span>
<span class="Comment">   *     these would otherwise be trusted but actually return content from the redirected domain.</span>
<span class="Comment">   *</span>
<span class="Comment">   *     Finally, **the blacklist overrides the whitelist** and has the final say.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @return {Array} the currently set blacklist array.</span>
<span class="Comment">   *</span>
<span class="Comment">   * The **default value** when no whitelist has been explicitly set is the empty array (i.e. there</span>
<span class="Comment">   * is no blacklist.)</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Sets/Gets the blacklist of trusted resource URLs.</span>
<span class="Comment">   */</span>

  <span class="Identifier">this</span>.resourceUrlBlacklist = <span class="Identifier">function</span> (value) <span class="Identifier">{</span>
    <span class="Statement">if</span> (<span class="Identifier">arguments</span>.length) <span class="Identifier">{</span>
      resourceUrlBlacklist = adjustMatchers(value);
    <span class="Identifier">}</span>
    <span class="Statement">return</span> resourceUrlBlacklist;
  <span class="Identifier">}</span>;

  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$injector'</span>, <span class="Identifier">function</span>($injector) <span class="Identifier">{</span>

    <span class="Identifier">var</span> htmlSanitizer = <span class="Identifier">function</span> htmlSanitizer(html) <span class="Identifier">{</span>
      <span class="Statement">throw</span> $sceMinErr(<span class="Constant">'unsafe'</span>, <span class="Constant">'Attempting to use an unsafe value in a safe context.'</span>);
    <span class="Identifier">}</span>;

    <span class="Statement">if</span> ($injector.has(<span class="Constant">'$sanitize'</span>)) <span class="Identifier">{</span>
      htmlSanitizer = $injector.get(<span class="Constant">'$sanitize'</span>);
    <span class="Identifier">}</span>


    <span class="Identifier">function</span> matchUrl(matcher, parsedUrl) <span class="Identifier">{</span>
      <span class="Statement">if</span> (matcher === <span class="Constant">'self'</span>) <span class="Identifier">{</span>
        <span class="Statement">return</span> urlIsSameOrigin(parsedUrl);
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Comment">// definitely a regex.  See adjustMatchers()</span>
        <span class="Statement">return</span> !!matcher.exec(parsedUrl.href);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Identifier">function</span> isResourceUrlAllowedByPolicy(url) <span class="Identifier">{</span>
      <span class="Identifier">var</span> parsedUrl = urlResolve(url.toString());
      <span class="Identifier">var</span> i, n, allowed = <span class="Constant">false</span>;
      <span class="Comment">// Ensure that at least one item from the whitelist allows this url.</span>
      <span class="Statement">for</span> (i = 0, n = resourceUrlWhitelist.length; i &lt; n; i++) <span class="Identifier">{</span>
        <span class="Statement">if</span> (matchUrl(resourceUrlWhitelist<span class="Identifier">[</span>i<span class="Identifier">]</span>, parsedUrl)) <span class="Identifier">{</span>
          allowed = <span class="Constant">true</span>;
          <span class="Statement">break</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
      <span class="Statement">if</span> (allowed) <span class="Identifier">{</span>
        <span class="Comment">// Ensure that no item from the blacklist blocked this url.</span>
        <span class="Statement">for</span> (i = 0, n = resourceUrlBlacklist.length; i &lt; n; i++) <span class="Identifier">{</span>
          <span class="Statement">if</span> (matchUrl(resourceUrlBlacklist<span class="Identifier">[</span>i<span class="Identifier">]</span>, parsedUrl)) <span class="Identifier">{</span>
            allowed = <span class="Constant">false</span>;
            <span class="Statement">break</span>;
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
      <span class="Statement">return</span> allowed;
    <span class="Identifier">}</span>

    <span class="Identifier">function</span> generateHolderType(Base) <span class="Identifier">{</span>
      <span class="Identifier">var</span> holderType = <span class="Identifier">function</span> TrustedValueHolderType(trustedValue) <span class="Identifier">{</span>
        <span class="Identifier">this</span>.$$unwrapTrustedValue = <span class="Identifier">function</span>() <span class="Identifier">{</span>
          <span class="Statement">return</span> trustedValue;
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span>;
      <span class="Statement">if</span> (Base) <span class="Identifier">{</span>
        holderType.prototype = <span class="Statement">new</span> Base();
      <span class="Identifier">}</span>
      holderType.prototype.valueOf = <span class="Identifier">function</span> sceValueOf() <span class="Identifier">{</span>
        <span class="Statement">return</span> <span class="Identifier">this</span>.$$unwrapTrustedValue();
      <span class="Identifier">}</span>;
      holderType.prototype.toString = <span class="Identifier">function</span> sceToString() <span class="Identifier">{</span>
        <span class="Statement">return</span> <span class="Identifier">this</span>.$$unwrapTrustedValue().toString();
      <span class="Identifier">}</span>;
      <span class="Statement">return</span> holderType;
    <span class="Identifier">}</span>

    <span class="Identifier">var</span> trustedValueHolderBase = generateHolderType(),
        byType = <span class="Identifier">{}</span>;

    byType<span class="Identifier">[</span>SCE_CONTEXTS.HTML<span class="Identifier">]</span> = generateHolderType(trustedValueHolderBase);
    byType<span class="Identifier">[</span>SCE_CONTEXTS.CSS<span class="Identifier">]</span> = generateHolderType(trustedValueHolderBase);
    byType<span class="Identifier">[</span>SCE_CONTEXTS.URL<span class="Identifier">]</span> = generateHolderType(trustedValueHolderBase);
    byType<span class="Identifier">[</span>SCE_CONTEXTS.JS<span class="Identifier">]</span> = generateHolderType(trustedValueHolderBase);
    byType<span class="Identifier">[</span>SCE_CONTEXTS.RESOURCE_URL<span class="Identifier">]</span> = generateHolderType(byType<span class="Identifier">[</span>SCE_CONTEXTS.URL<span class="Identifier">]</span>);

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sceDelegate#trustAs</span>
<span class="Comment">     * @methodOf ng.$sceDelegate</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Returns an object that is trusted by angular for use in specified strict</span>
<span class="Comment">     * contextual escaping contexts (such as ng-html-bind-unsafe, ng-include, any src</span>
<span class="Comment">     * attribute interpolation, any dom event binding attribute interpolation</span>
<span class="Comment">     * such as for onclick,  etc.) that uses the provided value.</span>
<span class="Comment">     * See {@link ng.$sce $sce} for enabling strict contextual escaping.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,</span>
<span class="Comment">     *   resourceUrl, html, js and css.</span>
<span class="Comment">     * @param {*} value The value that that should be considered trusted/safe.</span>
<span class="Comment">     * @returns {*} A value that can be used to stand in for the provided `value` in places</span>
<span class="Comment">     * where Angular expects a $sce.trustAs() return value.</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> trustAs(type, trustedValue) <span class="Identifier">{</span>
      <span class="Identifier">var</span> Constructor = (byType.hasOwnProperty(type) ? byType<span class="Identifier">[</span>type<span class="Identifier">]</span> : <span class="Statement">null</span>);
      <span class="Statement">if</span> (!Constructor) <span class="Identifier">{</span>
        <span class="Statement">throw</span> $sceMinErr(<span class="Constant">'icontext'</span>,
            <span class="Constant">'Attempted to trust a value in invalid context. Context: {0}; Value: {1}'</span>,
            type, trustedValue);
      <span class="Identifier">}</span>
      <span class="Statement">if</span> (trustedValue === <span class="Statement">null</span> || trustedValue === <span class="Statement">undefined</span> || trustedValue === <span class="Constant">''</span>) <span class="Identifier">{</span>
        <span class="Statement">return</span> trustedValue;
      <span class="Identifier">}</span>
      <span class="Comment">// All the current contexts in SCE_CONTEXTS happen to be strings.  In order to avoid trusting</span>
      <span class="Comment">// mutable objects, we ensure here that the value passed in is actually a string.</span>
      <span class="Statement">if</span> (<span class="Statement">typeof</span> trustedValue !== <span class="Constant">'string'</span>) <span class="Identifier">{</span>
        <span class="Statement">throw</span> $sceMinErr(<span class="Constant">'itype'</span>,
            <span class="Constant">'Attempted to trust a non-string value in a content requiring a string: Context: {0}'</span>,
            type);
      <span class="Identifier">}</span>
      <span class="Statement">return</span> <span class="Statement">new</span> Constructor(trustedValue);
    <span class="Identifier">}</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sceDelegate#valueOf</span>
<span class="Comment">     * @methodOf ng.$sceDelegate</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * If the passed parameter had been returned by a prior call to {@link ng.$sceDelegate#methods_trustAs</span>
<span class="Comment">     * `$sceDelegate.trustAs`}, returns the value that had been passed to {@link</span>
<span class="Comment">     * ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs`}.</span>
<span class="Comment">     *</span>
<span class="Comment">     * If the passed parameter is not a value that had been returned by {@link</span>
<span class="Comment">     * ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs`}, returns it as-is.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {*} value The result of a prior {@link ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs`}</span>
<span class="Comment">     *      call or anything else.</span>
<span class="Comment">     * @returns {*} The value the was originally provided to {@link ng.$sceDelegate#methods_trustAs</span>
<span class="Comment">     *     `$sceDelegate.trustAs`} if `value` is the result of such a call.  Otherwise, returns</span>
<span class="Comment">     *     `value` unchanged.</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> valueOf(maybeTrusted) <span class="Identifier">{</span>
      <span class="Statement">if</span> (maybeTrusted <span class="Statement">instanceof</span> trustedValueHolderBase) <span class="Identifier">{</span>
        <span class="Statement">return</span> maybeTrusted.$$unwrapTrustedValue();
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">return</span> maybeTrusted;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sceDelegate#getTrusted</span>
<span class="Comment">     * @methodOf ng.$sceDelegate</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Takes the result of a {@link ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs`} call and</span>
<span class="Comment">     * returns the originally supplied value if the queried context type is a supertype of the</span>
<span class="Comment">     * created type.  If this condition isn't satisfied, throws an exception.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} type The kind of context in which this value is to be used.</span>
<span class="Comment">     * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#methods_trustAs</span>
<span class="Comment">     *     `$sceDelegate.trustAs`} call.</span>
<span class="Comment">     * @returns {*} The value the was originally provided to {@link ng.$sceDelegate#methods_trustAs</span>
<span class="Comment">     *     `$sceDelegate.trustAs`} if valid in this context.  Otherwise, throws an exception.</span>
<span class="Comment">     */</span>
    <span class="Identifier">function</span> getTrusted(type, maybeTrusted) <span class="Identifier">{</span>
      <span class="Statement">if</span> (maybeTrusted === <span class="Statement">null</span> || maybeTrusted === <span class="Statement">undefined</span> || maybeTrusted === <span class="Constant">''</span>) <span class="Identifier">{</span>
        <span class="Statement">return</span> maybeTrusted;
      <span class="Identifier">}</span>
      <span class="Identifier">var</span> constructor = (byType.hasOwnProperty(type) ? byType<span class="Identifier">[</span>type<span class="Identifier">]</span> : <span class="Statement">null</span>);
      <span class="Statement">if</span> (constructor &amp;&amp; maybeTrusted <span class="Statement">instanceof</span> constructor) <span class="Identifier">{</span>
        <span class="Statement">return</span> maybeTrusted.$$unwrapTrustedValue();
      <span class="Identifier">}</span>
      <span class="Comment">// If we get here, then we may only take one of two actions.</span>
      <span class="Comment">// 1. sanitize the value for the requested type, or</span>
      <span class="Comment">// 2. throw an exception.</span>
      <span class="Statement">if</span> (type === SCE_CONTEXTS.RESOURCE_URL) <span class="Identifier">{</span>
        <span class="Statement">if</span> (isResourceUrlAllowedByPolicy(maybeTrusted)) <span class="Identifier">{</span>
          <span class="Statement">return</span> maybeTrusted;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          <span class="Statement">throw</span> $sceMinErr(<span class="Constant">'insecurl'</span>,
              <span class="Constant">'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}'</span>,
              maybeTrusted.toString());
        <span class="Identifier">}</span>
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (type === SCE_CONTEXTS.HTML) <span class="Identifier">{</span>
        <span class="Statement">return</span> htmlSanitizer(maybeTrusted);
      <span class="Identifier">}</span>
      <span class="Statement">throw</span> $sceMinErr(<span class="Constant">'unsafe'</span>, <span class="Constant">'Attempting to use an unsafe value in a safe context.'</span>);
    <span class="Identifier">}</span>

    <span class="Statement">return</span> <span class="Identifier">{</span> trustAs: trustAs,
             getTrusted: getTrusted,
             valueOf: valueOf <span class="Identifier">}</span>;
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$sceProvider</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * The $sceProvider provider allows developers to configure the {@link ng.$sce $sce} service.</span>
<span class="Comment"> * -   enable/disable Strict Contextual Escaping (SCE) in a module</span>
<span class="Comment"> * -   override the default implementation with a custom delegate</span>
<span class="Comment"> *</span>
<span class="Comment"> * Read more about {@link ng.$sce Strict Contextual Escaping (SCE)}.</span>
<span class="Comment"> */</span>

<span class="Comment">/* jshint maxlen: false*/</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc service</span>
<span class="Comment"> * @name ng.$sce</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * `$sce` is a service that provides Strict Contextual Escaping services to AngularJS.</span>
<span class="Comment"> *</span>
<span class="Comment"> * # Strict Contextual Escaping</span>
<span class="Comment"> *</span>
<span class="Comment"> * Strict Contextual Escaping (SCE) is a mode in which AngularJS requires bindings in certain</span>
<span class="Comment"> * contexts to result in a value that is marked as safe to use for that context.  One example of</span>
<span class="Comment"> * such a context is binding arbitrary html controlled by the user via `ng-bind-html`.  We refer</span>
<span class="Comment"> * to these contexts as privileged or SCE contexts.</span>
<span class="Comment"> *</span>
<span class="Comment"> * As of version 1.2, Angular ships with SCE enabled by default.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Note:  When enabled (the default), IE8 in quirks mode is not supported.  In this mode, IE8 allows</span>
<span class="Comment"> * one to execute arbitrary javascript by the use of the expression() syntax.  Refer</span>
<span class="Comment"> * &lt;<a href="http://blogs.msdn.com/b/ie/archive/2008/10/16/ending-expressions.aspx">http://blogs.msdn.com/b/ie/archive/2008/10/16/ending-expressions.aspx</a>&gt; to learn more about them.</span>
<span class="Comment"> * You can ensure your document is in standards mode and not quirks mode by adding `&lt;!doctype html&gt;`</span>
<span class="Comment"> * to the top of your HTML document.</span>
<span class="Comment"> *</span>
<span class="Comment"> * SCE assists in writing code in way that (a) is secure by default and (b) makes auditing for</span>
<span class="Comment"> * security vulnerabilities such as XSS, clickjacking, etc. a lot easier.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Here's an example of a binding in a privileged context:</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre class=&quot;prettyprint&quot;&gt;</span>
<span class="Comment"> *     &lt;input ng-model=&quot;userHtml&quot;&gt;</span>
<span class="Comment"> *     &lt;div ng-bind-html=&quot;userHtml&quot;&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * Notice that `ng-bind-html` is bound to `userHtml` controlled by the user.  With SCE</span>
<span class="Comment"> * disabled, this application allows the user to render arbitrary HTML into the DIV.</span>
<span class="Comment"> * In a more realistic example, one may be rendering user comments, blog articles, etc. via</span>
<span class="Comment"> * bindings.  (HTML is just one example of a context where rendering user controlled input creates</span>
<span class="Comment"> * security vulnerabilities.)</span>
<span class="Comment"> *</span>
<span class="Comment"> * For the case of HTML, you might use a library, either on the client side, or on the server side,</span>
<span class="Comment"> * to sanitize unsafe HTML before binding to the value and rendering it in the document.</span>
<span class="Comment"> *</span>
<span class="Comment"> * How would you ensure that every place that used these types of bindings was bound to a value that</span>
<span class="Comment"> * was sanitized by your library (or returned as safe for rendering by your server?)  How can you</span>
<span class="Comment"> * ensure that you didn't accidentally delete the line that sanitized the value, or renamed some</span>
<span class="Comment"> * properties/fields and forgot to update the binding to the sanitized value?</span>
<span class="Comment"> *</span>
<span class="Comment"> * To be secure by default, you want to ensure that any such bindings are disallowed unless you can</span>
<span class="Comment"> * determine that something explicitly says it's safe to use a value for binding in that</span>
<span class="Comment"> * context.  You can then audit your code (a simple grep would do) to ensure that this is only done</span>
<span class="Comment"> * for those values that you can easily tell are safe - because they were received from your server,</span>
<span class="Comment"> * sanitized by your library, etc.  You can organize your codebase to help with this - perhaps</span>
<span class="Comment"> * allowing only the files in a specific directory to do this.  Ensuring that the internal API</span>
<span class="Comment"> * exposed by that code doesn't markup arbitrary values as safe then becomes a more manageable task.</span>
<span class="Comment"> *</span>
<span class="Comment"> * In the case of AngularJS' SCE service, one uses {@link ng.$sce#methods_trustAs $sce.trustAs} </span>
<span class="Comment"> * (and shorthand methods such as {@link ng.$sce#methods_trustAsHtml $sce.trustAsHtml}, etc.) to</span>
<span class="Comment"> * obtain values that will be accepted by SCE / privileged contexts.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## How does it work?</span>
<span class="Comment"> *</span>
<span class="Comment"> * In privileged contexts, directives and code will bind to the result of {@link ng.$sce#methods_getTrusted</span>
<span class="Comment"> * $sce.getTrusted(context, value)} rather than to the value directly.  Directives use {@link</span>
<span class="Comment"> * ng.$sce#methods_parse $sce.parseAs} rather than `$parse` to watch attribute bindings, which performs the</span>
<span class="Comment"> * {@link ng.$sce#methods_getTrusted $sce.getTrusted} behind the scenes on non-constant literals.</span>
<span class="Comment"> *</span>
<span class="Comment"> * As an example, {@link ng.directive:ngBindHtml ngBindHtml} uses {@link</span>
<span class="Comment"> * ng.$sce#methods_parseAsHtml $sce.parseAsHtml(binding expression)}.  Here's the actual code (slightly</span>
<span class="Comment"> * simplified):</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre class=&quot;prettyprint&quot;&gt;</span>
<span class="Comment"> *   var ngBindHtmlDirective = ['$sce', function($sce) {</span>
<span class="Comment"> *     return function(scope, element, attr) {</span>
<span class="Comment"> *       scope.$watch($sce.parseAsHtml(attr.ngBindHtml), function(value) {</span>
<span class="Comment"> *         element.html(value || '');</span>
<span class="Comment"> *       });</span>
<span class="Comment"> *     };</span>
<span class="Comment"> *   }];</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## Impact on loading templates</span>
<span class="Comment"> *</span>
<span class="Comment"> * This applies both to the {@link ng.directive:ngInclude `ng-include`} directive as well as</span>
<span class="Comment"> * `templateUrl`'s specified by {@link guide/directive directives}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * By default, Angular only loads templates from the same domain and protocol as the application</span>
<span class="Comment"> * document.  This is done by calling {@link ng.$sce#methods_getTrustedResourceUrl</span>
<span class="Comment"> * $sce.getTrustedResourceUrl} on the template URL.  To load templates from other domains and/or</span>
<span class="Comment"> * protocols, you may either either {@link ng.$sceDelegateProvider#methods_resourceUrlWhitelist whitelist</span>
<span class="Comment"> * them} or {@link ng.$sce#methods_trustAsResourceUrl wrap it} into a trusted value.</span>
<span class="Comment"> *</span>
<span class="Comment"> * *Please note*:</span>
<span class="Comment"> * The browser's</span>
<span class="Comment"> * {@link <a href="https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest">https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest</a></span>
<span class="Comment"> * Same Origin Policy} and {@link <a href="http://www.w3.org/TR/cors/">http://www.w3.org/TR/cors/</a> Cross-Origin Resource Sharing (CORS)}</span>
<span class="Comment"> * policy apply in addition to this and may further restrict whether the template is successfully</span>
<span class="Comment"> * loaded.  This means that without the right CORS policy, loading templates from a different domain</span>
<span class="Comment"> * won't work on all browsers.  Also, loading templates from `file://` URL does not work on some</span>
<span class="Comment"> * browsers.</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## This feels like too much overhead for the developer?</span>
<span class="Comment"> *</span>
<span class="Comment"> * It's important to remember that SCE only applies to interpolation expressions.</span>
<span class="Comment"> *</span>
<span class="Comment"> * If your expressions are constant literals, they're automatically trusted and you don't need to</span>
<span class="Comment"> * call `$sce.trustAs` on them.  (e.g.</span>
<span class="Comment"> * `&lt;div ng-html-bind-unsafe=&quot;'&lt;b&gt;implicitly trusted&lt;/b&gt;'&quot;&gt;&lt;/div&gt;`) just works.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Additionally, `a[href]` and `img[src]` automatically sanitize their URLs and do not pass them</span>
<span class="Comment"> * through {@link ng.$sce#methods_getTrusted $sce.getTrusted}.  SCE doesn't play a role here.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The included {@link ng.$sceDelegate $sceDelegate} comes with sane defaults to allow you to load</span>
<span class="Comment"> * templates in `ng-include` from your application's domain without having to even know about SCE.</span>
<span class="Comment"> * It blocks loading templates from other domains or loading templates over http from an https</span>
<span class="Comment"> * served document.  You can change these by setting your own custom {@link</span>
<span class="Comment"> * ng.$sceDelegateProvider#methods_resourceUrlWhitelist whitelists} and {@link</span>
<span class="Comment"> * ng.$sceDelegateProvider#methods_resourceUrlBlacklist blacklists} for matching such URLs.</span>
<span class="Comment"> *</span>
<span class="Comment"> * This significantly reduces the overhead.  It is far easier to pay the small overhead and have an</span>
<span class="Comment"> * application that's secure and can be audited to verify that with much more ease than bolting</span>
<span class="Comment"> * security onto an application later.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;a name=&quot;contexts&quot;&gt;&lt;/a&gt;</span>
<span class="Comment"> * ## What trusted context types are supported?</span>
<span class="Comment"> *</span>
<span class="Comment"> * | Context             | Notes          |</span>
<span class="Comment"> * |---------------------|----------------|</span>
<span class="Comment"> * | `$sce.HTML`         | For HTML that's safe to source into the application.  The {@link ng.directive:ngBindHtml ngBindHtml} directive uses this context for bindings. |</span>
<span class="Comment"> * | `$sce.CSS`          | For CSS that's safe to source into the application.  Currently unused.  Feel free to use it in your own directives. |</span>
<span class="Comment"> * | `$sce.URL`          | For URLs that are safe to follow as links.  Currently unused (`&lt;a href=` and `&lt;img src=` sanitize their urls and don't consititute an SCE context. |</span>
<span class="Comment"> * | `$sce.RESOURCE_URL` | For URLs that are not only safe to follow as links, but whose contens are also safe to include in your application.  Examples include `ng-include`, `src` / `ngSrc` bindings for tags other than `IMG` (e.g. `IFRAME`, `OBJECT`, etc.)  &lt;br&gt;&lt;br&gt;Note that `$sce.RESOURCE_URL` makes a stronger statement about the URL than `$sce.URL` does and therefore contexts requiring values trusted for `$sce.RESOURCE_URL` can be used anywhere that values trusted for `$sce.URL` are required. |</span>
<span class="Comment"> * | `$sce.JS`           | For JavaScript that is safe to execute in your application's context.  Currently unused.  Feel free to use it in your own directives. |</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## Format of items in {@link ng.$sceDelegateProvider#methods_resourceUrlWhitelist resourceUrlWhitelist}/{@link ng.$sceDelegateProvider#methods_resourceUrlBlacklist Blacklist} &lt;a name=&quot;resourceUrlPatternItem&quot;&gt;&lt;/a&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> *  Each element in these arrays must be one of the following:</span>
<span class="Comment"> *</span>
<span class="Comment"> *  - **'self'**</span>
<span class="Comment"> *    - The special **string**, `'self'`, can be used to match against all URLs of the **same</span>
<span class="Comment"> *      domain** as the application document using the **same protocol**.</span>
<span class="Comment"> *  - **String** (except the special value `'self'`)</span>
<span class="Comment"> *    - The string is matched against the full *normalized / absolute URL* of the resource</span>
<span class="Comment"> *      being tested (substring matches are not good enough.)</span>
<span class="Comment"> *    - There are exactly **two wildcard sequences** - `*` and `**`.  All other characters</span>
<span class="Comment"> *      match themselves.</span>
<span class="Comment"> *    - `*`: matches zero or more occurances of any character other than one of the following 6</span>
<span class="Comment"> *      characters: '`:`', '`/`', '`.`', '`?`', '`&amp;`' and ';'.  It's a useful wildcard for use</span>
<span class="Comment"> *      in a whitelist.</span>
<span class="Comment"> *    - `**`: matches zero or more occurances of *any* character.  As such, it's not</span>
<span class="Comment"> *      not appropriate to use in for a scheme, domain, etc. as it would match too much.  (e.g.</span>
<span class="Comment"> *      <a href="http://**.example.com/">http://**.example.com/</a> would match <a href="http://evil.com/?ignore=.example.com/">http://evil.com/?ignore=.example.com/</a> and that might</span>
<span class="Comment"> *      not have been the intention.)  It's usage at the very end of the path is ok.  (e.g.</span>
<span class="Comment"> *      <a href="http://foo.example.com/templates/**).">http://foo.example.com/templates/**).</a></span>
<span class="Comment"> *  - **RegExp** (*see caveat below*)</span>
<span class="Comment"> *    - *Caveat*:  While regular expressions are powerful and offer great flexibility,  their syntax</span>
<span class="Comment"> *      (and all the inevitable escaping) makes them *harder to maintain*.  It's easy to</span>
<span class="Comment"> *      accidentally introduce a bug when one updates a complex expression (imho, all regexes should</span>
<span class="Comment"> *      have good test coverage.).  For instance, the use of `.` in the regex is correct only in a</span>
<span class="Comment"> *      small number of cases.  A `.` character in the regex used when matching the scheme or a</span>
<span class="Comment"> *      subdomain could be matched against a `:` or literal `.` that was likely not intended.   It</span>
<span class="Comment"> *      is highly recommended to use the string patterns and only fall back to regular expressions</span>
<span class="Comment"> *      if they as a last resort.</span>
<span class="Comment"> *    - The regular expression must be an instance of RegExp (i.e. not a string.)  It is</span>
<span class="Comment"> *      matched against the **entire** *normalized / absolute URL* of the resource being tested</span>
<span class="Comment"> *      (even when the RegExp did not have the `^` and `$` codes.)  In addition, any flags</span>
<span class="Comment"> *      present on the RegExp (such as multiline, global, ignoreCase) are ignored.</span>
<span class="Comment"> *    - If you are generating your Javascript from some other templating engine (not</span>
<span class="Comment"> *      recommended, e.g. in issue [#4006](<a href="https://github.com/angular/angular.js/issues/4006)),">https://github.com/angular/angular.js/issues/4006)),</a></span>
<span class="Comment"> *      remember to escape your regular expression (and be aware that you might need more than</span>
<span class="Comment"> *      one level of escaping depending on your templating engine and the way you interpolated</span>
<span class="Comment"> *      the value.)  Do make use of your platform's escaping mechanism as it might be good</span>
<span class="Comment"> *      enough before coding your own.  e.g. Ruby has</span>
<span class="Comment"> *      [Regexp.escape(str)](<a href="http://www.ruby-doc.org/core-2.0.0/Regexp.html#method-c-escape)">http://www.ruby-doc.org/core-2.0.0/Regexp.html#method-c-escape)</a></span>
<span class="Comment"> *      and Python has [re.escape](<a href="http://docs.python.org/library/re.html#re.escape).">http://docs.python.org/library/re.html#re.escape).</a></span>
<span class="Comment"> *      Javascript lacks a similar built in function for escaping.  Take a look at Google</span>
<span class="Comment"> *      Closure library's [goog.string.regExpEscape(s)](</span>
<span class="Comment"> *      <a href="http://docs.closure-library.googlecode.com/git/closure_goog_string_string.js.source.html#line962).">http://docs.closure-library.googlecode.com/git/closure_goog_string_string.js.source.html#line962).</a></span>
<span class="Comment"> *</span>
<span class="Comment"> * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} for an example.</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## Show me an example using SCE.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">&lt;example module=&quot;mySceApp&quot;&gt;</span>
<span class="Comment">&lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">  &lt;div ng-controller=&quot;myAppController as myCtrl&quot;&gt;</span>
<span class="Comment">    &lt;i ng-bind-html=&quot;myCtrl.explicitlyTrustedHtml&quot; id=&quot;explicitlyTrustedHtml&quot;&gt;&lt;/i&gt;&lt;br&gt;&lt;br&gt;</span>
<span class="Comment">    &lt;b&gt;User comments&lt;/b&gt;&lt;br&gt;</span>
<span class="Comment">    By default, HTML that isn't explicitly trusted (e.g. Alice's comment) is sanitized when</span>
<span class="Comment">    $sanitize is available.  If $sanitize isn't available, this results in an error instead of an</span>
<span class="Comment">    exploit.</span>
<span class="Comment">    &lt;div class=&quot;well&quot;&gt;</span>
<span class="Comment">      &lt;div ng-repeat=&quot;userComment in myCtrl.userComments&quot;&gt;</span>
<span class="Comment">        &lt;b&gt;{{userComment.name}}&lt;/b&gt;:</span>
<span class="Comment">        &lt;span ng-bind-html=&quot;userComment.htmlComment&quot; class=&quot;htmlComment&quot;&gt;&lt;/span&gt;</span>
<span class="Comment">        &lt;br&gt;</span>
<span class="Comment">      &lt;/div&gt;</span>
<span class="Comment">    &lt;/div&gt;</span>
<span class="Comment">  &lt;/div&gt;</span>
<span class="Comment">&lt;/file&gt;</span>

<span class="Comment">&lt;file name=&quot;script.js&quot;&gt;</span>
<span class="Comment">  var mySceApp = angular.module('mySceApp', ['ngSanitize']);</span>

<span class="Comment">  mySceApp.controller(&quot;myAppController&quot;, function myAppController($http, $templateCache, $sce) {</span>
<span class="Comment">    var self = this;</span>
<span class="Comment">    $http.get(&quot;test_data.json&quot;, {cache: $templateCache}).success(function(userComments) {</span>
<span class="Comment">      self.userComments = userComments;</span>
<span class="Comment">    });</span>
<span class="Comment">    self.explicitlyTrustedHtml = $sce.trustAsHtml(</span>
<span class="Comment">        '&lt;span onmouseover=&quot;this.textContent=&amp;quot;Explicitly trusted HTML bypasses ' +</span>
<span class="Comment">        'sanitization.&amp;quot;&quot;&gt;Hover over this text.&lt;/span&gt;');</span>
<span class="Comment">  });</span>
<span class="Comment">&lt;/file&gt;</span>

<span class="Comment">&lt;file name=&quot;test_data.json&quot;&gt;</span>
<span class="Comment">[</span>
<span class="Comment">  { &quot;name&quot;: &quot;Alice&quot;,</span>
<span class="Comment">    &quot;htmlComment&quot;:</span>
<span class="Comment">        &quot;&lt;span onmouseover='this.textContent=\&quot;PWN3D!\&quot;'&gt;Is &lt;i&gt;anyone&lt;/i&gt; reading this?&lt;/span&gt;&quot;</span>
<span class="Comment">  },</span>
<span class="Comment">  { &quot;name&quot;: &quot;Bob&quot;,</span>
<span class="Comment">    &quot;htmlComment&quot;: &quot;&lt;i&gt;Yes!&lt;/i&gt;  Am I the only other one?&quot;</span>
<span class="Comment">  }</span>
<span class="Comment">]</span>
<span class="Comment">&lt;/file&gt;</span>

<span class="Comment">&lt;file name=&quot;scenario.js&quot;&gt;</span>
<span class="Comment">  describe('SCE doc demo', function() {</span>
<span class="Comment">    it('should sanitize untrusted values', function() {</span>
<span class="Comment">      expect(element('.htmlComment').html()).toBe('&lt;span&gt;Is &lt;i&gt;anyone&lt;/i&gt; reading this?&lt;/span&gt;');</span>
<span class="Comment">    });</span>
<span class="Comment">    it('should NOT sanitize explicitly trusted values', function() {</span>
<span class="Comment">      expect(element('#explicitlyTrustedHtml').html()).toBe(</span>
<span class="Comment">          '&lt;span onmouseover=&quot;this.textContent=&amp;quot;Explicitly trusted HTML bypasses ' +</span>
<span class="Comment">          'sanitization.&amp;quot;&quot;&gt;Hover over this text.&lt;/span&gt;');</span>
<span class="Comment">    });</span>
<span class="Comment">  });</span>
<span class="Comment">&lt;/file&gt;</span>
<span class="Comment">&lt;/example&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## Can I disable SCE completely?</span>
<span class="Comment"> *</span>
<span class="Comment"> * Yes, you can.  However, this is strongly discouraged.  SCE gives you a lot of security benefits</span>
<span class="Comment"> * for little coding overhead.  It will be much harder to take an SCE disabled application and</span>
<span class="Comment"> * either secure it on your own or enable SCE at a later stage.  It might make sense to disable SCE</span>
<span class="Comment"> * for cases where you have a lot of existing code that was written before SCE was introduced and</span>
<span class="Comment"> * you're migrating them a module at a time.</span>
<span class="Comment"> *</span>
<span class="Comment"> * That said, here's how you can completely disable SCE:</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre class=&quot;prettyprint&quot;&gt;</span>
<span class="Comment"> *   angular.module('myAppWithSceDisabledmyApp', []).config(function($sceProvider) {</span>
<span class="Comment"> *     // Completely disable SCE.  For demonstration purposes only!</span>
<span class="Comment"> *     // Do not use in new projects.</span>
<span class="Comment"> *     $sceProvider.enabled(false);</span>
<span class="Comment"> *   });</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>
<span class="Comment">/* jshint maxlen: 100 */</span>

<span class="Identifier">function</span> $SceProvider() <span class="Identifier">{</span>
  <span class="Identifier">var</span> enabled = <span class="Constant">true</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.sceProvider#enabled</span>
<span class="Comment">   * @methodOf ng.$sceProvider</span>
<span class="Comment">   * @function</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {boolean=} value If provided, then enables/disables SCE.</span>
<span class="Comment">   * @return {boolean} true if SCE is enabled, false otherwise.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Enables/disables SCE and returns the current value.</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.enabled = <span class="Identifier">function</span> (value) <span class="Identifier">{</span>
    <span class="Statement">if</span> (<span class="Identifier">arguments</span>.length) <span class="Identifier">{</span>
      enabled = !!value;
    <span class="Identifier">}</span>
    <span class="Statement">return</span> enabled;
  <span class="Identifier">}</span>;


  <span class="Comment">/* Design notes on the default implementation for SCE.</span>
<span class="Comment">   *</span>
<span class="Comment">   * The API contract for the SCE delegate</span>
<span class="Comment">   * -------------------------------------</span>
<span class="Comment">   * The SCE delegate object must provide the following 3 methods:</span>
<span class="Comment">   *</span>
<span class="Comment">   * - trustAs(contextEnum, value)</span>
<span class="Comment">   *     This method is used to tell the SCE service that the provided value is OK to use in the</span>
<span class="Comment">   *     contexts specified by contextEnum.  It must return an object that will be accepted by</span>
<span class="Comment">   *     getTrusted() for a compatible contextEnum and return this value.</span>
<span class="Comment">   *</span>
<span class="Comment">   * - valueOf(value)</span>
<span class="Comment">   *     For values that were not produced by trustAs(), return them as is.  For values that were</span>
<span class="Comment">   *     produced by trustAs(), return the corresponding input value to trustAs.  Basically, if</span>
<span class="Comment">   *     trustAs is wrapping the given values into some type, this operation unwraps it when given</span>
<span class="Comment">   *     such a value.</span>
<span class="Comment">   *</span>
<span class="Comment">   * - getTrusted(contextEnum, value)</span>
<span class="Comment">   *     This function should return the a value that is safe to use in the context specified by</span>
<span class="Comment">   *     contextEnum or throw and exception otherwise.</span>
<span class="Comment">   *</span>
<span class="Comment">   * NOTE: This contract deliberately does NOT state that values returned by trustAs() must be</span>
<span class="Comment">   * opaque or wrapped in some holder object.  That happens to be an implementation detail.  For</span>
<span class="Comment">   * instance, an implementation could maintain a registry of all trusted objects by context.  In</span>
<span class="Comment">   * such a case, trustAs() would return the same object that was passed in.  getTrusted() would</span>
<span class="Comment">   * return the same object passed in if it was found in the registry under a compatible context or</span>
<span class="Comment">   * throw an exception otherwise.  An implementation might only wrap values some of the time based</span>
<span class="Comment">   * on some criteria.  getTrusted() might return a value and not throw an exception for special</span>
<span class="Comment">   * constants or objects even if not wrapped.  All such implementations fulfill this contract.</span>
<span class="Comment">   *</span>
<span class="Comment">   *</span>
<span class="Comment">   * A note on the inheritance model for SCE contexts</span>
<span class="Comment">   * ------------------------------------------------</span>
<span class="Comment">   * I've used inheritance and made RESOURCE_URL wrapped types a subtype of URL wrapped types.  This</span>
<span class="Comment">   * is purely an implementation details.</span>
<span class="Comment">   *</span>
<span class="Comment">   * The contract is simply this:</span>
<span class="Comment">   *</span>
<span class="Comment">   *     getTrusted($sce.RESOURCE_URL, value) succeeding implies that getTrusted($sce.URL, value)</span>
<span class="Comment">   *     will also succeed.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Inheritance happens to capture this in a natural way.  In some future, we</span>
<span class="Comment">   * may not use inheritance anymore.  That is OK because no code outside of</span>
<span class="Comment">   * sce.js and sceSpecs.js would need to be aware of this detail.</span>
<span class="Comment">   */</span>

  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$parse'</span>, <span class="Constant">'$sniffer'</span>, <span class="Constant">'$sceDelegate'</span>, <span class="Identifier">function</span>(
                $parse,   $sniffer,   $sceDelegate) <span class="Identifier">{</span>
    <span class="Comment">// Prereq: Ensure that we're not running in IE8 quirks mode.  In that mode, IE allows</span>
    <span class="Comment">// the &quot;expression(javascript expression)&quot; syntax which is insecure.</span>
    <span class="Statement">if</span> (enabled &amp;&amp; $sniffer.msie &amp;&amp; $sniffer.msieDocumentMode &lt; 8) <span class="Identifier">{</span>
      <span class="Statement">throw</span> $sceMinErr(<span class="Constant">'iequirks'</span>,
        <span class="Constant">'Strict Contextual Escaping does not support Internet Explorer version &lt; 9 in quirks '</span> +
        <span class="Constant">'mode.  You can fix this by adding the text &lt;!doctype html&gt; to the top of your HTML '</span> +
        <span class="Constant">'document.  See <a href="http://docs.angularjs.org/api/ng.$sce">http://docs.angularjs.org/api/ng.$sce</a> for more information.'</span>);
    <span class="Identifier">}</span>

    <span class="Identifier">var</span> sce = copy(SCE_CONTEXTS);

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc function</span>
<span class="Comment">     * @name ng.sce#isEnabled</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     * @function</span>
<span class="Comment">     *</span>
<span class="Comment">     * @return {Boolean} true if SCE is enabled, false otherwise.  If you want to set the value, you</span>
<span class="Comment">     * have to do it at module config time on {@link ng.$sceProvider $sceProvider}.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Returns a boolean indicating if SCE is enabled.</span>
<span class="Comment">     */</span>
    sce.isEnabled = <span class="Identifier">function</span> () <span class="Identifier">{</span>
      <span class="Statement">return</span> enabled;
    <span class="Identifier">}</span>;
    sce.trustAs = $sceDelegate.trustAs;
    sce.getTrusted = $sceDelegate.getTrusted;
    sce.valueOf = $sceDelegate.valueOf;

    <span class="Statement">if</span> (!enabled) <span class="Identifier">{</span>
      sce.trustAs = sce.getTrusted = <span class="Identifier">function</span>(type, value) <span class="Identifier">{</span> <span class="Statement">return</span> value; <span class="Identifier">}</span>;
      sce.valueOf = identity;
    <span class="Identifier">}</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#parse</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Converts Angular {@link guide/expression expression} into a function.  This is like {@link</span>
<span class="Comment">     * ng.$parse $parse} and is identical when the expression is a literal constant.  Otherwise, it</span>
<span class="Comment">     * wraps the expression in a call to {@link ng.$sce#methods_getTrusted $sce.getTrusted(*type*,</span>
<span class="Comment">     * *result*)}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} type The kind of SCE context in which this result will be used.</span>
<span class="Comment">     * @param {string} expression String expression to compile.</span>
<span class="Comment">     * @returns {function(context, locals)} a function which represents the compiled expression:</span>
<span class="Comment">     *</span>
<span class="Comment">     *    * `context` – `{object}` – an object against which any expressions embedded in the strings</span>
<span class="Comment">     *      are evaluated against (typically a scope object).</span>
<span class="Comment">     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in</span>
<span class="Comment">     *      `context`.</span>
<span class="Comment">     */</span>
    sce.parseAs = <span class="Identifier">function</span> sceParseAs(type, expr) <span class="Identifier">{</span>
      <span class="Identifier">var</span> parsed = $parse(expr);
      <span class="Statement">if</span> (parsed.literal &amp;&amp; parsed.constant) <span class="Identifier">{</span>
        <span class="Statement">return</span> parsed;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">return</span> <span class="Identifier">function</span> sceParseAsTrusted(<span class="Statement">self</span>, locals) <span class="Identifier">{</span>
          <span class="Statement">return</span> sce.getTrusted(type, parsed(<span class="Statement">self</span>, locals));
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#trustAs</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Delegates to {@link ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs`}.  As such,</span>
<span class="Comment">     * returns an objectthat is trusted by angular for use in specified strict contextual</span>
<span class="Comment">     * escaping contexts (such as ng-html-bind-unsafe, ng-include, any src attribute</span>
<span class="Comment">     * interpolation, any dom event binding attribute interpolation such as for onclick,  etc.)</span>
<span class="Comment">     * that uses the provided value.  See * {@link ng.$sce $sce} for enabling strict contextual</span>
<span class="Comment">     * escaping.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,</span>
<span class="Comment">     *   resource_url, html, js and css.</span>
<span class="Comment">     * @param {*} value The value that that should be considered trusted/safe.</span>
<span class="Comment">     * @returns {*} A value that can be used to stand in for the provided `value` in places</span>
<span class="Comment">     * where Angular expects a $sce.trustAs() return value.</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#trustAsHtml</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shorthand method.  `$sce.trustAsHtml(value)` →</span>
<span class="Comment">     *     {@link ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs($sce.HTML, value)`}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {*} value The value to trustAs.</span>
<span class="Comment">     * @returns {*} An object that can be passed to {@link ng.$sce#methods_getTrustedHtml</span>
<span class="Comment">     *     $sce.getTrustedHtml(value)} to obtain the original value.  (privileged directives</span>
<span class="Comment">     *     only accept expressions that are either literal constants or are the</span>
<span class="Comment">     *     return value of {@link ng.$sce#methods_trustAs $sce.trustAs}.)</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#trustAsUrl</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shorthand method.  `$sce.trustAsUrl(value)` →</span>
<span class="Comment">     *     {@link ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs($sce.URL, value)`}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {*} value The value to trustAs.</span>
<span class="Comment">     * @returns {*} An object that can be passed to {@link ng.$sce#methods_getTrustedUrl</span>
<span class="Comment">     *     $sce.getTrustedUrl(value)} to obtain the original value.  (privileged directives</span>
<span class="Comment">     *     only accept expressions that are either literal constants or are the</span>
<span class="Comment">     *     return value of {@link ng.$sce#methods_trustAs $sce.trustAs}.)</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#trustAsResourceUrl</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shorthand method.  `$sce.trustAsResourceUrl(value)` →</span>
<span class="Comment">     *     {@link ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {*} value The value to trustAs.</span>
<span class="Comment">     * @returns {*} An object that can be passed to {@link ng.$sce#methods_getTrustedResourceUrl</span>
<span class="Comment">     *     $sce.getTrustedResourceUrl(value)} to obtain the original value.  (privileged directives</span>
<span class="Comment">     *     only accept expressions that are either literal constants or are the return</span>
<span class="Comment">     *     value of {@link ng.$sce#methods_trustAs $sce.trustAs}.)</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#trustAsJs</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shorthand method.  `$sce.trustAsJs(value)` →</span>
<span class="Comment">     *     {@link ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs($sce.JS, value)`}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {*} value The value to trustAs.</span>
<span class="Comment">     * @returns {*} An object that can be passed to {@link ng.$sce#methods_getTrustedJs</span>
<span class="Comment">     *     $sce.getTrustedJs(value)} to obtain the original value.  (privileged directives</span>
<span class="Comment">     *     only accept expressions that are either literal constants or are the</span>
<span class="Comment">     *     return value of {@link ng.$sce#methods_trustAs $sce.trustAs}.)</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#getTrusted</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Delegates to {@link ng.$sceDelegate#methods_getTrusted `$sceDelegate.getTrusted`}.  As such,</span>
<span class="Comment">     * takes the result of a {@link ng.$sce#methods_trustAs `$sce.trustAs`}() call and returns the</span>
<span class="Comment">     * originally supplied value if the queried context type is a supertype of the created type.</span>
<span class="Comment">     * If this condition isn't satisfied, throws an exception.</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} type The kind of context in which this value is to be used.</span>
<span class="Comment">     * @param {*} maybeTrusted The result of a prior {@link ng.$sce#methods_trustAs `$sce.trustAs`}</span>
<span class="Comment">     *                         call.</span>
<span class="Comment">     * @returns {*} The value the was originally provided to</span>
<span class="Comment">     *              {@link ng.$sce#methods_trustAs `$sce.trustAs`} if valid in this context.</span>
<span class="Comment">     *              Otherwise, throws an exception.</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#getTrustedHtml</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shorthand method.  `$sce.getTrustedHtml(value)` →</span>
<span class="Comment">     *     {@link ng.$sceDelegate#methods_getTrusted `$sceDelegate.getTrusted($sce.HTML, value)`}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {*} value The value to pass to `$sce.getTrusted`.</span>
<span class="Comment">     * @returns {*} The return value of `$sce.getTrusted($sce.HTML, value)`</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#getTrustedCss</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shorthand method.  `$sce.getTrustedCss(value)` →</span>
<span class="Comment">     *     {@link ng.$sceDelegate#methods_getTrusted `$sceDelegate.getTrusted($sce.CSS, value)`}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {*} value The value to pass to `$sce.getTrusted`.</span>
<span class="Comment">     * @returns {*} The return value of `$sce.getTrusted($sce.CSS, value)`</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#getTrustedUrl</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shorthand method.  `$sce.getTrustedUrl(value)` →</span>
<span class="Comment">     *     {@link ng.$sceDelegate#methods_getTrusted `$sceDelegate.getTrusted($sce.URL, value)`}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {*} value The value to pass to `$sce.getTrusted`.</span>
<span class="Comment">     * @returns {*} The return value of `$sce.getTrusted($sce.URL, value)`</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#getTrustedResourceUrl</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shorthand method.  `$sce.getTrustedResourceUrl(value)` →</span>
<span class="Comment">     *     {@link ng.$sceDelegate#methods_getTrusted `$sceDelegate.getTrusted($sce.RESOURCE_URL, value)`}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {*} value The value to pass to `$sceDelegate.getTrusted`.</span>
<span class="Comment">     * @returns {*} The return value of `$sce.getTrusted($sce.RESOURCE_URL, value)`</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#getTrustedJs</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shorthand method.  `$sce.getTrustedJs(value)` →</span>
<span class="Comment">     *     {@link ng.$sceDelegate#methods_getTrusted `$sceDelegate.getTrusted($sce.JS, value)`}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {*} value The value to pass to `$sce.getTrusted`.</span>
<span class="Comment">     * @returns {*} The return value of `$sce.getTrusted($sce.JS, value)`</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#parseAsHtml</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shorthand method.  `$sce.parseAsHtml(expression string)` →</span>
<span class="Comment">     *     {@link ng.$sce#methods_parse `$sce.parseAs($sce.HTML, value)`}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} expression String expression to compile.</span>
<span class="Comment">     * @returns {function(context, locals)} a function which represents the compiled expression:</span>
<span class="Comment">     *</span>
<span class="Comment">     *    * `context` – `{object}` – an object against which any expressions embedded in the strings</span>
<span class="Comment">     *      are evaluated against (typically a scope object).</span>
<span class="Comment">     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in</span>
<span class="Comment">     *      `context`.</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#parseAsCss</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shorthand method.  `$sce.parseAsCss(value)` →</span>
<span class="Comment">     *     {@link ng.$sce#methods_parse `$sce.parseAs($sce.CSS, value)`}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} expression String expression to compile.</span>
<span class="Comment">     * @returns {function(context, locals)} a function which represents the compiled expression:</span>
<span class="Comment">     *</span>
<span class="Comment">     *    * `context` – `{object}` – an object against which any expressions embedded in the strings</span>
<span class="Comment">     *      are evaluated against (typically a scope object).</span>
<span class="Comment">     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in</span>
<span class="Comment">     *      `context`.</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#parseAsUrl</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shorthand method.  `$sce.parseAsUrl(value)` →</span>
<span class="Comment">     *     {@link ng.$sce#methods_parse `$sce.parseAs($sce.URL, value)`}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} expression String expression to compile.</span>
<span class="Comment">     * @returns {function(context, locals)} a function which represents the compiled expression:</span>
<span class="Comment">     *</span>
<span class="Comment">     *    * `context` – `{object}` – an object against which any expressions embedded in the strings</span>
<span class="Comment">     *      are evaluated against (typically a scope object).</span>
<span class="Comment">     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in</span>
<span class="Comment">     *      `context`.</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#parseAsResourceUrl</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shorthand method.  `$sce.parseAsResourceUrl(value)` →</span>
<span class="Comment">     *     {@link ng.$sce#methods_parse `$sce.parseAs($sce.RESOURCE_URL, value)`}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} expression String expression to compile.</span>
<span class="Comment">     * @returns {function(context, locals)} a function which represents the compiled expression:</span>
<span class="Comment">     *</span>
<span class="Comment">     *    * `context` – `{object}` – an object against which any expressions embedded in the strings</span>
<span class="Comment">     *      are evaluated against (typically a scope object).</span>
<span class="Comment">     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in</span>
<span class="Comment">     *      `context`.</span>
<span class="Comment">     */</span>

    <span class="Comment">/**</span>
<span class="Comment">     * @ngdoc method</span>
<span class="Comment">     * @name ng.$sce#parseAsJs</span>
<span class="Comment">     * @methodOf ng.$sce</span>
<span class="Comment">     *</span>
<span class="Comment">     * @description</span>
<span class="Comment">     * Shorthand method.  `$sce.parseAsJs(value)` →</span>
<span class="Comment">     *     {@link ng.$sce#methods_parse `$sce.parseAs($sce.JS, value)`}</span>
<span class="Comment">     *</span>
<span class="Comment">     * @param {string} expression String expression to compile.</span>
<span class="Comment">     * @returns {function(context, locals)} a function which represents the compiled expression:</span>
<span class="Comment">     *</span>
<span class="Comment">     *    * `context` – `{object}` – an object against which any expressions embedded in the strings</span>
<span class="Comment">     *      are evaluated against (typically a scope object).</span>
<span class="Comment">     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in</span>
<span class="Comment">     *      `context`.</span>
<span class="Comment">     */</span>

    <span class="Comment">// Shorthand delegations.</span>
    <span class="Identifier">var</span> parse = sce.parseAs,
        getTrusted = sce.getTrusted,
        trustAs = sce.trustAs;

    forEach(SCE_CONTEXTS, <span class="Identifier">function</span> (enumValue, name) <span class="Identifier">{</span>
      <span class="Identifier">var</span> lName = lowercase(name);
      sce<span class="Identifier">[</span>camelCase(<span class="Constant">&quot;parse_as_&quot;</span> + lName)<span class="Identifier">]</span> = <span class="Identifier">function</span> (expr) <span class="Identifier">{</span>
        <span class="Statement">return</span> parse(enumValue, expr);
      <span class="Identifier">}</span>;
      sce<span class="Identifier">[</span>camelCase(<span class="Constant">&quot;get_trusted_&quot;</span> + lName)<span class="Identifier">]</span> = <span class="Identifier">function</span> (value) <span class="Identifier">{</span>
        <span class="Statement">return</span> getTrusted(enumValue, value);
      <span class="Identifier">}</span>;
      sce<span class="Identifier">[</span>camelCase(<span class="Constant">&quot;trust_as_&quot;</span> + lName)<span class="Identifier">]</span> = <span class="Identifier">function</span> (value) <span class="Identifier">{</span>
        <span class="Statement">return</span> trustAs(enumValue, value);
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>);

    <span class="Statement">return</span> sce;
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * !!! This is an undocumented &quot;private&quot; service !!!</span>
<span class="Comment"> *</span>
<span class="Comment"> * @name ng.$sniffer</span>
<span class="Comment"> * @requires $window</span>
<span class="Comment"> * @requires $document</span>
<span class="Comment"> *</span>
<span class="Comment"> * @property {boolean} history Does the browser support html5 history api ?</span>
<span class="Comment"> * @property {boolean} hashchange Does the browser support hashchange event ?</span>
<span class="Comment"> * @property {boolean} transitions Does the browser support CSS transition events ?</span>
<span class="Comment"> * @property {boolean} animations Does the browser support CSS animation events ?</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * This is very simple implementation of testing browser's features.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $SnifferProvider() <span class="Identifier">{</span>
  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$window'</span>, <span class="Constant">'$document'</span>, <span class="Identifier">function</span>($<span class="Statement">window</span>, $<span class="Statement">document</span>) <span class="Identifier">{</span>
    <span class="Identifier">var</span> eventSupport = <span class="Identifier">{}</span>,
        android =
          <span class="Statement">int</span>((<span class="Constant">/android (\d+)/</span>.exec(lowercase(($<span class="Statement">window</span>.navigator || <span class="Identifier">{}</span>).userAgent)) || <span class="Identifier">[]</span>)<span class="Identifier">[</span>1<span class="Identifier">]</span>),
        boxee = <span class="Constant">/Boxee/i</span>.test(($<span class="Statement">window</span>.navigator || <span class="Identifier">{}</span>).userAgent),
        <span class="Statement">document</span> = $<span class="Statement">document</span><span class="Identifier">[</span>0<span class="Identifier">]</span> || <span class="Identifier">{}</span>,
        documentMode = <span class="Statement">document</span>.documentMode,
        vendorPrefix,
        vendorRegex = <span class="Constant">/^(Moz|webkit|O|ms)(?=[A-Z])/</span>,
        bodyStyle = <span class="Statement">document</span>.body &amp;&amp; <span class="Statement">document</span>.body.style,
        transitions = <span class="Constant">false</span>,
        animations = <span class="Constant">false</span>,
        match;

    <span class="Statement">if</span> (bodyStyle) <span class="Identifier">{</span>
      <span class="Statement">for</span>(<span class="Identifier">var</span> prop <span class="Statement">in</span> bodyStyle) <span class="Identifier">{</span>
        <span class="Statement">if</span>(match = vendorRegex.exec(prop)) <span class="Identifier">{</span>
          vendorPrefix = match<span class="Identifier">[</span>0<span class="Identifier">]</span>;
          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
          <span class="Statement">break</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>

      <span class="Statement">if</span>(!vendorPrefix) <span class="Identifier">{</span>
        vendorPrefix = (<span class="Constant">'WebkitOpacity'</span> <span class="Statement">in</span> bodyStyle) &amp;&amp; <span class="Constant">'webkit'</span>;
      <span class="Identifier">}</span>

      transitions = !!((<span class="Constant">'transition'</span> <span class="Statement">in</span> bodyStyle) || (vendorPrefix + <span class="Constant">'Transition'</span> <span class="Statement">in</span> bodyStyle));
      animations  = !!((<span class="Constant">'animation'</span> <span class="Statement">in</span> bodyStyle) || (vendorPrefix + <span class="Constant">'Animation'</span> <span class="Statement">in</span> bodyStyle));

      <span class="Statement">if</span> (android &amp;&amp; (!transitions||!animations)) <span class="Identifier">{</span>
        transitions = isString(<span class="Statement">document</span>.body.style.webkitTransition);
        animations = isString(<span class="Statement">document</span>.body.style.webkitAnimation);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>


    <span class="Statement">return</span> <span class="Identifier">{</span>
      <span class="Comment">// Android has history.pushState, but it does not update location correctly</span>
      <span class="Comment">// so let's not use the history API at all.</span>
      <span class="Comment">// <a href="http://code.google.com/p/android/issues/detail?id=17471">http://code.google.com/p/android/issues/detail?id=17471</a></span>
      <span class="Comment">// <a href="https://github.com/angular/angular.js/issues/904">https://github.com/angular/angular.js/issues/904</a></span>

      <span class="Comment">// older webit browser (533.9) on Boxee box has exactly the same problem as Android has</span>
      <span class="Comment">// so let's not use the history API also</span>
      <span class="Comment">// We are purposefully using `!(android &lt; 4)` to cover the case when `android` is undefined</span>
      <span class="Comment">// jshint -W018</span>
      history: !!($<span class="Statement">window</span>.history &amp;&amp; $<span class="Statement">window</span>.history.pushState &amp;&amp; !(android &lt; 4) &amp;&amp; !boxee),
      <span class="Comment">// jshint +W018</span>
      hashchange: <span class="Constant">'onhashchange'</span> <span class="Statement">in</span> $<span class="Statement">window</span> &amp;&amp;
                  <span class="Comment">// IE8 compatible mode lies</span>
                  (!documentMode || documentMode &gt; 7),
      hasEvent: <span class="Identifier">function</span>(<span class="Statement">event</span>) <span class="Identifier">{</span>
        <span class="Comment">// IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have</span>
        <span class="Comment">// it. In particular the event is not fired when backspace or delete key are pressed or</span>
        <span class="Comment">// when cut operation is performed.</span>
        <span class="Statement">if</span> (<span class="Statement">event</span> == <span class="Constant">'input'</span> &amp;&amp; msie == 9) <span class="Statement">return</span> <span class="Constant">false</span>;

        <span class="Statement">if</span> (isUndefined(eventSupport<span class="Identifier">[</span><span class="Statement">event</span><span class="Identifier">]</span>)) <span class="Identifier">{</span>
          <span class="Identifier">var</span> divElm = <span class="Statement">document</span>.createElement(<span class="Constant">'div'</span>);
          eventSupport<span class="Identifier">[</span><span class="Statement">event</span><span class="Identifier">]</span> = <span class="Constant">'on'</span> + <span class="Statement">event</span> <span class="Statement">in</span> divElm;
        <span class="Identifier">}</span>

        <span class="Statement">return</span> eventSupport<span class="Identifier">[</span><span class="Statement">event</span><span class="Identifier">]</span>;
      <span class="Identifier">}</span>,
      csp: csp(),
      vendorPrefix: vendorPrefix,
      transitions : transitions,
      animations : animations,
      msie : msie,
      msieDocumentMode: documentMode
    <span class="Identifier">}</span>;
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Identifier">function</span> $TimeoutProvider() <span class="Identifier">{</span>
  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$rootScope'</span>, <span class="Constant">'$browser'</span>, <span class="Constant">'$q'</span>, <span class="Constant">'$exceptionHandler'</span>,
       <span class="Identifier">function</span>($rootScope,   $browser,   $q,   $exceptionHandler) <span class="Identifier">{</span>
    <span class="Identifier">var</span> deferreds = <span class="Identifier">{}</span>;


     <span class="Comment">/**</span>
<span class="Comment">      * @ngdoc function</span>
<span class="Comment">      * @name ng.$timeout</span>
<span class="Comment">      * @requires $browser</span>
<span class="Comment">      *</span>
<span class="Comment">      * @description</span>
<span class="Comment">      * Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch</span>
<span class="Comment">      * block and delegates any exceptions to</span>
<span class="Comment">      * {@link ng.$exceptionHandler $exceptionHandler} service.</span>
<span class="Comment">      *</span>
<span class="Comment">      * The return value of registering a timeout function is a promise, which will be resolved when</span>
<span class="Comment">      * the timeout is reached and the timeout function is executed.</span>
<span class="Comment">      *</span>
<span class="Comment">      * To cancel a timeout request, call `$timeout.cancel(promise)`.</span>
<span class="Comment">      *</span>
<span class="Comment">      * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} to</span>
<span class="Comment">      * synchronously flush the queue of deferred functions.</span>
<span class="Comment">      *</span>
<span class="Comment">      * @param {function()} fn A function, whose execution should be delayed.</span>
<span class="Comment">      * @param {number=} [delay=0] Delay in milliseconds.</span>
<span class="Comment">      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise</span>
<span class="Comment">      *   will invoke `fn` within the {@link ng.$rootScope.Scope#methods_$apply $apply} block.</span>
<span class="Comment">      * @returns {Promise} Promise that will be resolved when the timeout is reached. The value this</span>
<span class="Comment">      *   promise will be resolved with is the return value of the `fn` function.</span>
<span class="Comment">      * </span>
<span class="Comment">      * @example</span>
<span class="Comment">      &lt;doc:example module=&quot;time&quot;&gt;</span>
<span class="Comment">        &lt;doc:source&gt;</span>
<span class="Comment">          &lt;script&gt;</span>
<span class="Comment">            function Ctrl2($scope,$timeout) {</span>
<span class="Comment">              $scope.format = 'M/d/yy h:mm:ss a';</span>
<span class="Comment">              $scope.blood_1 = 100;</span>
<span class="Comment">              $scope.blood_2 = 120;</span>

<span class="Comment">              var stop;</span>
<span class="Comment">              $scope.fight = function() {</span>
<span class="Comment">                stop = $timeout(function() {</span>
<span class="Comment">                  if ($scope.blood_1 &gt; 0 &amp;&amp; $scope.blood_2 &gt; 0) {</span>
<span class="Comment">                      $scope.blood_1 = $scope.blood_1 - 3;</span>
<span class="Comment">                      $scope.blood_2 = $scope.blood_2 - 4;</span>
<span class="Comment">                      $scope.fight();</span>
<span class="Comment">                  } else {</span>
<span class="Comment">                      $timeout.cancel(stop);</span>
<span class="Comment">                  }</span>
<span class="Comment">                }, 100);</span>
<span class="Comment">              };</span>

<span class="Comment">              $scope.stopFight = function() {</span>
<span class="Comment">                $timeout.cancel(stop);</span>
<span class="Comment">              };</span>

<span class="Comment">              $scope.resetFight = function() {</span>
<span class="Comment">                $scope.blood_1 = 100;</span>
<span class="Comment">                $scope.blood_2 = 120;</span>
<span class="Comment">              }</span>
<span class="Comment">            }</span>

<span class="Comment">            angular.module('time', [])</span>
<span class="Comment">              // Register the 'myCurrentTime' directive factory method.</span>
<span class="Comment">              // We inject $timeout and dateFilter service since the factory method is DI.</span>
<span class="Comment">              .directive('myCurrentTime', function($timeout, dateFilter) {</span>
<span class="Comment">                // return the directive link function. (compile function not needed)</span>
<span class="Comment">                return function(scope, element, attrs) {</span>
<span class="Comment">                  var format,  // date format</span>
<span class="Comment">                  timeoutId; // timeoutId, so that we can cancel the time updates</span>

<span class="Comment">                  // used to update the UI</span>
<span class="Comment">                  function updateTime() {</span>
<span class="Comment">                    element.text(dateFilter(new Date(), format));</span>
<span class="Comment">                  }</span>

<span class="Comment">                  // watch the expression, and update the UI on change.</span>
<span class="Comment">                  scope.$watch(attrs.myCurrentTime, function(value) {</span>
<span class="Comment">                    format = value;</span>
<span class="Comment">                    updateTime();</span>
<span class="Comment">                  });</span>

<span class="Comment">                  // schedule update in one second</span>
<span class="Comment">                  function updateLater() {</span>
<span class="Comment">                    // save the timeoutId for canceling</span>
<span class="Comment">                    timeoutId = $timeout(function() {</span>
<span class="Comment">                      updateTime(); // update DOM</span>
<span class="Comment">                      updateLater(); // schedule another update</span>
<span class="Comment">                    }, 1000);</span>
<span class="Comment">                  }</span>

<span class="Comment">                  // listen on DOM destroy (removal) event, and cancel the next UI update</span>
<span class="Comment">                  // to prevent updating time ofter the DOM element was removed.</span>
<span class="Comment">                  element.bind('$destroy', function() {</span>
<span class="Comment">                    $timeout.cancel(timeoutId);</span>
<span class="Comment">                  });</span>

<span class="Comment">                  updateLater(); // kick off the UI update process.</span>
<span class="Comment">                }</span>
<span class="Comment">              });</span>
<span class="Comment">          &lt;/script&gt;</span>

<span class="Comment">          &lt;div&gt;</span>
<span class="Comment">            &lt;div ng-controller=&quot;Ctrl2&quot;&gt;</span>
<span class="Comment">              Date format: &lt;input ng-model=&quot;format&quot;&gt; &lt;hr/&gt;</span>
<span class="Comment">              Current time is: &lt;span my-current-time=&quot;format&quot;&gt;&lt;/span&gt;</span>
<span class="Comment">              &lt;hr/&gt;</span>
<span class="Comment">              Blood 1 : &lt;font color='red'&gt;{{blood_1}}&lt;/font&gt;</span>
<span class="Comment">              Blood 2 : &lt;font color='red'&gt;{{blood_2}}&lt;/font&gt;</span>
<span class="Comment">              &lt;button type=&quot;button&quot; data-ng-click=&quot;fight()&quot;&gt;Fight&lt;/button&gt;</span>
<span class="Comment">              &lt;button type=&quot;button&quot; data-ng-click=&quot;stopFight()&quot;&gt;StopFight&lt;/button&gt;</span>
<span class="Comment">              &lt;button type=&quot;button&quot; data-ng-click=&quot;resetFight()&quot;&gt;resetFight&lt;/button&gt;</span>
<span class="Comment">            &lt;/div&gt;</span>
<span class="Comment">          &lt;/div&gt;</span>

<span class="Comment">        &lt;/doc:source&gt;</span>
<span class="Comment">      &lt;/doc:example&gt;</span>
<span class="Comment">      */</span>
    <span class="Identifier">function</span> timeout(fn, delay, invokeApply) <span class="Identifier">{</span>
      <span class="Identifier">var</span> deferred = $q.defer(),
          promise = deferred.promise,
          skipApply = (isDefined(invokeApply) &amp;&amp; !invokeApply),
          timeoutId;

      timeoutId = $browser.defer(<span class="Identifier">function</span>() <span class="Identifier">{</span>
        <span class="Statement">try</span> <span class="Identifier">{</span>
          deferred.resolve(fn());
        <span class="Identifier">}</span> <span class="Statement">catch</span>(e) <span class="Identifier">{</span>
          deferred.reject(e);
          $exceptionHandler(e);
        <span class="Identifier">}</span>
        <span class="Statement">finally</span> <span class="Identifier">{</span>
          <span class="Statement">delete</span> deferreds<span class="Identifier">[</span>promise.$$timeoutId<span class="Identifier">]</span>;
        <span class="Identifier">}</span>

        <span class="Statement">if</span> (!skipApply) $rootScope.$apply();
      <span class="Identifier">}</span>, delay);

      promise.$$timeoutId = timeoutId;
      deferreds<span class="Identifier">[</span>timeoutId<span class="Identifier">]</span> = deferred;

      <span class="Statement">return</span> promise;
    <span class="Identifier">}</span>


     <span class="Comment">/**</span>
<span class="Comment">      * @ngdoc function</span>
<span class="Comment">      * @name ng.$timeout#cancel</span>
<span class="Comment">      * @methodOf ng.$timeout</span>
<span class="Comment">      *</span>
<span class="Comment">      * @description</span>
<span class="Comment">      * Cancels a task associated with the `promise`. As a result of this, the promise will be</span>
<span class="Comment">      * resolved with a rejection.</span>
<span class="Comment">      *</span>
<span class="Comment">      * @param {Promise=} promise Promise returned by the `$timeout` function.</span>
<span class="Comment">      * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully</span>
<span class="Comment">      *   canceled.</span>
<span class="Comment">      */</span>
    timeout.cancel = <span class="Identifier">function</span>(promise) <span class="Identifier">{</span>
      <span class="Statement">if</span> (promise &amp;&amp; promise.$$timeoutId <span class="Statement">in</span> deferreds) <span class="Identifier">{</span>
        deferreds<span class="Identifier">[</span>promise.$$timeoutId<span class="Identifier">]</span>.reject(<span class="Constant">'canceled'</span>);
        <span class="Statement">delete</span> deferreds<span class="Identifier">[</span>promise.$$timeoutId<span class="Identifier">]</span>;
        <span class="Statement">return</span> $browser.defer.cancel(promise.$$timeoutId);
      <span class="Identifier">}</span>
      <span class="Statement">return</span> <span class="Constant">false</span>;
    <span class="Identifier">}</span>;

    <span class="Statement">return</span> timeout;
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>

<span class="Comment">// NOTE:  The usage of window and document instead of $window and $document here is</span>
<span class="Comment">// deliberate.  This service depends on the specific behavior of anchor nodes created by the</span>
<span class="Comment">// browser (resolving and parsing URLs) that is unlikely to be provided by mock objects and</span>
<span class="Comment">// cause us to break tests.  In addition, when the browser resolves a URL for XHR, it</span>
<span class="Comment">// doesn't know about mocked locations and resolves URLs to the real document - which is</span>
<span class="Comment">// exactly the behavior needed here.  There is little value is mocking these out for this</span>
<span class="Comment">// service.</span>
<span class="Identifier">var</span> urlParsingNode = <span class="Statement">document</span>.createElement(<span class="Constant">&quot;a&quot;</span>);
<span class="Identifier">var</span> originUrl = urlResolve(<span class="Statement">window</span>.<span class="Statement">location</span>.href, <span class="Constant">true</span>);


<span class="Comment">/**</span>
<span class="Comment"> *</span>
<span class="Comment"> * Implementation Notes for non-IE browsers</span>
<span class="Comment"> * ----------------------------------------</span>
<span class="Comment"> * Assigning a URL to the href property of an anchor DOM node, even one attached to the DOM,</span>
<span class="Comment"> * results both in the normalizing and parsing of the URL.  Normalizing means that a relative</span>
<span class="Comment"> * URL will be resolved into an absolute URL in the context of the application document.</span>
<span class="Comment"> * Parsing means that the anchor node's host, hostname, protocol, port, pathname and related</span>
<span class="Comment"> * properties are all populated to reflect the normalized URL.  This approach has wide</span>
<span class="Comment"> * compatibility - Safari 1+, Mozilla 1+, Opera 7+,e etc.  See</span>
<span class="Comment"> * <a href="http://www.aptana.com/reference/html/api/HTMLAnchorElement.html">http://www.aptana.com/reference/html/api/HTMLAnchorElement.html</a></span>
<span class="Comment"> *</span>
<span class="Comment"> * Implementation Notes for IE</span>
<span class="Comment"> * ---------------------------</span>
<span class="Comment"> * IE &gt;= 8 and &lt;= 10 normalizes the URL when assigned to the anchor node similar to the other</span>
<span class="Comment"> * browsers.  However, the parsed components will not be set if the URL assigned did not specify</span>
<span class="Comment"> * them.  (e.g. if you assign a.href = &quot;foo&quot;, then a.protocol, a.host, etc. will be empty.)  We</span>
<span class="Comment"> * work around that by performing the parsing in a 2nd step by taking a previously normalized</span>
<span class="Comment"> * URL (e.g. by assigning to a.href) and assigning it a.href again.  This correctly populates the</span>
<span class="Comment"> * properties such as protocol, hostname, port, etc.</span>
<span class="Comment"> *</span>
<span class="Comment"> * IE7 does not normalize the URL when assigned to an anchor node.  (Apparently, it does, if one</span>
<span class="Comment"> * uses the inner HTML approach to assign the URL as part of an HTML snippet -</span>
<span class="Comment"> * <a href="http://stackoverflow.com/a/472729)">http://stackoverflow.com/a/472729)</a>  However, setting img[src] does normalize the URL.</span>
<span class="Comment"> * Unfortunately, setting img[src] to something like &quot;javascript:foo&quot; on IE throws an exception.</span>
<span class="Comment"> * Since the primary usage for normalizing URLs is to sanitize such URLs, we can't use that</span>
<span class="Comment"> * method and IE &lt; 8 is unsupported.</span>
<span class="Comment"> *</span>
<span class="Comment"> * References:</span>
<span class="Comment"> *   <a href="http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement">http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement</a></span>
<span class="Comment"> *   <a href="http://www.aptana.com/reference/html/api/HTMLAnchorElement.html">http://www.aptana.com/reference/html/api/HTMLAnchorElement.html</a></span>
<span class="Comment"> *   <a href="http://url.spec.whatwg.org/#urlutils">http://url.spec.whatwg.org/#urlutils</a></span>
<span class="Comment"> *   <a href="https://github.com/angular/angular.js/pull/2902">https://github.com/angular/angular.js/pull/2902</a></span>
<span class="Comment"> *   <a href="http://james.padolsey.com/javascript/parsing-urls-with-the-dom/">http://james.padolsey.com/javascript/parsing-urls-with-the-dom/</a></span>
<span class="Comment"> *</span>
<span class="Comment"> * @function</span>
<span class="Comment"> * @param {string} url The URL to be parsed.</span>
<span class="Comment"> * @description Normalizes and parses a URL.</span>
<span class="Comment"> * @returns {object} Returns the normalized URL as a dictionary.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   | member name   | Description    |</span>
<span class="Comment"> *   |---------------|----------------|</span>
<span class="Comment"> *   | href          | A normalized version of the provided URL if it was not an absolute URL |</span>
<span class="Comment"> *   | protocol      | The protocol including the trailing colon                              |</span>
<span class="Comment"> *   | host          | The host and port (if the port is non-default) of the normalizedUrl    |</span>
<span class="Comment"> *   | search        | The search params, minus the question mark                             |</span>
<span class="Comment"> *   | hash          | The hash string, minus the hash symbol</span>
<span class="Comment"> *   | hostname      | The hostname</span>
<span class="Comment"> *   | port          | The port, without &quot;:&quot;</span>
<span class="Comment"> *   | pathname      | The pathname, beginning with &quot;/&quot;</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> urlResolve(url, base) <span class="Identifier">{</span>
  <span class="Identifier">var</span> href = url;

  <span class="Statement">if</span> (msie) <span class="Identifier">{</span>
    <span class="Comment">// Normalize before parse.  Refer Implementation Notes on why this is</span>
    <span class="Comment">// done in two steps on IE.</span>
    urlParsingNode.setAttribute(<span class="Constant">&quot;href&quot;</span>, href);
    href = urlParsingNode.href;
  <span class="Identifier">}</span>

  urlParsingNode.setAttribute(<span class="Constant">'href'</span>, href);

  <span class="Comment">// urlParsingNode provides the UrlUtils interface - <a href="http://url.spec.whatwg.org/#urlutils">http://url.spec.whatwg.org/#urlutils</a></span>
  <span class="Statement">return</span> <span class="Identifier">{</span>
    href: urlParsingNode.href,
    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(<span class="Constant">/:$/</span>, <span class="Constant">''</span>) : <span class="Constant">''</span>,
    host: urlParsingNode.host,
    search: urlParsingNode.search ? urlParsingNode.search.replace(<span class="Constant">/^\?/</span>, <span class="Constant">''</span>) : <span class="Constant">''</span>,
    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(<span class="Constant">/^#/</span>, <span class="Constant">''</span>) : <span class="Constant">''</span>,
    hostname: urlParsingNode.hostname,
    port: urlParsingNode.port,
    pathname: (urlParsingNode.pathname.charAt(0) === <span class="Constant">'/'</span>)
      ? urlParsingNode.pathname
      : <span class="Constant">'/'</span> + urlParsingNode.pathname
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * Parse a request URL and determine whether this is a same-origin request as the application document.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string|object} requestUrl The url of the request as a string that will be resolved</span>
<span class="Comment"> * or a parsed URL object.</span>
<span class="Comment"> * @returns {boolean} Whether the request is for the same origin as the application document.</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> urlIsSameOrigin(requestUrl) <span class="Identifier">{</span>
  <span class="Identifier">var</span> parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
  <span class="Statement">return</span> (parsed.protocol === originUrl.protocol &amp;&amp;
          parsed.host === originUrl.host);
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$window</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * A reference to the browser's `window` object. While `window`</span>
<span class="Comment"> * is globally available in JavaScript, it causes testability problems, because</span>
<span class="Comment"> * it is a global variable. In angular we always refer to it through the</span>
<span class="Comment"> * `$window` service, so it may be overridden, removed or mocked for testing.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Expressions, like the one defined for the `ngClick` directive in the example</span>
<span class="Comment"> * below, are evaluated with respect to the current scope.  Therefore, there is</span>
<span class="Comment"> * no risk of inadvertently coding in a dependency on a global value in such an</span>
<span class="Comment"> * expression.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">       &lt;script&gt;</span>
<span class="Comment">         function Ctrl($scope, $window) {</span>
<span class="Comment">           $scope.greeting = 'Hello, World!';</span>
<span class="Comment">           $scope.doGreeting = function(greeting) {</span>
<span class="Comment">               $window.alert(greeting);</span>
<span class="Comment">           };</span>
<span class="Comment">         }</span>
<span class="Comment">       &lt;/script&gt;</span>
<span class="Comment">       &lt;div ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">         &lt;input type=&quot;text&quot; ng-model=&quot;greeting&quot; /&gt;</span>
<span class="Comment">         &lt;button ng-click=&quot;doGreeting(greeting)&quot;&gt;ALERT&lt;/button&gt;</span>
<span class="Comment">       &lt;/div&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">      it('should display the greeting in the input box', function() {</span>
<span class="Comment">       input('greeting').enter('Hello, E2E Tests');</span>
<span class="Comment">       // If we click the button it will block the test runner</span>
<span class="Comment">       // element(':button').click();</span>
<span class="Comment">      });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> $WindowProvider()<span class="Identifier">{</span>
  <span class="Identifier">this</span>.$get = valueFn(<span class="Statement">window</span>);
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.$filterProvider</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * Filters are just functions which transform input to an output. However filters need to be</span>
<span class="Comment"> * Dependency Injected. To achieve this a filter definition consists of a factory function which is</span>
<span class="Comment"> * annotated with dependencies and is responsible for creating a filter function.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   // Filter registration</span>
<span class="Comment"> *   function MyModule($provide, $filterProvider) {</span>
<span class="Comment"> *     // create a service to demonstrate injection (not always needed)</span>
<span class="Comment"> *     $provide.value('greet', function(name){</span>
<span class="Comment"> *       return 'Hello ' + name + '!';</span>
<span class="Comment"> *     });</span>
<span class="Comment"> *</span>
<span class="Comment"> *     // register a filter factory which uses the</span>
<span class="Comment"> *     // greet service to demonstrate DI.</span>
<span class="Comment"> *     $filterProvider.register('greet', function(greet){</span>
<span class="Comment"> *       // return the filter function which uses the greet service</span>
<span class="Comment"> *       // to generate salutation</span>
<span class="Comment"> *       return function(text) {</span>
<span class="Comment"> *         // filters need to be forgiving so check input validity</span>
<span class="Comment"> *         return text &amp;&amp; greet(text) || text;</span>
<span class="Comment"> *       };</span>
<span class="Comment"> *     });</span>
<span class="Comment"> *   }</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * The filter function is registered with the `$injector` under the filter name suffix with</span>
<span class="Comment"> * `Filter`.</span>
<span class="Comment"> * </span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   it('should be the same instance', inject(</span>
<span class="Comment"> *     function($filterProvider) {</span>
<span class="Comment"> *       $filterProvider.register('reverse', function(){</span>
<span class="Comment"> *         return ...;</span>
<span class="Comment"> *       });</span>
<span class="Comment"> *     },</span>
<span class="Comment"> *     function($filter, reverseFilter) {</span>
<span class="Comment"> *       expect($filter('reverse')).toBe(reverseFilter);</span>
<span class="Comment"> *     });</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * For more information about how angular filters work, and how to create your own filters, see</span>
<span class="Comment"> * {@link guide/filter Filters} in the Angular Developer Guide.</span>
<span class="Comment"> */</span>
<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc method</span>
<span class="Comment"> * @name ng.$filterProvider#register</span>
<span class="Comment"> * @methodOf ng.$filterProvider</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Register filter factory function.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {String} name Name of the filter.</span>
<span class="Comment"> * @param {function} fn The filter factory function which is injectable.</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name ng.$filter</span>
<span class="Comment"> * @function</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Filters are used for formatting data displayed to the user.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The general syntax in templates is as follows:</span>
<span class="Comment"> *</span>
<span class="Comment"> *         {{ expression [| filter_name[:parameter_value] ... ] }}</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {String} name Name of the filter function to retrieve</span>
<span class="Comment"> * @return {Function} the filter function</span>
<span class="Comment"> */</span>
$FilterProvider.$inject = <span class="Identifier">[</span><span class="Constant">'$provide'</span><span class="Identifier">]</span>;
<span class="Identifier">function</span> $FilterProvider($provide) <span class="Identifier">{</span>
  <span class="Identifier">var</span> suffix = <span class="Constant">'Filter'</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.$controllerProvider#register</span>
<span class="Comment">   * @methodOf ng.$controllerProvider</span>
<span class="Comment">   * @param {string|Object} name Name of the filter function, or an object map of filters where</span>
<span class="Comment">   *    the keys are the filter names and the values are the filter factories.</span>
<span class="Comment">   * @returns {Object} Registered filter instance, or if a map of filters was provided then a map</span>
<span class="Comment">   *    of the registered filter instances.</span>
<span class="Comment">   */</span>
  <span class="Identifier">function</span> register(name, factory) <span class="Identifier">{</span>
    <span class="Statement">if</span>(isObject(name)) <span class="Identifier">{</span>
      <span class="Identifier">var</span> filters = <span class="Identifier">{}</span>;
      forEach(name, <span class="Identifier">function</span>(filter, key) <span class="Identifier">{</span>
        filters<span class="Identifier">[</span>key<span class="Identifier">]</span> = register(key, filter);
      <span class="Identifier">}</span>);
      <span class="Statement">return</span> filters;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">return</span> $provide.factory(name + suffix, factory);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>
  <span class="Identifier">this</span>.register = register;

  <span class="Identifier">this</span>.$get = <span class="Identifier">[</span><span class="Constant">'$injector'</span>, <span class="Identifier">function</span>($injector) <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">function</span>(name) <span class="Identifier">{</span>
      <span class="Statement">return</span> $injector.get(name + suffix);
    <span class="Identifier">}</span>;
  <span class="Identifier">}]</span>;

  <span class="Comment">////////////////////////////////////////</span>

  <span class="Comment">/* global</span>
<span class="Comment">    currencyFilter: false,</span>
<span class="Comment">    dateFilter: false,</span>
<span class="Comment">    filterFilter: false,</span>
<span class="Comment">    jsonFilter: false,</span>
<span class="Comment">    limitToFilter: false,</span>
<span class="Comment">    lowercaseFilter: false,</span>
<span class="Comment">    numberFilter: false,</span>
<span class="Comment">    orderByFilter: false,</span>
<span class="Comment">    uppercaseFilter: false,</span>
<span class="Comment">  */</span>

  register(<span class="Constant">'currency'</span>, currencyFilter);
  register(<span class="Constant">'date'</span>, dateFilter);
  register(<span class="Constant">'filter'</span>, filterFilter);
  register(<span class="Constant">'json'</span>, jsonFilter);
  register(<span class="Constant">'limitTo'</span>, limitToFilter);
  register(<span class="Constant">'lowercase'</span>, lowercaseFilter);
  register(<span class="Constant">'number'</span>, numberFilter);
  register(<span class="Constant">'orderBy'</span>, orderByFilter);
  register(<span class="Constant">'uppercase'</span>, uppercaseFilter);
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc filter</span>
<span class="Comment"> * @name ng.filter:filter</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Selects a subset of items from `array` and returns it as a new array.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {Array} array The source array.</span>
<span class="Comment"> * @param {string|Object|function()} expression The predicate to be used for selecting items from</span>
<span class="Comment"> *   `array`.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   Can be one of:</span>
<span class="Comment"> *</span>
<span class="Comment"> *   - `string`: Predicate that results in a substring match using the value of `expression`</span>
<span class="Comment"> *     string. All strings or objects with string properties in `array` that contain this string</span>
<span class="Comment"> *     will be returned. The predicate can be negated by prefixing the string with `!`.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   - `Object`: A pattern object can be used to filter specific properties on objects contained</span>
<span class="Comment"> *     by `array`. For example `{name:&quot;M&quot;, phone:&quot;1&quot;}` predicate will return an array of items</span>
<span class="Comment"> *     which have property `name` containing &quot;M&quot; and property `phone` containing &quot;1&quot;. A special</span>
<span class="Comment"> *     property name `$` can be used (as in `{$:&quot;text&quot;}`) to accept a match against any</span>
<span class="Comment"> *     property of the object. That's equivalent to the simple substring match with a `string`</span>
<span class="Comment"> *     as described above.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   - `function`: A predicate function can be used to write arbitrary filters. The function is</span>
<span class="Comment"> *     called for each element of `array`. The final result is an array of those elements that</span>
<span class="Comment"> *     the predicate returned true for.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {function(expected, actual)|true|undefined} comparator Comparator which is used in</span>
<span class="Comment"> *     determining if the expected value (from the filter expression) and actual value (from</span>
<span class="Comment"> *     the object in the array) should be considered a match.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   Can be one of:</span>
<span class="Comment"> *</span>
<span class="Comment"> *     - `function(expected, actual)`:</span>
<span class="Comment"> *       The function will be given the object value and the predicate value to compare and</span>
<span class="Comment"> *       should return true if the item should be included in filtered result.</span>
<span class="Comment"> *</span>
<span class="Comment"> *     - `true`: A shorthand for `function(expected, actual) { return angular.equals(expected, actual)}`.</span>
<span class="Comment"> *       this is essentially strict comparison of expected and actual.</span>
<span class="Comment"> *</span>
<span class="Comment"> *     - `false|undefined`: A short hand for a function which will look for a substring match in case</span>
<span class="Comment"> *       insensitive way.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">       &lt;div ng-init=&quot;friends = [{name:'John', phone:'555-1276'},</span>
<span class="Comment">                                {name:'Mary', phone:'800-BIG-MARY'},</span>
<span class="Comment">                                {name:'Mike', phone:'555-4321'},</span>
<span class="Comment">                                {name:'Adam', phone:'555-5678'},</span>
<span class="Comment">                                {name:'Julie', phone:'555-8765'},</span>
<span class="Comment">                                {name:'Juliette', phone:'555-5678'}]&quot;&gt;&lt;/div&gt;</span>

<span class="Comment">       Search: &lt;input ng-model=&quot;searchText&quot;&gt;</span>
<span class="Comment">       &lt;table id=&quot;searchTextResults&quot;&gt;</span>
<span class="Comment">         &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Phone&lt;/th&gt;&lt;/tr&gt;</span>
<span class="Comment">         &lt;tr ng-repeat=&quot;friend in friends | filter:searchText&quot;&gt;</span>
<span class="Comment">           &lt;td&gt;{{friend.name}}&lt;/td&gt;</span>
<span class="Comment">           &lt;td&gt;{{friend.phone}}&lt;/td&gt;</span>
<span class="Comment">         &lt;/tr&gt;</span>
<span class="Comment">       &lt;/table&gt;</span>
<span class="Comment">       &lt;hr&gt;</span>
<span class="Comment">       Any: &lt;input ng-model=&quot;search.$&quot;&gt; &lt;br&gt;</span>
<span class="Comment">       Name only &lt;input ng-model=&quot;search.name&quot;&gt;&lt;br&gt;</span>
<span class="Comment">       Phone only &lt;input ng-model=&quot;search.phone&quot;&gt;&lt;br&gt;</span>
<span class="Comment">       Equality &lt;input type=&quot;checkbox&quot; ng-model=&quot;strict&quot;&gt;&lt;br&gt;</span>
<span class="Comment">       &lt;table id=&quot;searchObjResults&quot;&gt;</span>
<span class="Comment">         &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Phone&lt;/th&gt;&lt;/tr&gt;</span>
<span class="Comment">         &lt;tr ng-repeat=&quot;friend in friends | filter:search:strict&quot;&gt;</span>
<span class="Comment">           &lt;td&gt;{{friend.name}}&lt;/td&gt;</span>
<span class="Comment">           &lt;td&gt;{{friend.phone}}&lt;/td&gt;</span>
<span class="Comment">         &lt;/tr&gt;</span>
<span class="Comment">       &lt;/table&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should search across all fields when filtering with a string', function() {</span>
<span class="Comment">         input('searchText').enter('m');</span>
<span class="Comment">         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).</span>
<span class="Comment">           toEqual(['Mary', 'Mike', 'Adam']);</span>

<span class="Comment">         input('searchText').enter('76');</span>
<span class="Comment">         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).</span>
<span class="Comment">           toEqual(['John', 'Julie']);</span>
<span class="Comment">       });</span>

<span class="Comment">       it('should search in specific fields when filtering with a predicate object', function() {</span>
<span class="Comment">         input('search.$').enter('i');</span>
<span class="Comment">         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).</span>
<span class="Comment">           toEqual(['Mary', 'Mike', 'Julie', 'Juliette']);</span>
<span class="Comment">       });</span>
<span class="Comment">       it('should use a equal comparison when comparator is true', function() {</span>
<span class="Comment">         input('search.name').enter('Julie');</span>
<span class="Comment">         input('strict').check();</span>
<span class="Comment">         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).</span>
<span class="Comment">           toEqual(['Julie']);</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> filterFilter() <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">function</span>(array, expression, comparator) <span class="Identifier">{</span>
    <span class="Statement">if</span> (!isArray(array)) <span class="Statement">return</span> array;

    <span class="Identifier">var</span> comparatorType = <span class="Statement">typeof</span>(comparator),
        predicates = <span class="Identifier">[]</span>;

    predicates.check = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
      <span class="Statement">for</span> (<span class="Identifier">var</span> j = 0; j &lt; predicates.length; j++) <span class="Identifier">{</span>
        <span class="Statement">if</span>(!predicates<span class="Identifier">[</span>j<span class="Identifier">]</span>(value)) <span class="Identifier">{</span>
          <span class="Statement">return</span> <span class="Constant">false</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
      <span class="Statement">return</span> <span class="Constant">true</span>;
    <span class="Identifier">}</span>;

    <span class="Statement">if</span> (comparatorType !== <span class="Constant">'function'</span>) <span class="Identifier">{</span>
      <span class="Statement">if</span> (comparatorType === <span class="Constant">'boolean'</span> &amp;&amp; comparator) <span class="Identifier">{</span>
        comparator = <span class="Identifier">function</span>(obj, text) <span class="Identifier">{</span>
          <span class="Statement">return</span> angular.equals(obj, text);
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        comparator = <span class="Identifier">function</span>(obj, text) <span class="Identifier">{</span>
          text = (<span class="Constant">''</span>+text).toLowerCase();
          <span class="Statement">return</span> (<span class="Constant">''</span>+obj).toLowerCase().indexOf(text) &gt; -1;
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Identifier">var</span> search = <span class="Identifier">function</span>(obj, text)<span class="Identifier">{</span>
      <span class="Statement">if</span> (<span class="Statement">typeof</span> text == <span class="Constant">'string'</span> &amp;&amp; text.charAt(0) === <span class="Constant">'!'</span>) <span class="Identifier">{</span>
        <span class="Statement">return</span> !search(obj, text.substr(1));
      <span class="Identifier">}</span>
      <span class="Statement">switch</span> (<span class="Statement">typeof</span> obj) <span class="Identifier">{</span>
        <span class="Statement">case</span> <span class="Constant">&quot;boolean&quot;</span>:
        <span class="Statement">case</span> <span class="Constant">&quot;number&quot;</span>:
        <span class="Statement">case</span> <span class="Constant">&quot;string&quot;</span>:
          <span class="Statement">return</span> comparator(obj, text);
        <span class="Statement">case</span> <span class="Constant">&quot;object&quot;</span>:
          <span class="Statement">switch</span> (<span class="Statement">typeof</span> text) <span class="Identifier">{</span>
            <span class="Statement">case</span> <span class="Constant">&quot;object&quot;</span>:
              <span class="Statement">return</span> comparator(obj, text);
            <span class="Statement">default</span>:
              <span class="Statement">for</span> ( <span class="Identifier">var</span> objKey <span class="Statement">in</span> obj) <span class="Identifier">{</span>
                <span class="Statement">if</span> (objKey.charAt(0) !== <span class="Constant">'$'</span> &amp;&amp; search(obj<span class="Identifier">[</span>objKey<span class="Identifier">]</span>, text)) <span class="Identifier">{</span>
                  <span class="Statement">return</span> <span class="Constant">true</span>;
                <span class="Identifier">}</span>
              <span class="Identifier">}</span>
              <span class="Statement">break</span>;
          <span class="Identifier">}</span>
          <span class="Statement">return</span> <span class="Constant">false</span>;
        <span class="Statement">case</span> <span class="Constant">&quot;array&quot;</span>:
          <span class="Statement">for</span> ( <span class="Identifier">var</span> i = 0; i &lt; obj.length; i++) <span class="Identifier">{</span>
            <span class="Statement">if</span> (search(obj<span class="Identifier">[</span>i<span class="Identifier">]</span>, text)) <span class="Identifier">{</span>
              <span class="Statement">return</span> <span class="Constant">true</span>;
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
          <span class="Statement">return</span> <span class="Constant">false</span>;
        <span class="Statement">default</span>:
          <span class="Statement">return</span> <span class="Constant">false</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;
    <span class="Statement">switch</span> (<span class="Statement">typeof</span> expression) <span class="Identifier">{</span>
      <span class="Statement">case</span> <span class="Constant">&quot;boolean&quot;</span>:
      <span class="Statement">case</span> <span class="Constant">&quot;number&quot;</span>:
      <span class="Statement">case</span> <span class="Constant">&quot;string&quot;</span>:
        <span class="Comment">// Set up expression object and fall through</span>
        expression = <span class="Identifier">{</span>$:expression<span class="Identifier">}</span>;
        <span class="Comment">// jshint -W086</span>
      <span class="Statement">case</span> <span class="Constant">&quot;object&quot;</span>:
        <span class="Comment">// jshint +W086</span>
        <span class="Statement">for</span> (<span class="Identifier">var</span> key <span class="Statement">in</span> expression) <span class="Identifier">{</span>
          <span class="Statement">if</span> (key == <span class="Constant">'$'</span>) <span class="Identifier">{</span>
            (<span class="Identifier">function</span>() <span class="Identifier">{</span>
              <span class="Statement">if</span> (!expression<span class="Identifier">[</span>key<span class="Identifier">]</span>) <span class="Statement">return</span>;
              <span class="Identifier">var</span> path = key;
              predicates.push(<span class="Identifier">function</span>(value) <span class="Identifier">{</span>
                <span class="Statement">return</span> search(value, expression<span class="Identifier">[</span>path<span class="Identifier">]</span>);
              <span class="Identifier">}</span>);
            <span class="Identifier">}</span>)();
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            (<span class="Identifier">function</span>() <span class="Identifier">{</span>
              <span class="Statement">if</span> (<span class="Statement">typeof</span>(expression<span class="Identifier">[</span>key<span class="Identifier">]</span>) == <span class="Constant">'undefined'</span>) <span class="Identifier">{</span> <span class="Statement">return</span>; <span class="Identifier">}</span>
              <span class="Identifier">var</span> path = key;
              predicates.push(<span class="Identifier">function</span>(value) <span class="Identifier">{</span>
                <span class="Statement">return</span> search(getter(value,path), expression<span class="Identifier">[</span>path<span class="Identifier">]</span>);
              <span class="Identifier">}</span>);
            <span class="Identifier">}</span>)();
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
        <span class="Statement">break</span>;
      <span class="Statement">case</span> <span class="Constant">'function'</span>:
        predicates.push(expression);
        <span class="Statement">break</span>;
      <span class="Statement">default</span>:
        <span class="Statement">return</span> array;
    <span class="Identifier">}</span>
    <span class="Identifier">var</span> filtered = <span class="Identifier">[]</span>;
    <span class="Statement">for</span> ( <span class="Identifier">var</span> j = 0; j &lt; array.length; j++) <span class="Identifier">{</span>
      <span class="Identifier">var</span> value = array<span class="Identifier">[</span>j<span class="Identifier">]</span>;
      <span class="Statement">if</span> (predicates.check(value)) <span class="Identifier">{</span>
        filtered.push(value);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
    <span class="Statement">return</span> filtered;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc filter</span>
<span class="Comment"> * @name ng.filter:currency</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default</span>
<span class="Comment"> * symbol for current locale is used.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {number} amount Input to filter.</span>
<span class="Comment"> * @param {string=} symbol Currency symbol or identifier to be displayed.</span>
<span class="Comment"> * @returns {string} Formatted number.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">       &lt;script&gt;</span>
<span class="Comment">         function Ctrl($scope) {</span>
<span class="Comment">           $scope.amount = 1234.56;</span>
<span class="Comment">         }</span>
<span class="Comment">       &lt;/script&gt;</span>
<span class="Comment">       &lt;div ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">         &lt;input type=&quot;number&quot; ng-model=&quot;amount&quot;&gt; &lt;br&gt;</span>
<span class="Comment">         default currency symbol ($): {{amount | currency}}&lt;br&gt;</span>
<span class="Comment">         custom currency identifier (USD$): {{amount | currency:&quot;USD$&quot;}}</span>
<span class="Comment">       &lt;/div&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should init with 1234.56', function() {</span>
<span class="Comment">         expect(binding('amount | currency')).toBe('$1,234.56');</span>
<span class="Comment">         expect(binding('amount | currency:&quot;USD$&quot;')).toBe('USD$1,234.56');</span>
<span class="Comment">       });</span>
<span class="Comment">       it('should update', function() {</span>
<span class="Comment">         input('amount').enter('-1234');</span>
<span class="Comment">         expect(binding('amount | currency')).toBe('($1,234.00)');</span>
<span class="Comment">         expect(binding('amount | currency:&quot;USD$&quot;')).toBe('(USD$1,234.00)');</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
currencyFilter.$inject = <span class="Identifier">[</span><span class="Constant">'$locale'</span><span class="Identifier">]</span>;
<span class="Identifier">function</span> currencyFilter($locale) <span class="Identifier">{</span>
  <span class="Identifier">var</span> formats = $locale.NUMBER_FORMATS;
  <span class="Statement">return</span> <span class="Identifier">function</span>(amount, currencySymbol)<span class="Identifier">{</span>
    <span class="Statement">if</span> (isUndefined(currencySymbol)) currencySymbol = formats.CURRENCY_SYM;
    <span class="Statement">return</span> formatNumber(amount, formats.PATTERNS<span class="Identifier">[</span>1<span class="Identifier">]</span>, formats.GROUP_SEP, formats.DECIMAL_SEP, 2).
                replace(<span class="Constant">/\u00A4/g</span>, currencySymbol);
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc filter</span>
<span class="Comment"> * @name ng.filter:number</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Formats a number as text.</span>
<span class="Comment"> *</span>
<span class="Comment"> * If the input is not a number an empty string is returned.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {number|string} number Number to format.</span>
<span class="Comment"> * @param {(number|string)=} fractionSize Number of decimal places to round the number to.</span>
<span class="Comment"> * If this is not provided then the fraction size is computed from the current locale's number</span>
<span class="Comment"> * formatting pattern. In the case of the default locale, it will be 3.</span>
<span class="Comment"> * @returns {string} Number rounded to decimalPlaces and places a “,” after each third digit.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">       &lt;script&gt;</span>
<span class="Comment">         function Ctrl($scope) {</span>
<span class="Comment">           $scope.val = 1234.56789;</span>
<span class="Comment">         }</span>
<span class="Comment">       &lt;/script&gt;</span>
<span class="Comment">       &lt;div ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">         Enter number: &lt;input ng-model='val'&gt;&lt;br&gt;</span>
<span class="Comment">         Default formatting: {{val | number}}&lt;br&gt;</span>
<span class="Comment">         No fractions: {{val | number:0}}&lt;br&gt;</span>
<span class="Comment">         Negative number: {{-val | number:4}}</span>
<span class="Comment">       &lt;/div&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should format numbers', function() {</span>
<span class="Comment">         expect(binding('val | number')).toBe('1,234.568');</span>
<span class="Comment">         expect(binding('val | number:0')).toBe('1,235');</span>
<span class="Comment">         expect(binding('-val | number:4')).toBe('-1,234.5679');</span>
<span class="Comment">       });</span>

<span class="Comment">       it('should update', function() {</span>
<span class="Comment">         input('val').enter('3374.333');</span>
<span class="Comment">         expect(binding('val | number')).toBe('3,374.333');</span>
<span class="Comment">         expect(binding('val | number:0')).toBe('3,374');</span>
<span class="Comment">         expect(binding('-val | number:4')).toBe('-3,374.3330');</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>


numberFilter.$inject = <span class="Identifier">[</span><span class="Constant">'$locale'</span><span class="Identifier">]</span>;
<span class="Identifier">function</span> numberFilter($locale) <span class="Identifier">{</span>
  <span class="Identifier">var</span> formats = $locale.NUMBER_FORMATS;
  <span class="Statement">return</span> <span class="Identifier">function</span>(number, fractionSize) <span class="Identifier">{</span>
    <span class="Statement">return</span> formatNumber(number, formats.PATTERNS<span class="Identifier">[</span>0<span class="Identifier">]</span>, formats.GROUP_SEP, formats.DECIMAL_SEP,
      fractionSize);
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Identifier">var</span> DECIMAL_SEP = <span class="Constant">'.'</span>;
<span class="Identifier">function</span> formatNumber(number, pattern, groupSep, decimalSep, fractionSize) <span class="Identifier">{</span>
  <span class="Statement">if</span> (isNaN(number) || !isFinite(number)) <span class="Statement">return</span> <span class="Constant">''</span>;

  <span class="Identifier">var</span> isNegative = number &lt; 0;
  number = Math.abs(number);
  <span class="Identifier">var</span> numStr = number + <span class="Constant">''</span>,
      formatedText = <span class="Constant">''</span>,
      parts = <span class="Identifier">[]</span>;

  <span class="Identifier">var</span> hasExponent = <span class="Constant">false</span>;
  <span class="Statement">if</span> (numStr.indexOf(<span class="Constant">'e'</span>) !== -1) <span class="Identifier">{</span>
    <span class="Identifier">var</span> match = numStr.match(<span class="Constant">/([\d\.]+)e(-?)(\d+)/</span>);
    <span class="Statement">if</span> (match &amp;&amp; match<span class="Identifier">[</span>2<span class="Identifier">]</span> == <span class="Constant">'-'</span> &amp;&amp; match<span class="Identifier">[</span>3<span class="Identifier">]</span> &gt; fractionSize + 1) <span class="Identifier">{</span>
      numStr = <span class="Constant">'0'</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      formatedText = numStr;
      hasExponent = <span class="Constant">true</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>

  <span class="Statement">if</span> (!hasExponent) <span class="Identifier">{</span>
    <span class="Identifier">var</span> fractionLen = (numStr.split(DECIMAL_SEP)<span class="Identifier">[</span>1<span class="Identifier">]</span> || <span class="Constant">''</span>).length;

    <span class="Comment">// determine fractionSize if it is not specified</span>
    <span class="Statement">if</span> (isUndefined(fractionSize)) <span class="Identifier">{</span>
      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
    <span class="Identifier">}</span>

    <span class="Identifier">var</span> pow = Math.pow(10, fractionSize);
    number = Math.round(number * pow) / pow;
    <span class="Identifier">var</span> fraction = (<span class="Constant">''</span> + number).split(DECIMAL_SEP);
    <span class="Identifier">var</span> whole = fraction<span class="Identifier">[</span>0<span class="Identifier">]</span>;
    fraction = fraction<span class="Identifier">[</span>1<span class="Identifier">]</span> || <span class="Constant">''</span>;

    <span class="Identifier">var</span> i, pos = 0,
        lgroup = pattern.lgSize,
        group = pattern.gSize;

    <span class="Statement">if</span> (whole.length &gt;= (lgroup + group)) <span class="Identifier">{</span>
      pos = whole.length - lgroup;
      <span class="Statement">for</span> (i = 0; i &lt; pos; i++) <span class="Identifier">{</span>
        <span class="Statement">if</span> ((pos - i)%group === 0 &amp;&amp; i !== 0) <span class="Identifier">{</span>
          formatedText += groupSep;
        <span class="Identifier">}</span>
        formatedText += whole.charAt(i);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Statement">for</span> (i = pos; i &lt; whole.length; i++) <span class="Identifier">{</span>
      <span class="Statement">if</span> ((whole.length - i)%lgroup === 0 &amp;&amp; i !== 0) <span class="Identifier">{</span>
        formatedText += groupSep;
      <span class="Identifier">}</span>
      formatedText += whole.charAt(i);
    <span class="Identifier">}</span>

    <span class="Comment">// format fraction part.</span>
    <span class="Statement">while</span>(fraction.length &lt; fractionSize) <span class="Identifier">{</span>
      fraction += <span class="Constant">'0'</span>;
    <span class="Identifier">}</span>

    <span class="Statement">if</span> (fractionSize &amp;&amp; fractionSize !== <span class="Constant">&quot;0&quot;</span>) formatedText += decimalSep + fraction.substr(0, fractionSize);
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>

    <span class="Statement">if</span> (fractionSize &gt; 0 &amp;&amp; number &gt; -1 &amp;&amp; number &lt; 1) <span class="Identifier">{</span>
      formatedText = number.toFixed(fractionSize);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>

  parts.push(isNegative ? pattern.negPre : pattern.posPre);
  parts.push(formatedText);
  parts.push(isNegative ? pattern.negSuf : pattern.posSuf);
  <span class="Statement">return</span> parts.join(<span class="Constant">''</span>);
<span class="Identifier">}</span>

<span class="Identifier">function</span> padNumber(num, digits, trim) <span class="Identifier">{</span>
  <span class="Identifier">var</span> neg = <span class="Constant">''</span>;
  <span class="Statement">if</span> (num &lt; 0) <span class="Identifier">{</span>
    neg =  <span class="Constant">'-'</span>;
    num = -num;
  <span class="Identifier">}</span>
  num = <span class="Constant">''</span> + num;
  <span class="Statement">while</span>(num.length &lt; digits) num = <span class="Constant">'0'</span> + num;
  <span class="Statement">if</span> (trim)
    num = num.substr(num.length - digits);
  <span class="Statement">return</span> neg + num;
<span class="Identifier">}</span>


<span class="Identifier">function</span> dateGetter(name, size, offset, trim) <span class="Identifier">{</span>
  offset = offset || 0;
  <span class="Statement">return</span> <span class="Identifier">function</span>(date) <span class="Identifier">{</span>
    <span class="Identifier">var</span> value = date<span class="Identifier">[</span><span class="Constant">'get'</span> + name<span class="Identifier">]</span>();
    <span class="Statement">if</span> (offset &gt; 0 || value &gt; -offset)
      value += offset;
    <span class="Statement">if</span> (value === 0 &amp;&amp; offset == -12 ) value = 12;
    <span class="Statement">return</span> padNumber(value, size, trim);
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Identifier">function</span> dateStrGetter(name, shortForm) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">function</span>(date, formats) <span class="Identifier">{</span>
    <span class="Identifier">var</span> value = date<span class="Identifier">[</span><span class="Constant">'get'</span> + name<span class="Identifier">]</span>();
    <span class="Identifier">var</span> get = uppercase(shortForm ? (<span class="Constant">'SHORT'</span> + name) : name);

    <span class="Statement">return</span> formats<span class="Identifier">[</span>get<span class="Identifier">][</span>value<span class="Identifier">]</span>;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Identifier">function</span> timeZoneGetter(date) <span class="Identifier">{</span>
  <span class="Identifier">var</span> zone = -1 * date.getTimezoneOffset();
  <span class="Identifier">var</span> paddedZone = (zone &gt;= 0) ? <span class="Constant">&quot;+&quot;</span> : <span class="Constant">&quot;&quot;</span>;

  paddedZone += padNumber(Math<span class="Identifier">[</span>zone &gt; 0 ? <span class="Constant">'floor'</span> : <span class="Constant">'ceil'</span><span class="Identifier">]</span>(zone / 60), 2) +
                padNumber(Math.abs(zone % 60), 2);

  <span class="Statement">return</span> paddedZone;
<span class="Identifier">}</span>

<span class="Identifier">function</span> ampmGetter(date, formats) <span class="Identifier">{</span>
  <span class="Statement">return</span> date.getHours() &lt; 12 ? formats.AMPMS<span class="Identifier">[</span>0<span class="Identifier">]</span> : formats.AMPMS<span class="Identifier">[</span>1<span class="Identifier">]</span>;
<span class="Identifier">}</span>

<span class="Identifier">var</span> DATE_FORMATS = <span class="Identifier">{</span>
  yyyy: dateGetter(<span class="Constant">'FullYear'</span>, 4),
    yy: dateGetter(<span class="Constant">'FullYear'</span>, 2, 0, <span class="Constant">true</span>),
     y: dateGetter(<span class="Constant">'FullYear'</span>, 1),
  MMMM: dateStrGetter(<span class="Constant">'Month'</span>),
   MMM: dateStrGetter(<span class="Constant">'Month'</span>, <span class="Constant">true</span>),
    MM: dateGetter(<span class="Constant">'Month'</span>, 2, 1),
     M: dateGetter(<span class="Constant">'Month'</span>, 1, 1),
    dd: dateGetter(<span class="Constant">'Date'</span>, 2),
     d: dateGetter(<span class="Constant">'Date'</span>, 1),
    HH: dateGetter(<span class="Constant">'Hours'</span>, 2),
     H: dateGetter(<span class="Constant">'Hours'</span>, 1),
    hh: dateGetter(<span class="Constant">'Hours'</span>, 2, -12),
     h: dateGetter(<span class="Constant">'Hours'</span>, 1, -12),
    mm: dateGetter(<span class="Constant">'Minutes'</span>, 2),
     m: dateGetter(<span class="Constant">'Minutes'</span>, 1),
    ss: dateGetter(<span class="Constant">'Seconds'</span>, 2),
     s: dateGetter(<span class="Constant">'Seconds'</span>, 1),
     <span class="Comment">// while ISO 8601 requires fractions to be prefixed with `.` or `,`</span>
     <span class="Comment">// we can be just safely rely on using `sss` since we currently don't support single or two digit fractions</span>
   sss: dateGetter(<span class="Constant">'Milliseconds'</span>, 3),
  EEEE: dateStrGetter(<span class="Constant">'Day'</span>),
   EEE: dateStrGetter(<span class="Constant">'Day'</span>, <span class="Constant">true</span>),
     a: ampmGetter,
     Z: timeZoneGetter
<span class="Identifier">}</span>;

<span class="Identifier">var</span> DATE_FORMATS_SPLIT = <span class="Constant">/((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/</span>,
    NUMBER_STRING = <span class="Constant">/^\-?\d+$/</span>;

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc filter</span>
<span class="Comment"> * @name ng.filter:date</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *   Formats `date` to a string based on the requested `format`.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   `format` string can be composed of the following elements:</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 =&gt; 0001, AD 2010 =&gt; 2010)</span>
<span class="Comment"> *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 =&gt; 01, AD 2010 =&gt; 10)</span>
<span class="Comment"> *   * `'y'`: 1 digit representation of year, e.g. (AD 1 =&gt; 1, AD 199 =&gt; 199)</span>
<span class="Comment"> *   * `'MMMM'`: Month in year (January-December)</span>
<span class="Comment"> *   * `'MMM'`: Month in year (Jan-Dec)</span>
<span class="Comment"> *   * `'MM'`: Month in year, padded (01-12)</span>
<span class="Comment"> *   * `'M'`: Month in year (1-12)</span>
<span class="Comment"> *   * `'dd'`: Day in month, padded (01-31)</span>
<span class="Comment"> *   * `'d'`: Day in month (1-31)</span>
<span class="Comment"> *   * `'EEEE'`: Day in Week,(Sunday-Saturday)</span>
<span class="Comment"> *   * `'EEE'`: Day in Week, (Sun-Sat)</span>
<span class="Comment"> *   * `'HH'`: Hour in day, padded (00-23)</span>
<span class="Comment"> *   * `'H'`: Hour in day (0-23)</span>
<span class="Comment"> *   * `'hh'`: Hour in am/pm, padded (01-12)</span>
<span class="Comment"> *   * `'h'`: Hour in am/pm, (1-12)</span>
<span class="Comment"> *   * `'mm'`: Minute in hour, padded (00-59)</span>
<span class="Comment"> *   * `'m'`: Minute in hour (0-59)</span>
<span class="Comment"> *   * `'ss'`: Second in minute, padded (00-59)</span>
<span class="Comment"> *   * `'s'`: Second in minute (0-59)</span>
<span class="Comment"> *   * `'.sss' or ',sss'`: Millisecond in second, padded (000-999)</span>
<span class="Comment"> *   * `'a'`: am/pm marker</span>
<span class="Comment"> *   * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-+1200)</span>
<span class="Comment"> *</span>
<span class="Comment"> *   `format` string can also be one of the following predefined</span>
<span class="Comment"> *   {@link guide/i18n localizable formats}:</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale</span>
<span class="Comment"> *     (e.g. Sep 3, 2010 12:05:08 pm)</span>
<span class="Comment"> *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 pm)</span>
<span class="Comment"> *   * `'fullDate'`: equivalent to `'EEEE, MMMM d,y'` for en_US  locale</span>
<span class="Comment"> *     (e.g. Friday, September 3, 2010)</span>
<span class="Comment"> *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010)</span>
<span class="Comment"> *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)</span>
<span class="Comment"> *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)</span>
<span class="Comment"> *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 pm)</span>
<span class="Comment"> *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 pm)</span>
<span class="Comment"> *</span>
<span class="Comment"> *   `format` string can contain literal values. These need to be quoted with single quotes (e.g.</span>
<span class="Comment"> *   `&quot;h 'in the morning'&quot;`). In order to output single quote, use two single quotes in a sequence</span>
<span class="Comment"> *   (e.g. `&quot;h 'o''clock'&quot;`).</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or</span>
<span class="Comment"> *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.SSSZ and its</span>
<span class="Comment"> *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is</span>
<span class="Comment"> *    specified in the string input, the time is considered to be in the local timezone.</span>
<span class="Comment"> * @param {string=} format Formatting rules (see Description). If not specified,</span>
<span class="Comment"> *    `mediumDate` is used.</span>
<span class="Comment"> * @returns {string} Formatted string or the input if input is not recognized as date/millis.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">       &lt;span ng-non-bindable&gt;{{1288323623006 | date:'medium'}}&lt;/span&gt;:</span>
<span class="Comment">           {{1288323623006 | date:'medium'}}&lt;br&gt;</span>
<span class="Comment">       &lt;span ng-non-bindable&gt;{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}&lt;/span&gt;:</span>
<span class="Comment">          {{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}&lt;br&gt;</span>
<span class="Comment">       &lt;span ng-non-bindable&gt;{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}&lt;/span&gt;:</span>
<span class="Comment">          {{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}&lt;br&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should format date', function() {</span>
<span class="Comment">         expect(binding(&quot;1288323623006 | date:'medium'&quot;)).</span>
<span class="Comment">            toMatch(/Oct 2\d, 2010 \d{1,2}:\d{2}:\d{2} (AM|PM)/);</span>
<span class="Comment">         expect(binding(&quot;1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'&quot;)).</span>
<span class="Comment">            toMatch(/2010\-10\-2\d \d{2}:\d{2}:\d{2} (\-|\+)?\d{4}/);</span>
<span class="Comment">         expect(binding(&quot;'1288323623006' | date:'MM/dd/yyyy @ h:mma'&quot;)).</span>
<span class="Comment">            toMatch(/10\/2\d\/2010 @ \d{1,2}:\d{2}(AM|PM)/);</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
dateFilter.$inject = <span class="Identifier">[</span><span class="Constant">'$locale'</span><span class="Identifier">]</span>;
<span class="Identifier">function</span> dateFilter($locale) <span class="Identifier">{</span>


  <span class="Identifier">var</span> R_ISO8601_STR = <span class="Constant">/^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/</span>;
                     <span class="Comment">// 1        2       3         4          5          6          7          8  9     10      11</span>
  <span class="Identifier">function</span> jsonStringToDate(string) <span class="Identifier">{</span>
    <span class="Identifier">var</span> match;
    <span class="Statement">if</span> (match = string.match(R_ISO8601_STR)) <span class="Identifier">{</span>
      <span class="Identifier">var</span> date = <span class="Statement">new</span> <span class="Type">Date</span>(0),
          tzHour = 0,
          tzMin  = 0,
          dateSetter = match<span class="Identifier">[</span>8<span class="Identifier">]</span> ? date.setUTCFullYear : date.setFullYear,
          timeSetter = match<span class="Identifier">[</span>8<span class="Identifier">]</span> ? date.setUTCHours : date.setHours;

      <span class="Statement">if</span> (match<span class="Identifier">[</span>9<span class="Identifier">]</span>) <span class="Identifier">{</span>
        tzHour = <span class="Statement">int</span>(match<span class="Identifier">[</span>9<span class="Identifier">]</span> + match<span class="Identifier">[</span>10<span class="Identifier">]</span>);
        tzMin = <span class="Statement">int</span>(match<span class="Identifier">[</span>9<span class="Identifier">]</span> + match<span class="Identifier">[</span>11<span class="Identifier">]</span>);
      <span class="Identifier">}</span>
      dateSetter.call(date, <span class="Statement">int</span>(match<span class="Identifier">[</span>1<span class="Identifier">]</span>), <span class="Statement">int</span>(match<span class="Identifier">[</span>2<span class="Identifier">]</span>) - 1, <span class="Statement">int</span>(match<span class="Identifier">[</span>3<span class="Identifier">]</span>));
      <span class="Identifier">var</span> h = <span class="Statement">int</span>(match<span class="Identifier">[</span>4<span class="Identifier">]</span>||0) - tzHour;
      <span class="Identifier">var</span> m = <span class="Statement">int</span>(match<span class="Identifier">[</span>5<span class="Identifier">]</span>||0) - tzMin;
      <span class="Identifier">var</span> s = <span class="Statement">int</span>(match<span class="Identifier">[</span>6<span class="Identifier">]</span>||0);
      <span class="Identifier">var</span> ms = Math.round(parseFloat(<span class="Constant">'0.'</span> + (match<span class="Identifier">[</span>7<span class="Identifier">]</span>||0)) * 1000);
      timeSetter.call(date, h, m, s, ms);
      <span class="Statement">return</span> date;
    <span class="Identifier">}</span>
    <span class="Statement">return</span> string;
  <span class="Identifier">}</span>


  <span class="Statement">return</span> <span class="Identifier">function</span>(date, format) <span class="Identifier">{</span>
    <span class="Identifier">var</span> text = <span class="Constant">''</span>,
        parts = <span class="Identifier">[]</span>,
        fn, match;

    format = format || <span class="Constant">'mediumDate'</span>;
    format = $locale.DATETIME_FORMATS<span class="Identifier">[</span>format<span class="Identifier">]</span> || format;
    <span class="Statement">if</span> (isString(date)) <span class="Identifier">{</span>
      <span class="Statement">if</span> (NUMBER_STRING.test(date)) <span class="Identifier">{</span>
        date = <span class="Statement">int</span>(date);
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        date = jsonStringToDate(date);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Statement">if</span> (isNumber(date)) <span class="Identifier">{</span>
      date = <span class="Statement">new</span> <span class="Type">Date</span>(date);
    <span class="Identifier">}</span>

    <span class="Statement">if</span> (!isDate(date)) <span class="Identifier">{</span>
      <span class="Statement">return</span> date;
    <span class="Identifier">}</span>

    <span class="Statement">while</span>(format) <span class="Identifier">{</span>
      match = DATE_FORMATS_SPLIT.exec(format);
      <span class="Statement">if</span> (match) <span class="Identifier">{</span>
        parts = concat(parts, match, 1);
        format = parts.pop();
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        parts.push(format);
        format = <span class="Statement">null</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    forEach(parts, <span class="Identifier">function</span>(value)<span class="Identifier">{</span>
      fn = DATE_FORMATS<span class="Identifier">[</span>value<span class="Identifier">]</span>;
      text += fn ? fn(date, $locale.DATETIME_FORMATS)
                 : value.replace(<span class="Constant">/(^'|'$)/g</span>, <span class="Constant">''</span>).replace(<span class="Constant">/''/g</span>, <span class="Constant">&quot;'&quot;</span>);
    <span class="Identifier">}</span>);

    <span class="Statement">return</span> text;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc filter</span>
<span class="Comment"> * @name ng.filter:json</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *   Allows you to convert a JavaScript object into JSON string.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   This filter is mostly useful for debugging. When using the double curly {{value}} notation</span>
<span class="Comment"> *   the binding is automatically converted to JSON.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.</span>
<span class="Comment"> * @returns {string} JSON string.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example:</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">       &lt;pre&gt;{{ {'name':'value'} | json }}&lt;/pre&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should jsonify filtered objects', function() {</span>
<span class="Comment">         expect(binding(&quot;{'name':'value'}&quot;)).toMatch(/\{\n  &quot;name&quot;: ?&quot;value&quot;\n}/);</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> jsonFilter() <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">function</span>(object) <span class="Identifier">{</span>
    <span class="Statement">return</span> toJson(object, <span class="Constant">true</span>);
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc filter</span>
<span class="Comment"> * @name ng.filter:lowercase</span>
<span class="Comment"> * @function</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Converts string to lowercase.</span>
<span class="Comment"> * @see angular.lowercase</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> lowercaseFilter = valueFn(lowercase);


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc filter</span>
<span class="Comment"> * @name ng.filter:uppercase</span>
<span class="Comment"> * @function</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Converts string to uppercase.</span>
<span class="Comment"> * @see angular.uppercase</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> uppercaseFilter = valueFn(uppercase);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name ng.filter:limitTo</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Creates a new array or string containing only a specified number of elements. The elements</span>
<span class="Comment"> * are taken from either the beginning or the end of the source array or string, as specified by</span>
<span class="Comment"> * the value and sign (positive or negative) of `limit`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {Array|string} input Source array or string to be limited.</span>
<span class="Comment"> * @param {string|number} limit The length of the returned array or string. If the `limit` number </span>
<span class="Comment"> *     is positive, `limit` number of items from the beginning of the source array/string are copied.</span>
<span class="Comment"> *     If the number is negative, `limit` number  of items from the end of the source array/string </span>
<span class="Comment"> *     are copied. The `limit` will be trimmed if it exceeds `array.length`</span>
<span class="Comment"> * @returns {Array|string} A new sub-array or substring of length `limit` or less if input array</span>
<span class="Comment"> *     had less than `limit` elements.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">       &lt;script&gt;</span>
<span class="Comment">         function Ctrl($scope) {</span>
<span class="Comment">           $scope.numbers = [1,2,3,4,5,6,7,8,9];</span>
<span class="Comment">           $scope.letters = &quot;abcdefghi&quot;;</span>
<span class="Comment">           $scope.numLimit = 3;</span>
<span class="Comment">           $scope.letterLimit = 3;</span>
<span class="Comment">         }</span>
<span class="Comment">       &lt;/script&gt;</span>
<span class="Comment">       &lt;div ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">         Limit {{numbers}} to: &lt;input type=&quot;integer&quot; ng-model=&quot;numLimit&quot;&gt;</span>
<span class="Comment">         &lt;p&gt;Output numbers: {{ numbers | limitTo:numLimit }}&lt;/p&gt;</span>
<span class="Comment">         Limit {{letters}} to: &lt;input type=&quot;integer&quot; ng-model=&quot;letterLimit&quot;&gt;</span>
<span class="Comment">         &lt;p&gt;Output letters: {{ letters | limitTo:letterLimit }}&lt;/p&gt;</span>
<span class="Comment">       &lt;/div&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should limit the number array to first three items', function() {</span>
<span class="Comment">         expect(element('.doc-example-live input[ng-model=numLimit]').val()).toBe('3');</span>
<span class="Comment">         expect(element('.doc-example-live input[ng-model=letterLimit]').val()).toBe('3');</span>
<span class="Comment">         expect(binding('numbers | limitTo:numLimit')).toEqual('[1,2,3]');</span>
<span class="Comment">         expect(binding('letters | limitTo:letterLimit')).toEqual('abc');</span>
<span class="Comment">       });</span>

<span class="Comment">       it('should update the output when -3 is entered', function() {</span>
<span class="Comment">         input('numLimit').enter(-3);</span>
<span class="Comment">         input('letterLimit').enter(-3);</span>
<span class="Comment">         expect(binding('numbers | limitTo:numLimit')).toEqual('[7,8,9]');</span>
<span class="Comment">         expect(binding('letters | limitTo:letterLimit')).toEqual('ghi');</span>
<span class="Comment">       });</span>

<span class="Comment">       it('should not exceed the maximum size of input array', function() {</span>
<span class="Comment">         input('numLimit').enter(100);</span>
<span class="Comment">         input('letterLimit').enter(100);</span>
<span class="Comment">         expect(binding('numbers | limitTo:numLimit')).toEqual('[1,2,3,4,5,6,7,8,9]');</span>
<span class="Comment">         expect(binding('letters | limitTo:letterLimit')).toEqual('abcdefghi');</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">function</span> limitToFilter()<span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">function</span>(input, limit) <span class="Identifier">{</span>
    <span class="Statement">if</span> (!isArray(input) &amp;&amp; !isString(input)) <span class="Statement">return</span> input;

    limit = <span class="Statement">int</span>(limit);

    <span class="Statement">if</span> (isString(input)) <span class="Identifier">{</span>
      <span class="Comment">//NaN check on limit</span>
      <span class="Statement">if</span> (limit) <span class="Identifier">{</span>
        <span class="Statement">return</span> limit &gt;= 0 ? input.slice(0, limit) : input.slice(limit, input.length);
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">return</span> <span class="Constant">&quot;&quot;</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Identifier">var</span> out = <span class="Identifier">[]</span>,
      i, n;

    <span class="Comment">// if abs(limit) exceeds maximum length, trim it</span>
    <span class="Statement">if</span> (limit &gt; input.length)
      limit = input.length;
    <span class="Statement">else</span> <span class="Statement">if</span> (limit &lt; -input.length)
      limit = -input.length;

    <span class="Statement">if</span> (limit &gt; 0) <span class="Identifier">{</span>
      i = 0;
      n = limit;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      i = input.length + limit;
      n = input.length;
    <span class="Identifier">}</span>

    <span class="Statement">for</span> (; i&lt;n; i++) <span class="Identifier">{</span>
      out.push(input<span class="Identifier">[</span>i<span class="Identifier">]</span>);
    <span class="Identifier">}</span>

    <span class="Statement">return</span> out;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc function</span>
<span class="Comment"> * @name ng.filter:orderBy</span>
<span class="Comment"> * @function</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Orders a specified `array` by the `expression` predicate.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {Array} array The array to sort.</span>
<span class="Comment"> * @param {function(*)|string|Array.&lt;(function(*)|string)&gt;} expression A predicate to be</span>
<span class="Comment"> *    used by the comparator to determine the order of elements.</span>
<span class="Comment"> *</span>
<span class="Comment"> *    Can be one of:</span>
<span class="Comment"> *</span>
<span class="Comment"> *    - `function`: Getter function. The result of this function will be sorted using the</span>
<span class="Comment"> *      `&lt;`, `=`, `&gt;` operator.</span>
<span class="Comment"> *    - `string`: An Angular expression which evaluates to an object to order by, such as 'name'</span>
<span class="Comment"> *      to sort by a property called 'name'. Optionally prefixed with `+` or `-` to control</span>
<span class="Comment"> *      ascending or descending sort order (for example, +name or -name).</span>
<span class="Comment"> *    - `Array`: An array of function or string predicates. The first predicate in the array</span>
<span class="Comment"> *      is used for sorting, but when two items are equivalent, the next predicate is used.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {boolean=} reverse Reverse the order the array.</span>
<span class="Comment"> * @returns {Array} Sorted copy of the source array.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">       &lt;script&gt;</span>
<span class="Comment">         function Ctrl($scope) {</span>
<span class="Comment">           $scope.friends =</span>
<span class="Comment">               [{name:'John', phone:'555-1212', age:10},</span>
<span class="Comment">                {name:'Mary', phone:'555-9876', age:19},</span>
<span class="Comment">                {name:'Mike', phone:'555-4321', age:21},</span>
<span class="Comment">                {name:'Adam', phone:'555-5678', age:35},</span>
<span class="Comment">                {name:'Julie', phone:'555-8765', age:29}]</span>
<span class="Comment">           $scope.predicate = '-age';</span>
<span class="Comment">         }</span>
<span class="Comment">       &lt;/script&gt;</span>
<span class="Comment">       &lt;div ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">         &lt;pre&gt;Sorting predicate = {{predicate}}; reverse = {{reverse}}&lt;/pre&gt;</span>
<span class="Comment">         &lt;hr/&gt;</span>
<span class="Comment">         [ &lt;a href=&quot;&quot; ng-click=&quot;predicate=''&quot;&gt;unsorted&lt;/a&gt; ]</span>
<span class="Comment">         &lt;table class=&quot;friend&quot;&gt;</span>
<span class="Comment">           &lt;tr&gt;</span>
<span class="Comment">             &lt;th&gt;&lt;a href=&quot;&quot; ng-click=&quot;predicate = 'name'; reverse=false&quot;&gt;Name&lt;/a&gt;</span>
<span class="Comment">                 (&lt;a href=&quot;&quot; ng-click=&quot;predicate = '-name'; reverse=false&quot;&gt;^&lt;/a&gt;)&lt;/th&gt;</span>
<span class="Comment">             &lt;th&gt;&lt;a href=&quot;&quot; ng-click=&quot;predicate = 'phone'; reverse=!reverse&quot;&gt;Phone Number&lt;/a&gt;&lt;/th&gt;</span>
<span class="Comment">             &lt;th&gt;&lt;a href=&quot;&quot; ng-click=&quot;predicate = 'age'; reverse=!reverse&quot;&gt;Age&lt;/a&gt;&lt;/th&gt;</span>
<span class="Comment">           &lt;/tr&gt;</span>
<span class="Comment">           &lt;tr ng-repeat=&quot;friend in friends | orderBy:predicate:reverse&quot;&gt;</span>
<span class="Comment">             &lt;td&gt;{{friend.name}}&lt;/td&gt;</span>
<span class="Comment">             &lt;td&gt;{{friend.phone}}&lt;/td&gt;</span>
<span class="Comment">             &lt;td&gt;{{friend.age}}&lt;/td&gt;</span>
<span class="Comment">           &lt;/tr&gt;</span>
<span class="Comment">         &lt;/table&gt;</span>
<span class="Comment">       &lt;/div&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should be reverse ordered by aged', function() {</span>
<span class="Comment">         expect(binding('predicate')).toBe('-age');</span>
<span class="Comment">         expect(repeater('table.friend', 'friend in friends').column('friend.age')).</span>
<span class="Comment">           toEqual(['35', '29', '21', '19', '10']);</span>
<span class="Comment">         expect(repeater('table.friend', 'friend in friends').column('friend.name')).</span>
<span class="Comment">           toEqual(['Adam', 'Julie', 'Mike', 'Mary', 'John']);</span>
<span class="Comment">       });</span>

<span class="Comment">       it('should reorder the table when user selects different predicate', function() {</span>
<span class="Comment">         element('.doc-example-live a:contains(&quot;Name&quot;)').click();</span>
<span class="Comment">         expect(repeater('table.friend', 'friend in friends').column('friend.name')).</span>
<span class="Comment">           toEqual(['Adam', 'John', 'Julie', 'Mary', 'Mike']);</span>
<span class="Comment">         expect(repeater('table.friend', 'friend in friends').column('friend.age')).</span>
<span class="Comment">           toEqual(['35', '10', '29', '19', '21']);</span>

<span class="Comment">         element('.doc-example-live a:contains(&quot;Phone&quot;)').click();</span>
<span class="Comment">         expect(repeater('table.friend', 'friend in friends').column('friend.phone')).</span>
<span class="Comment">           toEqual(['555-9876', '555-8765', '555-5678', '555-4321', '555-1212']);</span>
<span class="Comment">         expect(repeater('table.friend', 'friend in friends').column('friend.name')).</span>
<span class="Comment">           toEqual(['Mary', 'Julie', 'Adam', 'Mike', 'John']);</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
orderByFilter.$inject = <span class="Identifier">[</span><span class="Constant">'$parse'</span><span class="Identifier">]</span>;
<span class="Identifier">function</span> orderByFilter($parse)<span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">function</span>(array, sortPredicate, reverseOrder) <span class="Identifier">{</span>
    <span class="Statement">if</span> (!isArray(array)) <span class="Statement">return</span> array;
    <span class="Statement">if</span> (!sortPredicate) <span class="Statement">return</span> array;
    sortPredicate = isArray(sortPredicate) ? sortPredicate: <span class="Identifier">[</span>sortPredicate<span class="Identifier">]</span>;
    sortPredicate = map(sortPredicate, <span class="Identifier">function</span>(predicate)<span class="Identifier">{</span>
      <span class="Identifier">var</span> descending = <span class="Constant">false</span>, get = predicate || identity;
      <span class="Statement">if</span> (isString(predicate)) <span class="Identifier">{</span>
        <span class="Statement">if</span> ((predicate.charAt(0) == <span class="Constant">'+'</span> || predicate.charAt(0) == <span class="Constant">'-'</span>)) <span class="Identifier">{</span>
          descending = predicate.charAt(0) == <span class="Constant">'-'</span>;
          predicate = predicate.substring(1);
        <span class="Identifier">}</span>
        get = $parse(predicate);
      <span class="Identifier">}</span>
      <span class="Statement">return</span> reverseComparator(<span class="Identifier">function</span>(a,b)<span class="Identifier">{</span>
        <span class="Statement">return</span> compare(get(a),get(b));
      <span class="Identifier">}</span>, descending);
    <span class="Identifier">}</span>);
    <span class="Identifier">var</span> arrayCopy = <span class="Identifier">[]</span>;
    <span class="Statement">for</span> ( <span class="Identifier">var</span> i = 0; i &lt; array.length; i++) <span class="Identifier">{</span> arrayCopy.push(array<span class="Identifier">[</span>i<span class="Identifier">]</span>); <span class="Identifier">}</span>
    <span class="Statement">return</span> arrayCopy.sort(reverseComparator(comparator, reverseOrder));

    <span class="Identifier">function</span> comparator(o1, o2)<span class="Identifier">{</span>
      <span class="Statement">for</span> ( <span class="Identifier">var</span> i = 0; i &lt; sortPredicate.length; i++) <span class="Identifier">{</span>
        <span class="Identifier">var</span> comp = sortPredicate<span class="Identifier">[</span>i<span class="Identifier">]</span>(o1, o2);
        <span class="Statement">if</span> (comp !== 0) <span class="Statement">return</span> comp;
      <span class="Identifier">}</span>
      <span class="Statement">return</span> 0;
    <span class="Identifier">}</span>
    <span class="Identifier">function</span> reverseComparator(comp, descending) <span class="Identifier">{</span>
      <span class="Statement">return</span> toBoolean(descending)
          ? <span class="Identifier">function</span>(a,b)<span class="Identifier">{</span><span class="Statement">return</span> comp(b,a);<span class="Identifier">}</span>
          : comp;
    <span class="Identifier">}</span>
    <span class="Identifier">function</span> compare(v1, v2)<span class="Identifier">{</span>
      <span class="Identifier">var</span> t1 = <span class="Statement">typeof</span> v1;
      <span class="Identifier">var</span> t2 = <span class="Statement">typeof</span> v2;
      <span class="Statement">if</span> (t1 == t2) <span class="Identifier">{</span>
        <span class="Statement">if</span> (t1 == <span class="Constant">&quot;string&quot;</span>) <span class="Identifier">{</span>
           v1 = v1.toLowerCase();
           v2 = v2.toLowerCase();
        <span class="Identifier">}</span>
        <span class="Statement">if</span> (v1 === v2) <span class="Statement">return</span> 0;
        <span class="Statement">return</span> v1 &lt; v2 ? -1 : 1;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">return</span> t1 &lt; t2 ? -1 : 1;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Identifier">function</span> ngDirective(directive) <span class="Identifier">{</span>
  <span class="Statement">if</span> (isFunction(directive)) <span class="Identifier">{</span>
    directive = <span class="Identifier">{</span>
      link: directive
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>
  directive.restrict = directive.restrict || <span class="Constant">'AC'</span>;
  <span class="Statement">return</span> valueFn(directive);
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:a</span>
<span class="Comment"> * @restrict E</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Modifies the default behavior of the html A tag so that the default action is prevented when</span>
<span class="Comment"> * the href attribute is empty.</span>
<span class="Comment"> *</span>
<span class="Comment"> * This change permits the easy creation of action links with the `ngClick` directive</span>
<span class="Comment"> * without changing the location or causing page reloads, e.g.:</span>
<span class="Comment"> * `&lt;a href=&quot;&quot; ng-click=&quot;list.addItem()&quot;&gt;Add Item&lt;/a&gt;`</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> htmlAnchorDirective = valueFn(<span class="Identifier">{</span>
  restrict: <span class="Constant">'E'</span>,
  compile: <span class="Identifier">function</span>(element, attr) <span class="Identifier">{</span>

    <span class="Statement">if</span> (msie &lt;= 8) <span class="Identifier">{</span>

      <span class="Comment">// turn &lt;a href ng-click=&quot;..&quot;&gt;link&lt;/a&gt; into a stylable link in IE</span>
      <span class="Comment">// but only if it doesn't have name attribute, in which case it's an anchor</span>
      <span class="Statement">if</span> (!attr.href &amp;&amp; !attr.name) <span class="Identifier">{</span>
        attr.$set(<span class="Constant">'href'</span>, <span class="Constant">''</span>);
      <span class="Identifier">}</span>

      <span class="Comment">// add a comment node to anchors to workaround IE bug that causes element content to be reset</span>
      <span class="Comment">// to new attribute content if attribute is updated with value containing @ and element also</span>
      <span class="Comment">// contains value with @</span>
      <span class="Comment">// see issue #1949</span>
      element.append(<span class="Statement">document</span>.createComment(<span class="Constant">'IE fix'</span>));
    <span class="Identifier">}</span>

    <span class="Statement">return</span> <span class="Identifier">function</span>(scope, element) <span class="Identifier">{</span>
      element.on(<span class="Constant">'click'</span>, <span class="Identifier">function</span>(<span class="Statement">event</span>)<span class="Identifier">{</span>
        <span class="Comment">// if we have no href url, then don't navigate anywhere.</span>
        <span class="Statement">if</span> (!element.attr(<span class="Constant">'href'</span>)) <span class="Identifier">{</span>
          <span class="Statement">event</span>.preventDefault();
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>
<span class="Identifier">}</span>);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngHref</span>
<span class="Comment"> * @restrict A</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Using Angular markup like `{{hash}}` in an href attribute will</span>
<span class="Comment"> * make the link go to the wrong URL if the user clicks it before</span>
<span class="Comment"> * Angular has a chance to replace the `{{hash}}` markup with its</span>
<span class="Comment"> * value. Until Angular replaces the markup the link will be broken</span>
<span class="Comment"> * and will most likely return a 404 error.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The `ngHref` directive solves this problem.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The wrong way to write it:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * &lt;a href=&quot;<a href="http://www.gravatar.com/avatar/{{hash}}">http://www.gravatar.com/avatar/{{hash}}</a>&quot;/&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * The correct way to write it:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * &lt;a ng-href=&quot;<a href="http://www.gravatar.com/avatar/{{hash}}">http://www.gravatar.com/avatar/{{hash}}</a>&quot;/&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element A</span>
<span class="Comment"> * @param {template} ngHref any string which can contain `{{}}` markup.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * This example shows various combinations of `href`, `ng-href` and `ng-click` attributes</span>
<span class="Comment"> * in links and their different behaviors:</span>
<span class="Comment">    &lt;doc:example&gt;</span>
<span class="Comment">      &lt;doc:source&gt;</span>
<span class="Comment">        &lt;input ng-model=&quot;value&quot; /&gt;&lt;br /&gt;</span>
<span class="Comment">        &lt;a id=&quot;link-1&quot; href ng-click=&quot;value = 1&quot;&gt;link 1&lt;/a&gt; (link, don't reload)&lt;br /&gt;</span>
<span class="Comment">        &lt;a id=&quot;link-2&quot; href=&quot;&quot; ng-click=&quot;value = 2&quot;&gt;link 2&lt;/a&gt; (link, don't reload)&lt;br /&gt;</span>
<span class="Comment">        &lt;a id=&quot;link-3&quot; ng-href=&quot;/{{'123'}}&quot;&gt;link 3&lt;/a&gt; (link, reload!)&lt;br /&gt;</span>
<span class="Comment">        &lt;a id=&quot;link-4&quot; href=&quot;&quot; name=&quot;xx&quot; ng-click=&quot;value = 4&quot;&gt;anchor&lt;/a&gt; (link, don't reload)&lt;br /&gt;</span>
<span class="Comment">        &lt;a id=&quot;link-5&quot; name=&quot;xxx&quot; ng-click=&quot;value = 5&quot;&gt;anchor&lt;/a&gt; (no link)&lt;br /&gt;</span>
<span class="Comment">        &lt;a id=&quot;link-6&quot; ng-href=&quot;{{value}}&quot;&gt;link&lt;/a&gt; (link, change location)</span>
<span class="Comment">      &lt;/doc:source&gt;</span>
<span class="Comment">      &lt;doc:scenario&gt;</span>
<span class="Comment">        it('should execute ng-click but not reload when href without value', function() {</span>
<span class="Comment">          element('#link-1').click();</span>
<span class="Comment">          expect(input('value').val()).toEqual('1');</span>
<span class="Comment">          expect(element('#link-1').attr('href')).toBe(&quot;&quot;);</span>
<span class="Comment">        });</span>

<span class="Comment">        it('should execute ng-click but not reload when href empty string', function() {</span>
<span class="Comment">          element('#link-2').click();</span>
<span class="Comment">          expect(input('value').val()).toEqual('2');</span>
<span class="Comment">          expect(element('#link-2').attr('href')).toBe(&quot;&quot;);</span>
<span class="Comment">        });</span>

<span class="Comment">        it('should execute ng-click and change url when ng-href specified', function() {</span>
<span class="Comment">          expect(element('#link-3').attr('href')).toBe(&quot;/123&quot;);</span>

<span class="Comment">          element('#link-3').click();</span>
<span class="Comment">          expect(browser().window().path()).toEqual('/123');</span>
<span class="Comment">        });</span>

<span class="Comment">        it('should execute ng-click but not reload when href empty string and name specified', function() {</span>
<span class="Comment">          element('#link-4').click();</span>
<span class="Comment">          expect(input('value').val()).toEqual('4');</span>
<span class="Comment">          expect(element('#link-4').attr('href')).toBe('');</span>
<span class="Comment">        });</span>

<span class="Comment">        it('should execute ng-click but not reload when no href but name specified', function() {</span>
<span class="Comment">          element('#link-5').click();</span>
<span class="Comment">          expect(input('value').val()).toEqual('5');</span>
<span class="Comment">          expect(element('#link-5').attr('href')).toBe(undefined);</span>
<span class="Comment">        });</span>

<span class="Comment">        it('should only change url when only ng-href', function() {</span>
<span class="Comment">          input('value').enter('6');</span>
<span class="Comment">          expect(element('#link-6').attr('href')).toBe('6');</span>

<span class="Comment">          element('#link-6').click();</span>
<span class="Comment">          expect(browser().location().url()).toEqual('/6');</span>
<span class="Comment">        });</span>
<span class="Comment">      &lt;/doc:scenario&gt;</span>
<span class="Comment">    &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngSrc</span>
<span class="Comment"> * @restrict A</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Using Angular markup like `{{hash}}` in a `src` attribute doesn't</span>
<span class="Comment"> * work right: The browser will fetch from the URL with the literal</span>
<span class="Comment"> * text `{{hash}}` until Angular replaces the expression inside</span>
<span class="Comment"> * `{{hash}}`. The `ngSrc` directive solves this problem.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The buggy way to write it:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * &lt;img src=&quot;<a href="http://www.gravatar.com/avatar/{{hash}}">http://www.gravatar.com/avatar/{{hash}}</a>&quot;/&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * The correct way to write it:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * &lt;img ng-src=&quot;<a href="http://www.gravatar.com/avatar/{{hash}}">http://www.gravatar.com/avatar/{{hash}}</a>&quot;/&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element IMG</span>
<span class="Comment"> * @param {template} ngSrc any string which can contain `{{}}` markup.</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngSrcset</span>
<span class="Comment"> * @restrict A</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Using Angular markup like `{{hash}}` in a `srcset` attribute doesn't</span>
<span class="Comment"> * work right: The browser will fetch from the URL with the literal</span>
<span class="Comment"> * text `{{hash}}` until Angular replaces the expression inside</span>
<span class="Comment"> * `{{hash}}`. The `ngSrcset` directive solves this problem.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The buggy way to write it:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * &lt;img srcset=&quot;<a href="http://www.gravatar.com/avatar/{{hash}">http://www.gravatar.com/avatar/{{hash}</a>} 2x&quot;/&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * The correct way to write it:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * &lt;img ng-srcset=&quot;<a href="http://www.gravatar.com/avatar/{{hash}">http://www.gravatar.com/avatar/{{hash}</a>} 2x&quot;/&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element IMG</span>
<span class="Comment"> * @param {template} ngSrcset any string which can contain `{{}}` markup.</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngDisabled</span>
<span class="Comment"> * @restrict A</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * The following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * &lt;div ng-init=&quot;scope = { isDisabled: false }&quot;&gt;</span>
<span class="Comment"> *  &lt;button disabled=&quot;{{scope.isDisabled}}&quot;&gt;Disabled&lt;/button&gt;</span>
<span class="Comment"> * &lt;/div&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * The HTML specification does not require browsers to preserve the values of boolean attributes</span>
<span class="Comment"> * such as disabled. (Their presence means true and their absence means false.)</span>
<span class="Comment"> * If we put an Angular interpolation expression into such an attribute then the</span>
<span class="Comment"> * binding information would be lost when the browser removes the attribute.</span>
<span class="Comment"> * The `ngDisabled` directive solves this problem for the `disabled` attribute.</span>
<span class="Comment"> * This complementary directive is not removed by the browser and so provides</span>
<span class="Comment"> * a permanent reliable place to store the binding information.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">    &lt;doc:example&gt;</span>
<span class="Comment">      &lt;doc:source&gt;</span>
<span class="Comment">        Click me to toggle: &lt;input type=&quot;checkbox&quot; ng-model=&quot;checked&quot;&gt;&lt;br/&gt;</span>
<span class="Comment">        &lt;button ng-model=&quot;button&quot; ng-disabled=&quot;checked&quot;&gt;Button&lt;/button&gt;</span>
<span class="Comment">      &lt;/doc:source&gt;</span>
<span class="Comment">      &lt;doc:scenario&gt;</span>
<span class="Comment">        it('should toggle button', function() {</span>
<span class="Comment">          expect(element('.doc-example-live :button').prop('disabled')).toBeFalsy();</span>
<span class="Comment">          input('checked').check();</span>
<span class="Comment">          expect(element('.doc-example-live :button').prop('disabled')).toBeTruthy();</span>
<span class="Comment">        });</span>
<span class="Comment">      &lt;/doc:scenario&gt;</span>
<span class="Comment">    &lt;/doc:example&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element INPUT</span>
<span class="Comment"> * @param {expression} ngDisabled If the {@link guide/expression expression} is truthy, </span>
<span class="Comment"> *     then special attribute &quot;disabled&quot; will be set on the element</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngChecked</span>
<span class="Comment"> * @restrict A</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The HTML specification does not require browsers to preserve the values of boolean attributes</span>
<span class="Comment"> * such as checked. (Their presence means true and their absence means false.)</span>
<span class="Comment"> * If we put an Angular interpolation expression into such an attribute then the</span>
<span class="Comment"> * binding information would be lost when the browser removes the attribute.</span>
<span class="Comment"> * The `ngChecked` directive solves this problem for the `checked` attribute.</span>
<span class="Comment"> * This complementary directive is not removed by the browser and so provides</span>
<span class="Comment"> * a permanent reliable place to store the binding information.</span>
<span class="Comment"> * @example</span>
<span class="Comment">    &lt;doc:example&gt;</span>
<span class="Comment">      &lt;doc:source&gt;</span>
<span class="Comment">        Check me to check both: &lt;input type=&quot;checkbox&quot; ng-model=&quot;master&quot;&gt;&lt;br/&gt;</span>
<span class="Comment">        &lt;input id=&quot;checkSlave&quot; type=&quot;checkbox&quot; ng-checked=&quot;master&quot;&gt;</span>
<span class="Comment">      &lt;/doc:source&gt;</span>
<span class="Comment">      &lt;doc:scenario&gt;</span>
<span class="Comment">        it('should check both checkBoxes', function() {</span>
<span class="Comment">          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeFalsy();</span>
<span class="Comment">          input('master').check();</span>
<span class="Comment">          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeTruthy();</span>
<span class="Comment">        });</span>
<span class="Comment">      &lt;/doc:scenario&gt;</span>
<span class="Comment">    &lt;/doc:example&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element INPUT</span>
<span class="Comment"> * @param {expression} ngChecked If the {@link guide/expression expression} is truthy, </span>
<span class="Comment"> *     then special attribute &quot;checked&quot; will be set on the element</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngReadonly</span>
<span class="Comment"> * @restrict A</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The HTML specification does not require browsers to preserve the values of boolean attributes</span>
<span class="Comment"> * such as readonly. (Their presence means true and their absence means false.)</span>
<span class="Comment"> * If we put an Angular interpolation expression into such an attribute then the</span>
<span class="Comment"> * binding information would be lost when the browser removes the attribute.</span>
<span class="Comment"> * The `ngReadonly` directive solves this problem for the `readonly` attribute.</span>
<span class="Comment"> * This complementary directive is not removed by the browser and so provides</span>
<span class="Comment"> * a permanent reliable place to store the binding information.</span>

<span class="Comment"> * @example</span>
<span class="Comment">    &lt;doc:example&gt;</span>
<span class="Comment">      &lt;doc:source&gt;</span>
<span class="Comment">        Check me to make text readonly: &lt;input type=&quot;checkbox&quot; ng-model=&quot;checked&quot;&gt;&lt;br/&gt;</span>
<span class="Comment">        &lt;input type=&quot;text&quot; ng-readonly=&quot;checked&quot; value=&quot;I'm Angular&quot;/&gt;</span>
<span class="Comment">      &lt;/doc:source&gt;</span>
<span class="Comment">      &lt;doc:scenario&gt;</span>
<span class="Comment">        it('should toggle readonly attr', function() {</span>
<span class="Comment">          expect(element('.doc-example-live :text').prop('readonly')).toBeFalsy();</span>
<span class="Comment">          input('checked').check();</span>
<span class="Comment">          expect(element('.doc-example-live :text').prop('readonly')).toBeTruthy();</span>
<span class="Comment">        });</span>
<span class="Comment">      &lt;/doc:scenario&gt;</span>
<span class="Comment">    &lt;/doc:example&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element INPUT</span>
<span class="Comment"> * @param {expression} ngReadonly If the {@link guide/expression expression} is truthy, </span>
<span class="Comment"> *     then special attribute &quot;readonly&quot; will be set on the element</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngSelected</span>
<span class="Comment"> * @restrict A</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The HTML specification does not require browsers to preserve the values of boolean attributes</span>
<span class="Comment"> * such as selected. (Their presence means true and their absence means false.)</span>
<span class="Comment"> * If we put an Angular interpolation expression into such an attribute then the</span>
<span class="Comment"> * binding information would be lost when the browser removes the attribute.</span>
<span class="Comment"> * The `ngSelected` directive solves this problem for the `selected` atttribute.</span>
<span class="Comment"> * This complementary directive is not removed by the browser and so provides</span>
<span class="Comment"> * a permanent reliable place to store the binding information.</span>
<span class="Comment"> * @example</span>
<span class="Comment">    &lt;doc:example&gt;</span>
<span class="Comment">      &lt;doc:source&gt;</span>
<span class="Comment">        Check me to select: &lt;input type=&quot;checkbox&quot; ng-model=&quot;selected&quot;&gt;&lt;br/&gt;</span>
<span class="Comment">        &lt;select&gt;</span>
<span class="Comment">          &lt;option&gt;Hello!&lt;/option&gt;</span>
<span class="Comment">          &lt;option id=&quot;greet&quot; ng-selected=&quot;selected&quot;&gt;Greetings!&lt;/option&gt;</span>
<span class="Comment">        &lt;/select&gt;</span>
<span class="Comment">      &lt;/doc:source&gt;</span>
<span class="Comment">      &lt;doc:scenario&gt;</span>
<span class="Comment">        it('should select Greetings!', function() {</span>
<span class="Comment">          expect(element('.doc-example-live #greet').prop('selected')).toBeFalsy();</span>
<span class="Comment">          input('selected').check();</span>
<span class="Comment">          expect(element('.doc-example-live #greet').prop('selected')).toBeTruthy();</span>
<span class="Comment">        });</span>
<span class="Comment">      &lt;/doc:scenario&gt;</span>
<span class="Comment">    &lt;/doc:example&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element OPTION</span>
<span class="Comment"> * @param {expression} ngSelected If the {@link guide/expression expression} is truthy, </span>
<span class="Comment"> *     then special attribute &quot;selected&quot; will be set on the element</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngOpen</span>
<span class="Comment"> * @restrict A</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The HTML specification does not require browsers to preserve the values of boolean attributes</span>
<span class="Comment"> * such as open. (Their presence means true and their absence means false.)</span>
<span class="Comment"> * If we put an Angular interpolation expression into such an attribute then the</span>
<span class="Comment"> * binding information would be lost when the browser removes the attribute.</span>
<span class="Comment"> * The `ngOpen` directive solves this problem for the `open` attribute.</span>
<span class="Comment"> * This complementary directive is not removed by the browser and so provides</span>
<span class="Comment"> * a permanent reliable place to store the binding information.</span>

<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">     &lt;doc:example&gt;</span>
<span class="Comment">       &lt;doc:source&gt;</span>
<span class="Comment">         Check me check multiple: &lt;input type=&quot;checkbox&quot; ng-model=&quot;open&quot;&gt;&lt;br/&gt;</span>
<span class="Comment">         &lt;details id=&quot;details&quot; ng-open=&quot;open&quot;&gt;</span>
<span class="Comment">            &lt;summary&gt;Show/Hide me&lt;/summary&gt;</span>
<span class="Comment">         &lt;/details&gt;</span>
<span class="Comment">       &lt;/doc:source&gt;</span>
<span class="Comment">       &lt;doc:scenario&gt;</span>
<span class="Comment">         it('should toggle open', function() {</span>
<span class="Comment">           expect(element('#details').prop('open')).toBeFalsy();</span>
<span class="Comment">           input('open').check();</span>
<span class="Comment">           expect(element('#details').prop('open')).toBeTruthy();</span>
<span class="Comment">         });</span>
<span class="Comment">       &lt;/doc:scenario&gt;</span>
<span class="Comment">     &lt;/doc:example&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element DETAILS</span>
<span class="Comment"> * @param {expression} ngOpen If the {@link guide/expression expression} is truthy, </span>
<span class="Comment"> *     then special attribute &quot;open&quot; will be set on the element</span>
<span class="Comment"> */</span>

<span class="Identifier">var</span> ngAttributeAliasDirectives = <span class="Identifier">{}</span>;


<span class="Comment">// boolean attrs are evaluated</span>
forEach(BOOLEAN_ATTR, <span class="Identifier">function</span>(propName, attrName) <span class="Identifier">{</span>
  <span class="Comment">// binding to multiple is not supported</span>
  <span class="Statement">if</span> (propName == <span class="Constant">&quot;multiple&quot;</span>) <span class="Statement">return</span>;

  <span class="Identifier">var</span> normalized = directiveNormalize(<span class="Constant">'ng-'</span> + attrName);
  ngAttributeAliasDirectives<span class="Identifier">[</span>normalized<span class="Identifier">]</span> = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">{</span>
      priority: 100,
      compile: <span class="Identifier">function</span>() <span class="Identifier">{</span>
        <span class="Statement">return</span> <span class="Identifier">function</span>(scope, element, attr) <span class="Identifier">{</span>
          scope.$watch(attr<span class="Identifier">[</span>normalized<span class="Identifier">]</span>, <span class="Identifier">function</span> ngBooleanAttrWatchAction(value) <span class="Identifier">{</span>
            attr.$set(attrName, !!value);
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>);


<span class="Comment">// ng-src, ng-srcset, ng-href are interpolated</span>
forEach(<span class="Identifier">[</span><span class="Constant">'src'</span>, <span class="Constant">'srcset'</span>, <span class="Constant">'href'</span><span class="Identifier">]</span>, <span class="Identifier">function</span>(attrName) <span class="Identifier">{</span>
  <span class="Identifier">var</span> normalized = directiveNormalize(<span class="Constant">'ng-'</span> + attrName);
  ngAttributeAliasDirectives<span class="Identifier">[</span>normalized<span class="Identifier">]</span> = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">{</span>
      priority: 99, <span class="Comment">// it needs to run after the attributes are interpolated</span>
      link: <span class="Identifier">function</span>(scope, element, attr) <span class="Identifier">{</span>
        attr.$observe(normalized, <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
          <span class="Statement">if</span> (!value)
             <span class="Statement">return</span>;

          attr.$set(attrName, value);

          <span class="Comment">// on IE, if &quot;ng:src&quot; directive declaration is used and &quot;src&quot; attribute doesn't exist</span>
          <span class="Comment">// then calling element.setAttribute('src', 'foo') doesn't do anything, so we need</span>
          <span class="Comment">// to set the property as well to achieve the desired effect.</span>
          <span class="Comment">// we use attr[attrName] value since $set can sanitize the url.</span>
          <span class="Statement">if</span> (msie) element.prop(attrName, attr<span class="Identifier">[</span>attrName<span class="Identifier">]</span>);
        <span class="Identifier">}</span>);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>);

<span class="Comment">/* global -nullFormCtrl */</span>
<span class="Identifier">var</span> nullFormCtrl = <span class="Identifier">{</span>
  $addControl: noop,
  $removeControl: noop,
  $setValidity: noop,
  $setDirty: noop,
  $setPristine: noop
<span class="Identifier">}</span>;

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.directive:form.FormController</span>
<span class="Comment"> *</span>
<span class="Comment"> * @property {boolean} $pristine True if user has not interacted with the form yet.</span>
<span class="Comment"> * @property {boolean} $dirty True if user has already interacted with the form.</span>
<span class="Comment"> * @property {boolean} $valid True if all of the containing forms and controls are valid.</span>
<span class="Comment"> * @property {boolean} $invalid True if at least one containing control or form is invalid.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @property {Object} $error Is an object hash, containing references to all invalid controls or</span>
<span class="Comment"> *  forms, where:</span>
<span class="Comment"> *</span>
<span class="Comment"> *  - keys are validation tokens (error names),</span>
<span class="Comment"> *  - values are arrays of controls or forms that are invalid for given error name.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> *  Built-in validation tokens:</span>
<span class="Comment"> *</span>
<span class="Comment"> *  - `email`</span>
<span class="Comment"> *  - `max`</span>
<span class="Comment"> *  - `maxlength`</span>
<span class="Comment"> *  - `min`</span>
<span class="Comment"> *  - `minlength`</span>
<span class="Comment"> *  - `number`</span>
<span class="Comment"> *  - `pattern`</span>
<span class="Comment"> *  - `required`</span>
<span class="Comment"> *  - `url`</span>
<span class="Comment"> * </span>
<span class="Comment"> * @description</span>
<span class="Comment"> * `FormController` keeps track of all its controls and nested forms as well as state of them,</span>
<span class="Comment"> * such as being valid/invalid or dirty/pristine.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Each {@link ng.directive:form form} directive creates an instance</span>
<span class="Comment"> * of `FormController`.</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>
<span class="Comment">//asks for $scope to fool the BC controller module</span>
FormController.$inject = <span class="Identifier">[</span><span class="Constant">'$element'</span>, <span class="Constant">'$attrs'</span>, <span class="Constant">'$scope'</span><span class="Identifier">]</span>;
<span class="Identifier">function</span> FormController(element, attrs) <span class="Identifier">{</span>
  <span class="Identifier">var</span> form = <span class="Identifier">this</span>,
      parentForm = element.<span class="Statement">parent</span>().controller(<span class="Constant">'form'</span>) || nullFormCtrl,
      invalidCount = 0, <span class="Comment">// used to easily determine if we are valid</span>
      errors = form.$error = <span class="Identifier">{}</span>,
      controls = <span class="Identifier">[]</span>;

  <span class="Comment">// init state</span>
  form.$name = attrs.name || attrs.ngForm;
  form.$dirty = <span class="Constant">false</span>;
  form.$pristine = <span class="Constant">true</span>;
  form.$valid = <span class="Constant">true</span>;
  form.$invalid = <span class="Constant">false</span>;

  parentForm.$addControl(form);

  <span class="Comment">// Setup initial state of the control</span>
  element.addClass(PRISTINE_CLASS);
  toggleValidCss(<span class="Constant">true</span>);

  <span class="Comment">// convenience method for easy toggling of classes</span>
  <span class="Identifier">function</span> toggleValidCss(isValid, validationErrorKey) <span class="Identifier">{</span>
    validationErrorKey = validationErrorKey ? <span class="Constant">'-'</span> + snake_case(validationErrorKey, <span class="Constant">'-'</span>) : <span class="Constant">''</span>;
    element.
      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
  <span class="Identifier">}</span>

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.directive:form.FormController#$addControl</span>
<span class="Comment">   * @methodOf ng.directive:form.FormController</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Register a control with the form.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Input elements using ngModelController do this automatically when they are linked.</span>
<span class="Comment">   */</span>
  form.$addControl = <span class="Identifier">function</span>(control) <span class="Identifier">{</span>
    <span class="Comment">// Breaking change - before, inputs whose name was &quot;hasOwnProperty&quot; were quietly ignored</span>
    <span class="Comment">// and not added to the scope.  Now we throw an error.</span>
    assertNotHasOwnProperty(control.$name, <span class="Constant">'input'</span>);
    controls.push(control);

    <span class="Statement">if</span> (control.$name) <span class="Identifier">{</span>
      form<span class="Identifier">[</span>control.$name<span class="Identifier">]</span> = control;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.directive:form.FormController#$removeControl</span>
<span class="Comment">   * @methodOf ng.directive:form.FormController</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Deregister a control from the form.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Input elements using ngModelController do this automatically when they are destroyed.</span>
<span class="Comment">   */</span>
  form.$removeControl = <span class="Identifier">function</span>(control) <span class="Identifier">{</span>
    <span class="Statement">if</span> (control.$name &amp;&amp; form<span class="Identifier">[</span>control.$name<span class="Identifier">]</span> === control) <span class="Identifier">{</span>
      <span class="Statement">delete</span> form<span class="Identifier">[</span>control.$name<span class="Identifier">]</span>;
    <span class="Identifier">}</span>
    forEach(errors, <span class="Identifier">function</span>(queue, validationToken) <span class="Identifier">{</span>
      form.$setValidity(validationToken, <span class="Constant">true</span>, control);
    <span class="Identifier">}</span>);

    arrayRemove(controls, control);
  <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.directive:form.FormController#$setValidity</span>
<span class="Comment">   * @methodOf ng.directive:form.FormController</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Sets the validity of a form control.</span>
<span class="Comment">   *</span>
<span class="Comment">   * This method will also propagate to parent forms.</span>
<span class="Comment">   */</span>
  form.$setValidity = <span class="Identifier">function</span>(validationToken, isValid, control) <span class="Identifier">{</span>
    <span class="Identifier">var</span> queue = errors<span class="Identifier">[</span>validationToken<span class="Identifier">]</span>;

    <span class="Statement">if</span> (isValid) <span class="Identifier">{</span>
      <span class="Statement">if</span> (queue) <span class="Identifier">{</span>
        arrayRemove(queue, control);
        <span class="Statement">if</span> (!queue.length) <span class="Identifier">{</span>
          invalidCount--;
          <span class="Statement">if</span> (!invalidCount) <span class="Identifier">{</span>
            toggleValidCss(isValid);
            form.$valid = <span class="Constant">true</span>;
            form.$invalid = <span class="Constant">false</span>;
          <span class="Identifier">}</span>
          errors<span class="Identifier">[</span>validationToken<span class="Identifier">]</span> = <span class="Constant">false</span>;
          toggleValidCss(<span class="Constant">true</span>, validationToken);
          parentForm.$setValidity(validationToken, <span class="Constant">true</span>, form);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>

    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      <span class="Statement">if</span> (!invalidCount) <span class="Identifier">{</span>
        toggleValidCss(isValid);
      <span class="Identifier">}</span>
      <span class="Statement">if</span> (queue) <span class="Identifier">{</span>
        <span class="Statement">if</span> (includes(queue, control)) <span class="Statement">return</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        errors<span class="Identifier">[</span>validationToken<span class="Identifier">]</span> = queue = <span class="Identifier">[]</span>;
        invalidCount++;
        toggleValidCss(<span class="Constant">false</span>, validationToken);
        parentForm.$setValidity(validationToken, <span class="Constant">false</span>, form);
      <span class="Identifier">}</span>
      queue.push(control);

      form.$valid = <span class="Constant">false</span>;
      form.$invalid = <span class="Constant">true</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.directive:form.FormController#$setDirty</span>
<span class="Comment">   * @methodOf ng.directive:form.FormController</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Sets the form to a dirty state.</span>
<span class="Comment">   *</span>
<span class="Comment">   * This method can be called to add the 'ng-dirty' class and set the form to a dirty</span>
<span class="Comment">   * state (ng-dirty class). This method will also propagate to parent forms.</span>
<span class="Comment">   */</span>
  form.$setDirty = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
    form.$dirty = <span class="Constant">true</span>;
    form.$pristine = <span class="Constant">false</span>;
    parentForm.$setDirty();
  <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.directive:form.FormController#$setPristine</span>
<span class="Comment">   * @methodOf ng.directive:form.FormController</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Sets the form to its pristine state.</span>
<span class="Comment">   *</span>
<span class="Comment">   * This method can be called to remove the 'ng-dirty' class and set the form to its pristine</span>
<span class="Comment">   * state (ng-pristine class). This method will also propagate to all the controls contained</span>
<span class="Comment">   * in this form.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Setting a form back to a pristine state is often useful when we want to 'reuse' a form after</span>
<span class="Comment">   * saving or resetting it.</span>
<span class="Comment">   */</span>
  form.$setPristine = <span class="Identifier">function</span> () <span class="Identifier">{</span>
    element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);
    form.$dirty = <span class="Constant">false</span>;
    form.$pristine = <span class="Constant">true</span>;
    forEach(controls, <span class="Identifier">function</span>(control) <span class="Identifier">{</span>
      control.$setPristine();
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngForm</span>
<span class="Comment"> * @restrict EAC</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Nestable alias of {@link ng.directive:form `form`} directive. HTML</span>
<span class="Comment"> * does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a</span>
<span class="Comment"> * sub-group of controls needs to be determined.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string=} ngForm|name Name of the form. If specified, the form controller will be published into</span>
<span class="Comment"> *                       related scope, under this name.</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>

 <span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:form</span>
<span class="Comment"> * @restrict E</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Directive that instantiates</span>
<span class="Comment"> * {@link ng.directive:form.FormController FormController}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * If the `name` attribute is specified, the form controller is published onto the current scope under</span>
<span class="Comment"> * this name.</span>
<span class="Comment"> *</span>
<span class="Comment"> * # Alias: {@link ng.directive:ngForm `ngForm`}</span>
<span class="Comment"> *</span>
<span class="Comment"> * In Angular forms can be nested. This means that the outer form is valid when all of the child</span>
<span class="Comment"> * forms are valid as well. However, browsers do not allow nesting of `&lt;form&gt;` elements, so</span>
<span class="Comment"> * Angular provides the {@link ng.directive:ngForm `ngForm`} directive which behaves identically to</span>
<span class="Comment"> * `&lt;form&gt;` but can be nested.  This allows you to have nested forms, which is very useful when</span>
<span class="Comment"> * using Angular validation directives in forms that are dynamically generated using the</span>
<span class="Comment"> * {@link ng.directive:ngRepeat `ngRepeat`} directive. Since you cannot dynamically generate the `name`</span>
<span class="Comment"> * attribute of input elements using interpolation, you have to wrap each set of repeated inputs in an</span>
<span class="Comment"> * `ngForm` directive and nest these in an outer `form` element.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * # CSS classes</span>
<span class="Comment"> *  - `ng-valid` Is set if the form is valid.</span>
<span class="Comment"> *  - `ng-invalid` Is set if the form is invalid.</span>
<span class="Comment"> *  - `ng-pristine` Is set if the form is pristine.</span>
<span class="Comment"> *  - `ng-dirty` Is set if the form is dirty.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * # Submitting a form and preventing the default action</span>
<span class="Comment"> *</span>
<span class="Comment"> * Since the role of forms in client-side Angular applications is different than in classical</span>
<span class="Comment"> * roundtrip apps, it is desirable for the browser not to translate the form submission into a full</span>
<span class="Comment"> * page reload that sends the data to the server. Instead some javascript logic should be triggered</span>
<span class="Comment"> * to handle the form submission in an application-specific way.</span>
<span class="Comment"> *</span>
<span class="Comment"> * For this reason, Angular prevents the default action (form submission to the server) unless the</span>
<span class="Comment"> * `&lt;form&gt;` element has an `action` attribute specified.</span>
<span class="Comment"> *</span>
<span class="Comment"> * You can use one of the following two ways to specify what javascript method should be called when</span>
<span class="Comment"> * a form is submitted:</span>
<span class="Comment"> *</span>
<span class="Comment"> * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element</span>
<span class="Comment"> * - {@link ng.directive:ngClick ngClick} directive on the first</span>
<span class="Comment">  *  button or input field of type submit (input[type=submit])</span>
<span class="Comment"> *</span>
<span class="Comment"> * To prevent double execution of the handler, use only one of the {@link ng.directive:ngSubmit ngSubmit}</span>
<span class="Comment"> * or {@link ng.directive:ngClick ngClick} directives.</span>
<span class="Comment"> * This is because of the following form submission rules in the HTML specification:</span>
<span class="Comment"> *</span>
<span class="Comment"> * - If a form has only one input field then hitting enter in this field triggers form submit</span>
<span class="Comment"> * (`ngSubmit`)</span>
<span class="Comment"> * - if a form has 2+ input fields and no buttons or input[type=submit] then hitting enter</span>
<span class="Comment"> * doesn't trigger submit</span>
<span class="Comment"> * - if a form has one or more input fields and one or more buttons or input[type=submit] then</span>
<span class="Comment"> * hitting enter in any of the input fields will trigger the click handler on the *first* button or</span>
<span class="Comment"> * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string=} name Name of the form. If specified, the form controller will be published into</span>
<span class="Comment"> *                       related scope, under this name.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">    &lt;doc:example&gt;</span>
<span class="Comment">      &lt;doc:source&gt;</span>
<span class="Comment">       &lt;script&gt;</span>
<span class="Comment">         function Ctrl($scope) {</span>
<span class="Comment">           $scope.userType = 'guest';</span>
<span class="Comment">         }</span>
<span class="Comment">       &lt;/script&gt;</span>
<span class="Comment">       &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">         userType: &lt;input name=&quot;input&quot; ng-model=&quot;userType&quot; required&gt;</span>
<span class="Comment">         &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.required&quot;&gt;Required!&lt;/span&gt;&lt;br&gt;</span>
<span class="Comment">         &lt;tt&gt;userType = {{userType}}&lt;/tt&gt;&lt;br&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br&gt;</span>
<span class="Comment">        &lt;/form&gt;</span>
<span class="Comment">      &lt;/doc:source&gt;</span>
<span class="Comment">      &lt;doc:scenario&gt;</span>
<span class="Comment">        it('should initialize to model', function() {</span>
<span class="Comment">         expect(binding('userType')).toEqual('guest');</span>
<span class="Comment">         expect(binding('myForm.input.$valid')).toEqual('true');</span>
<span class="Comment">        });</span>

<span class="Comment">        it('should be invalid if empty', function() {</span>
<span class="Comment">         input('userType').enter('');</span>
<span class="Comment">         expect(binding('userType')).toEqual('');</span>
<span class="Comment">         expect(binding('myForm.input.$valid')).toEqual('false');</span>
<span class="Comment">        });</span>
<span class="Comment">      &lt;/doc:scenario&gt;</span>
<span class="Comment">    &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> formDirectiveFactory = <span class="Identifier">function</span>(isNgForm) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">[</span><span class="Constant">'$timeout'</span>, <span class="Identifier">function</span>($timeout) <span class="Identifier">{</span>
    <span class="Identifier">var</span> formDirective = <span class="Identifier">{</span>
      name: <span class="Constant">'form'</span>,
      restrict: isNgForm ? <span class="Constant">'EAC'</span> : <span class="Constant">'E'</span>,
      controller: FormController,
      compile: <span class="Identifier">function</span>() <span class="Identifier">{</span>
        <span class="Statement">return</span> <span class="Identifier">{</span>
          pre: <span class="Identifier">function</span>(scope, formElement, attr, controller) <span class="Identifier">{</span>
            <span class="Statement">if</span> (!attr.action) <span class="Identifier">{</span>
              <span class="Comment">// we can't use jq events because if a form is destroyed during submission the default</span>
              <span class="Comment">// action is not prevented. see #1238</span>
              <span class="Comment">//</span>
              <span class="Comment">// IE 9 is not affected because it doesn't fire a submit event and try to do a full</span>
              <span class="Comment">// page reload if the form was destroyed by submission of the form via a click handler</span>
              <span class="Comment">// on a button in the form. Looks like an IE9 specific bug.</span>
              <span class="Identifier">var</span> preventDefaultListener = <span class="Identifier">function</span>(<span class="Statement">event</span>) <span class="Identifier">{</span>
                <span class="Statement">event</span>.preventDefault
                  ? <span class="Statement">event</span>.preventDefault()
                  : <span class="Statement">event</span>.returnValue = <span class="Constant">false</span>; <span class="Comment">// IE</span>
              <span class="Identifier">}</span>;

              addEventListenerFn(formElement<span class="Identifier">[</span>0<span class="Identifier">]</span>, <span class="Constant">'submit'</span>, preventDefaultListener);

              <span class="Comment">// unregister the preventDefault listener so that we don't not leak memory but in a</span>
              <span class="Comment">// way that will achieve the prevention of the default action.</span>
              formElement.on(<span class="Constant">'$destroy'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
                $timeout(<span class="Identifier">function</span>() <span class="Identifier">{</span>
                  removeEventListenerFn(formElement<span class="Identifier">[</span>0<span class="Identifier">]</span>, <span class="Constant">'submit'</span>, preventDefaultListener);
                <span class="Identifier">}</span>, 0, <span class="Constant">false</span>);
              <span class="Identifier">}</span>);
            <span class="Identifier">}</span>

            <span class="Identifier">var</span> parentFormCtrl = formElement.<span class="Statement">parent</span>().controller(<span class="Constant">'form'</span>),
                alias = attr.name || attr.ngForm;

            <span class="Statement">if</span> (alias) <span class="Identifier">{</span>
              setter(scope, alias, controller, alias);
            <span class="Identifier">}</span>
            <span class="Statement">if</span> (parentFormCtrl) <span class="Identifier">{</span>
              formElement.on(<span class="Constant">'$destroy'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
                parentFormCtrl.$removeControl(controller);
                <span class="Statement">if</span> (alias) <span class="Identifier">{</span>
                  setter(scope, alias, <span class="Statement">undefined</span>, alias);
                <span class="Identifier">}</span>
                extend(controller, nullFormCtrl); <span class="Comment">//stop propagating child destruction handlers upwards</span>
              <span class="Identifier">}</span>);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;

    <span class="Statement">return</span> formDirective;
  <span class="Identifier">}]</span>;
<span class="Identifier">}</span>;

<span class="Identifier">var</span> formDirective = formDirectiveFactory();
<span class="Identifier">var</span> ngFormDirective = formDirectiveFactory(<span class="Constant">true</span>);

<span class="Comment">/* global</span>

<span class="Comment">    -VALID_CLASS,</span>
<span class="Comment">    -INVALID_CLASS,</span>
<span class="Comment">    -PRISTINE_CLASS,</span>
<span class="Comment">    -DIRTY_CLASS</span>
<span class="Comment">*/</span>

<span class="Identifier">var</span> URL_REGEXP = <span class="Constant">/^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&amp;%@!\-\/]))?$/</span>;
<span class="Identifier">var</span> EMAIL_REGEXP = <span class="Constant">/^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}$/</span>;
<span class="Identifier">var</span> NUMBER_REGEXP = <span class="Constant">/^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/</span>;

<span class="Identifier">var</span> inputType = <span class="Identifier">{</span>

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc inputType</span>
<span class="Comment">   * @name ng.directive:input.text</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Standard HTML text input with angular data binding.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string} ngModel Assignable angular expression to data-bind to.</span>
<span class="Comment">   * @param {string=} name Property name of the form under which the control is published.</span>
<span class="Comment">   * @param {string=} required Adds `required` validation error key if the value is not entered.</span>
<span class="Comment">   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to</span>
<span class="Comment">   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of</span>
<span class="Comment">   *    `required` when you want to data-bind to the `required` attribute.</span>
<span class="Comment">   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than</span>
<span class="Comment">   *    minlength.</span>
<span class="Comment">   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than</span>
<span class="Comment">   *    maxlength.</span>
<span class="Comment">   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the</span>
<span class="Comment">   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for</span>
<span class="Comment">   *    patterns defined as scope expressions.</span>
<span class="Comment">   * @param {string=} ngChange Angular expression to be executed when input changes due to user</span>
<span class="Comment">   *    interaction with the input element.</span>
<span class="Comment">   * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trim the input.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @example</span>
<span class="Comment">      &lt;doc:example&gt;</span>
<span class="Comment">        &lt;doc:source&gt;</span>
<span class="Comment">         &lt;script&gt;</span>
<span class="Comment">           function Ctrl($scope) {</span>
<span class="Comment">             $scope.text = 'guest';</span>
<span class="Comment">             $scope.word = /^\s*\w*\s*$/;</span>
<span class="Comment">           }</span>
<span class="Comment">         &lt;/script&gt;</span>
<span class="Comment">         &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">           Single word: &lt;input type=&quot;text&quot; name=&quot;input&quot; ng-model=&quot;text&quot;</span>
<span class="Comment">                               ng-pattern=&quot;word&quot; required ng-trim=&quot;false&quot;&gt;</span>
<span class="Comment">           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.required&quot;&gt;</span>
<span class="Comment">             Required!&lt;/span&gt;</span>
<span class="Comment">           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.pattern&quot;&gt;</span>
<span class="Comment">             Single word only!&lt;/span&gt;</span>

<span class="Comment">           &lt;tt&gt;text = {{text}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">          &lt;/form&gt;</span>
<span class="Comment">        &lt;/doc:source&gt;</span>
<span class="Comment">        &lt;doc:scenario&gt;</span>
<span class="Comment">          it('should initialize to model', function() {</span>
<span class="Comment">            expect(binding('text')).toEqual('guest');</span>
<span class="Comment">            expect(binding('myForm.input.$valid')).toEqual('true');</span>
<span class="Comment">          });</span>

<span class="Comment">          it('should be invalid if empty', function() {</span>
<span class="Comment">            input('text').enter('');</span>
<span class="Comment">            expect(binding('text')).toEqual('');</span>
<span class="Comment">            expect(binding('myForm.input.$valid')).toEqual('false');</span>
<span class="Comment">          });</span>

<span class="Comment">          it('should be invalid if multi word', function() {</span>
<span class="Comment">            input('text').enter('hello world');</span>
<span class="Comment">            expect(binding('myForm.input.$valid')).toEqual('false');</span>
<span class="Comment">          });</span>

<span class="Comment">          it('should not be trimmed', function() {</span>
<span class="Comment">            input('text').enter('untrimmed ');</span>
<span class="Comment">            expect(binding('text')).toEqual('untrimmed ');</span>
<span class="Comment">            expect(binding('myForm.input.$valid')).toEqual('true');</span>
<span class="Comment">          });</span>
<span class="Comment">        &lt;/doc:scenario&gt;</span>
<span class="Comment">      &lt;/doc:example&gt;</span>
<span class="Comment">   */</span>
  <span class="Constant">'text'</span>: textInputType,


  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc inputType</span>
<span class="Comment">   * @name ng.directive:input.number</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Text input with number validation and transformation. Sets the `number` validation</span>
<span class="Comment">   * error if not a valid number.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string} ngModel Assignable angular expression to data-bind to.</span>
<span class="Comment">   * @param {string=} name Property name of the form under which the control is published.</span>
<span class="Comment">   * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.</span>
<span class="Comment">   * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.</span>
<span class="Comment">   * @param {string=} required Sets `required` validation error key if the value is not entered.</span>
<span class="Comment">   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to</span>
<span class="Comment">   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of</span>
<span class="Comment">   *    `required` when you want to data-bind to the `required` attribute.</span>
<span class="Comment">   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than</span>
<span class="Comment">   *    minlength.</span>
<span class="Comment">   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than</span>
<span class="Comment">   *    maxlength.</span>
<span class="Comment">   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the</span>
<span class="Comment">   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for</span>
<span class="Comment">   *    patterns defined as scope expressions.</span>
<span class="Comment">   * @param {string=} ngChange Angular expression to be executed when input changes due to user</span>
<span class="Comment">   *    interaction with the input element.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @example</span>
<span class="Comment">      &lt;doc:example&gt;</span>
<span class="Comment">        &lt;doc:source&gt;</span>
<span class="Comment">         &lt;script&gt;</span>
<span class="Comment">           function Ctrl($scope) {</span>
<span class="Comment">             $scope.value = 12;</span>
<span class="Comment">           }</span>
<span class="Comment">         &lt;/script&gt;</span>
<span class="Comment">         &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">           Number: &lt;input type=&quot;number&quot; name=&quot;input&quot; ng-model=&quot;value&quot;</span>
<span class="Comment">                          min=&quot;0&quot; max=&quot;99&quot; required&gt;</span>
<span class="Comment">           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.required&quot;&gt;</span>
<span class="Comment">             Required!&lt;/span&gt;</span>
<span class="Comment">           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.number&quot;&gt;</span>
<span class="Comment">             Not valid number!&lt;/span&gt;</span>
<span class="Comment">           &lt;tt&gt;value = {{value}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">          &lt;/form&gt;</span>
<span class="Comment">        &lt;/doc:source&gt;</span>
<span class="Comment">        &lt;doc:scenario&gt;</span>
<span class="Comment">          it('should initialize to model', function() {</span>
<span class="Comment">           expect(binding('value')).toEqual('12');</span>
<span class="Comment">           expect(binding('myForm.input.$valid')).toEqual('true');</span>
<span class="Comment">          });</span>

<span class="Comment">          it('should be invalid if empty', function() {</span>
<span class="Comment">           input('value').enter('');</span>
<span class="Comment">           expect(binding('value')).toEqual('');</span>
<span class="Comment">           expect(binding('myForm.input.$valid')).toEqual('false');</span>
<span class="Comment">          });</span>

<span class="Comment">          it('should be invalid if over max', function() {</span>
<span class="Comment">           input('value').enter('123');</span>
<span class="Comment">           expect(binding('value')).toEqual('');</span>
<span class="Comment">           expect(binding('myForm.input.$valid')).toEqual('false');</span>
<span class="Comment">          });</span>
<span class="Comment">        &lt;/doc:scenario&gt;</span>
<span class="Comment">      &lt;/doc:example&gt;</span>
<span class="Comment">   */</span>
  <span class="Constant">'number'</span>: numberInputType,


  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc inputType</span>
<span class="Comment">   * @name ng.directive:input.url</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Text input with URL validation. Sets the `url` validation error key if the content is not a</span>
<span class="Comment">   * valid URL.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string} ngModel Assignable angular expression to data-bind to.</span>
<span class="Comment">   * @param {string=} name Property name of the form under which the control is published.</span>
<span class="Comment">   * @param {string=} required Sets `required` validation error key if the value is not entered.</span>
<span class="Comment">   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to</span>
<span class="Comment">   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of</span>
<span class="Comment">   *    `required` when you want to data-bind to the `required` attribute.</span>
<span class="Comment">   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than</span>
<span class="Comment">   *    minlength.</span>
<span class="Comment">   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than</span>
<span class="Comment">   *    maxlength.</span>
<span class="Comment">   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the</span>
<span class="Comment">   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for</span>
<span class="Comment">   *    patterns defined as scope expressions.</span>
<span class="Comment">   * @param {string=} ngChange Angular expression to be executed when input changes due to user</span>
<span class="Comment">   *    interaction with the input element.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @example</span>
<span class="Comment">      &lt;doc:example&gt;</span>
<span class="Comment">        &lt;doc:source&gt;</span>
<span class="Comment">         &lt;script&gt;</span>
<span class="Comment">           function Ctrl($scope) {</span>
<span class="Comment">             $scope.text = '<a href="http://google.com">http://google.com</a>';</span>
<span class="Comment">           }</span>
<span class="Comment">         &lt;/script&gt;</span>
<span class="Comment">         &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">           URL: &lt;input type=&quot;url&quot; name=&quot;input&quot; ng-model=&quot;text&quot; required&gt;</span>
<span class="Comment">           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.required&quot;&gt;</span>
<span class="Comment">             Required!&lt;/span&gt;</span>
<span class="Comment">           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.url&quot;&gt;</span>
<span class="Comment">             Not valid url!&lt;/span&gt;</span>
<span class="Comment">           &lt;tt&gt;text = {{text}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;myForm.$error.url = {{!!myForm.$error.url}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">          &lt;/form&gt;</span>
<span class="Comment">        &lt;/doc:source&gt;</span>
<span class="Comment">        &lt;doc:scenario&gt;</span>
<span class="Comment">          it('should initialize to model', function() {</span>
<span class="Comment">            expect(binding('text')).toEqual('<a href="http://google.com">http://google.com</a>');</span>
<span class="Comment">            expect(binding('myForm.input.$valid')).toEqual('true');</span>
<span class="Comment">          });</span>

<span class="Comment">          it('should be invalid if empty', function() {</span>
<span class="Comment">            input('text').enter('');</span>
<span class="Comment">            expect(binding('text')).toEqual('');</span>
<span class="Comment">            expect(binding('myForm.input.$valid')).toEqual('false');</span>
<span class="Comment">          });</span>

<span class="Comment">          it('should be invalid if not url', function() {</span>
<span class="Comment">            input('text').enter('xxx');</span>
<span class="Comment">            expect(binding('myForm.input.$valid')).toEqual('false');</span>
<span class="Comment">          });</span>
<span class="Comment">        &lt;/doc:scenario&gt;</span>
<span class="Comment">      &lt;/doc:example&gt;</span>
<span class="Comment">   */</span>
  <span class="Constant">'url'</span>: urlInputType,


  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc inputType</span>
<span class="Comment">   * @name ng.directive:input.email</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Text input with email validation. Sets the `email` validation error key if not a valid email</span>
<span class="Comment">   * address.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string} ngModel Assignable angular expression to data-bind to.</span>
<span class="Comment">   * @param {string=} name Property name of the form under which the control is published.</span>
<span class="Comment">   * @param {string=} required Sets `required` validation error key if the value is not entered.</span>
<span class="Comment">   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to</span>
<span class="Comment">   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of</span>
<span class="Comment">   *    `required` when you want to data-bind to the `required` attribute.</span>
<span class="Comment">   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than</span>
<span class="Comment">   *    minlength.</span>
<span class="Comment">   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than</span>
<span class="Comment">   *    maxlength.</span>
<span class="Comment">   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the</span>
<span class="Comment">   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for</span>
<span class="Comment">   *    patterns defined as scope expressions.</span>
<span class="Comment">   * @param {string=} ngChange Angular expression to be executed when input changes due to user</span>
<span class="Comment">   *    interaction with the input element.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @example</span>
<span class="Comment">      &lt;doc:example&gt;</span>
<span class="Comment">        &lt;doc:source&gt;</span>
<span class="Comment">         &lt;script&gt;</span>
<span class="Comment">           function Ctrl($scope) {</span>
<span class="Comment">             $scope.text = 'me@example.com';</span>
<span class="Comment">           }</span>
<span class="Comment">         &lt;/script&gt;</span>
<span class="Comment">           &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">             Email: &lt;input type=&quot;email&quot; name=&quot;input&quot; ng-model=&quot;text&quot; required&gt;</span>
<span class="Comment">             &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.required&quot;&gt;</span>
<span class="Comment">               Required!&lt;/span&gt;</span>
<span class="Comment">             &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.email&quot;&gt;</span>
<span class="Comment">               Not valid email!&lt;/span&gt;</span>
<span class="Comment">             &lt;tt&gt;text = {{text}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">             &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">             &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">             &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">             &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">             &lt;tt&gt;myForm.$error.email = {{!!myForm.$error.email}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;/form&gt;</span>
<span class="Comment">        &lt;/doc:source&gt;</span>
<span class="Comment">        &lt;doc:scenario&gt;</span>
<span class="Comment">          it('should initialize to model', function() {</span>
<span class="Comment">            expect(binding('text')).toEqual('me@example.com');</span>
<span class="Comment">            expect(binding('myForm.input.$valid')).toEqual('true');</span>
<span class="Comment">          });</span>

<span class="Comment">          it('should be invalid if empty', function() {</span>
<span class="Comment">            input('text').enter('');</span>
<span class="Comment">            expect(binding('text')).toEqual('');</span>
<span class="Comment">            expect(binding('myForm.input.$valid')).toEqual('false');</span>
<span class="Comment">          });</span>

<span class="Comment">          it('should be invalid if not email', function() {</span>
<span class="Comment">            input('text').enter('xxx');</span>
<span class="Comment">            expect(binding('myForm.input.$valid')).toEqual('false');</span>
<span class="Comment">          });</span>
<span class="Comment">        &lt;/doc:scenario&gt;</span>
<span class="Comment">      &lt;/doc:example&gt;</span>
<span class="Comment">   */</span>
  <span class="Constant">'email'</span>: emailInputType,


  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc inputType</span>
<span class="Comment">   * @name ng.directive:input.radio</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * HTML radio button.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string} ngModel Assignable angular expression to data-bind to.</span>
<span class="Comment">   * @param {string} value The value to which the expression should be set when selected.</span>
<span class="Comment">   * @param {string=} name Property name of the form under which the control is published.</span>
<span class="Comment">   * @param {string=} ngChange Angular expression to be executed when input changes due to user</span>
<span class="Comment">   *    interaction with the input element.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @example</span>
<span class="Comment">      &lt;doc:example&gt;</span>
<span class="Comment">        &lt;doc:source&gt;</span>
<span class="Comment">         &lt;script&gt;</span>
<span class="Comment">           function Ctrl($scope) {</span>
<span class="Comment">             $scope.color = 'blue';</span>
<span class="Comment">           }</span>
<span class="Comment">         &lt;/script&gt;</span>
<span class="Comment">         &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">           &lt;input type=&quot;radio&quot; ng-model=&quot;color&quot; value=&quot;red&quot;&gt;  Red &lt;br/&gt;</span>
<span class="Comment">           &lt;input type=&quot;radio&quot; ng-model=&quot;color&quot; value=&quot;green&quot;&gt; Green &lt;br/&gt;</span>
<span class="Comment">           &lt;input type=&quot;radio&quot; ng-model=&quot;color&quot; value=&quot;blue&quot;&gt; Blue &lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;color = {{color}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">          &lt;/form&gt;</span>
<span class="Comment">        &lt;/doc:source&gt;</span>
<span class="Comment">        &lt;doc:scenario&gt;</span>
<span class="Comment">          it('should change state', function() {</span>
<span class="Comment">            expect(binding('color')).toEqual('blue');</span>

<span class="Comment">            input('color').select('red');</span>
<span class="Comment">            expect(binding('color')).toEqual('red');</span>
<span class="Comment">          });</span>
<span class="Comment">        &lt;/doc:scenario&gt;</span>
<span class="Comment">      &lt;/doc:example&gt;</span>
<span class="Comment">   */</span>
  <span class="Constant">'radio'</span>: radioInputType,


  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc inputType</span>
<span class="Comment">   * @name ng.directive:input.checkbox</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * HTML checkbox.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string} ngModel Assignable angular expression to data-bind to.</span>
<span class="Comment">   * @param {string=} name Property name of the form under which the control is published.</span>
<span class="Comment">   * @param {string=} ngTrueValue The value to which the expression should be set when selected.</span>
<span class="Comment">   * @param {string=} ngFalseValue The value to which the expression should be set when not selected.</span>
<span class="Comment">   * @param {string=} ngChange Angular expression to be executed when input changes due to user</span>
<span class="Comment">   *    interaction with the input element.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @example</span>
<span class="Comment">      &lt;doc:example&gt;</span>
<span class="Comment">        &lt;doc:source&gt;</span>
<span class="Comment">         &lt;script&gt;</span>
<span class="Comment">           function Ctrl($scope) {</span>
<span class="Comment">             $scope.value1 = true;</span>
<span class="Comment">             $scope.value2 = 'YES'</span>
<span class="Comment">           }</span>
<span class="Comment">         &lt;/script&gt;</span>
<span class="Comment">         &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">           Value1: &lt;input type=&quot;checkbox&quot; ng-model=&quot;value1&quot;&gt; &lt;br/&gt;</span>
<span class="Comment">           Value2: &lt;input type=&quot;checkbox&quot; ng-model=&quot;value2&quot;</span>
<span class="Comment">                          ng-true-value=&quot;YES&quot; ng-false-value=&quot;NO&quot;&gt; &lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;value1 = {{value1}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">           &lt;tt&gt;value2 = {{value2}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">          &lt;/form&gt;</span>
<span class="Comment">        &lt;/doc:source&gt;</span>
<span class="Comment">        &lt;doc:scenario&gt;</span>
<span class="Comment">          it('should change state', function() {</span>
<span class="Comment">            expect(binding('value1')).toEqual('true');</span>
<span class="Comment">            expect(binding('value2')).toEqual('YES');</span>

<span class="Comment">            input('value1').check();</span>
<span class="Comment">            input('value2').check();</span>
<span class="Comment">            expect(binding('value1')).toEqual('false');</span>
<span class="Comment">            expect(binding('value2')).toEqual('NO');</span>
<span class="Comment">          });</span>
<span class="Comment">        &lt;/doc:scenario&gt;</span>
<span class="Comment">      &lt;/doc:example&gt;</span>
<span class="Comment">   */</span>
  <span class="Constant">'checkbox'</span>: checkboxInputType,

  <span class="Constant">'hidden'</span>: noop,
  <span class="Constant">'button'</span>: noop,
  <span class="Constant">'submit'</span>: noop,
  <span class="Constant">'reset'</span>: noop
<span class="Identifier">}</span>;


<span class="Identifier">function</span> textInputType(scope, element, attr, ctrl, $sniffer, $browser) <span class="Identifier">{</span>
  <span class="Comment">// In composition mode, users are still inputing intermediate text buffer,</span>
  <span class="Comment">// hold the listener until composition is done.</span>
  <span class="Comment">// More about composition events: <a href="https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent">https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent</a></span>
  <span class="Identifier">var</span> composing = <span class="Constant">false</span>;

  element.on(<span class="Constant">'compositionstart'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
    composing = <span class="Constant">true</span>;
  <span class="Identifier">}</span>);

  element.on(<span class="Constant">'compositionend'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
    composing = <span class="Constant">false</span>;
  <span class="Identifier">}</span>);

  <span class="Identifier">var</span> listener = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Statement">if</span> (composing) <span class="Statement">return</span>;
    <span class="Identifier">var</span> value = element.val();

    <span class="Comment">// By default we will trim the value</span>
    <span class="Comment">// If the attribute ng-trim exists we will avoid trimming</span>
    <span class="Comment">// e.g. &lt;input ng-model=&quot;foo&quot; ng-trim=&quot;false&quot;&gt;</span>
    <span class="Statement">if</span> (toBoolean(attr.ngTrim || <span class="Constant">'T'</span>)) <span class="Identifier">{</span>
      value = trim(value);
    <span class="Identifier">}</span>

    <span class="Statement">if</span> (ctrl.$viewValue !== value) <span class="Identifier">{</span>
      scope.$apply(<span class="Identifier">function</span>() <span class="Identifier">{</span>
        ctrl.$setViewValue(value);
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Comment">// if the browser does support &quot;input&quot; event, we are fine - except on IE9 which doesn't fire the</span>
  <span class="Comment">// input event on backspace, delete or cut</span>
  <span class="Statement">if</span> ($sniffer.hasEvent(<span class="Constant">'input'</span>)) <span class="Identifier">{</span>
    element.on(<span class="Constant">'input'</span>, listener);
  <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
    <span class="Identifier">var</span> timeout;

    <span class="Identifier">var</span> deferListener = <span class="Identifier">function</span>() <span class="Identifier">{</span>
      <span class="Statement">if</span> (!timeout) <span class="Identifier">{</span>
        timeout = $browser.defer(<span class="Identifier">function</span>() <span class="Identifier">{</span>
          listener();
          timeout = <span class="Statement">null</span>;
        <span class="Identifier">}</span>);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;

    element.on(<span class="Constant">'keydown'</span>, <span class="Identifier">function</span>(<span class="Statement">event</span>) <span class="Identifier">{</span>
      <span class="Identifier">var</span> key = <span class="Statement">event</span>.keyCode;

      <span class="Comment">// ignore</span>
      <span class="Comment">//    command            modifiers                   arrows</span>
      <span class="Statement">if</span> (key === 91 || (15 &lt; key &amp;&amp; key &lt; 19) || (37 &lt;= key &amp;&amp; key &lt;= 40)) <span class="Statement">return</span>;

      deferListener();
    <span class="Identifier">}</span>);

    <span class="Comment">// if user modifies input value using context menu in IE, we need &quot;paste&quot; and &quot;cut&quot; events to catch it</span>
    <span class="Statement">if</span> ($sniffer.hasEvent(<span class="Constant">'paste'</span>)) <span class="Identifier">{</span>
      element.on(<span class="Constant">'paste cut'</span>, deferListener);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>

  <span class="Comment">// if user paste into input using mouse on older browser</span>
  <span class="Comment">// or form autocomplete on newer browser, we need &quot;change&quot; event to catch it</span>
  element.on(<span class="Constant">'change'</span>, listener);

  ctrl.$render = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    element.val(ctrl.$isEmpty(ctrl.$viewValue) ? <span class="Constant">''</span> : ctrl.$viewValue);
  <span class="Identifier">}</span>;

  <span class="Comment">// pattern validator</span>
  <span class="Identifier">var</span> pattern = attr.ngPattern,
      patternValidator,
      match;

  <span class="Identifier">var</span> validate = <span class="Identifier">function</span>(regexp, value) <span class="Identifier">{</span>
    <span class="Statement">if</span> (ctrl.$isEmpty(value) || regexp.test(value)) <span class="Identifier">{</span>
      ctrl.$setValidity(<span class="Constant">'pattern'</span>, <span class="Constant">true</span>);
      <span class="Statement">return</span> value;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      ctrl.$setValidity(<span class="Constant">'pattern'</span>, <span class="Constant">false</span>);
      <span class="Statement">return</span> <span class="Statement">undefined</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Statement">if</span> (pattern) <span class="Identifier">{</span>
    match = pattern.match(<span class="Constant">/^\/(.*)\/([gim]*)$/</span>);
    <span class="Statement">if</span> (match) <span class="Identifier">{</span>
      pattern = <span class="Statement">new</span> <span class="Type">RegExp</span>(match<span class="Identifier">[</span>1<span class="Identifier">]</span>, match<span class="Identifier">[</span>2<span class="Identifier">]</span>);
      patternValidator = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
        <span class="Statement">return</span> validate(pattern, value);
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      patternValidator = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
        <span class="Identifier">var</span> patternObj = scope.$eval(pattern);

        <span class="Statement">if</span> (!patternObj || !patternObj.test) <span class="Identifier">{</span>
          <span class="Statement">throw</span> minErr(<span class="Constant">'ngPattern'</span>)(<span class="Constant">'noregexp'</span>,
            <span class="Constant">'Expected {0} to be a RegExp but was {1}. Element: {2}'</span>, pattern,
            patternObj, startingTag(element));
        <span class="Identifier">}</span>
        <span class="Statement">return</span> validate(patternObj, value);
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>

    ctrl.$formatters.push(patternValidator);
    ctrl.$parsers.push(patternValidator);
  <span class="Identifier">}</span>

  <span class="Comment">// min length validator</span>
  <span class="Statement">if</span> (attr.ngMinlength) <span class="Identifier">{</span>
    <span class="Identifier">var</span> minlength = <span class="Statement">int</span>(attr.ngMinlength);
    <span class="Identifier">var</span> minLengthValidator = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
      <span class="Statement">if</span> (!ctrl.$isEmpty(value) &amp;&amp; value.length &lt; minlength) <span class="Identifier">{</span>
        ctrl.$setValidity(<span class="Constant">'minlength'</span>, <span class="Constant">false</span>);
        <span class="Statement">return</span> <span class="Statement">undefined</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        ctrl.$setValidity(<span class="Constant">'minlength'</span>, <span class="Constant">true</span>);
        <span class="Statement">return</span> value;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;

    ctrl.$parsers.push(minLengthValidator);
    ctrl.$formatters.push(minLengthValidator);
  <span class="Identifier">}</span>

  <span class="Comment">// max length validator</span>
  <span class="Statement">if</span> (attr.ngMaxlength) <span class="Identifier">{</span>
    <span class="Identifier">var</span> maxlength = <span class="Statement">int</span>(attr.ngMaxlength);
    <span class="Identifier">var</span> maxLengthValidator = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
      <span class="Statement">if</span> (!ctrl.$isEmpty(value) &amp;&amp; value.length &gt; maxlength) <span class="Identifier">{</span>
        ctrl.$setValidity(<span class="Constant">'maxlength'</span>, <span class="Constant">false</span>);
        <span class="Statement">return</span> <span class="Statement">undefined</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        ctrl.$setValidity(<span class="Constant">'maxlength'</span>, <span class="Constant">true</span>);
        <span class="Statement">return</span> value;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;

    ctrl.$parsers.push(maxLengthValidator);
    ctrl.$formatters.push(maxLengthValidator);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>

<span class="Identifier">function</span> numberInputType(scope, element, attr, ctrl, $sniffer, $browser) <span class="Identifier">{</span>
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  ctrl.$parsers.push(<span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Identifier">var</span> empty = ctrl.$isEmpty(value);
    <span class="Statement">if</span> (empty || NUMBER_REGEXP.test(value)) <span class="Identifier">{</span>
      ctrl.$setValidity(<span class="Constant">'number'</span>, <span class="Constant">true</span>);
      <span class="Statement">return</span> value === <span class="Constant">''</span> ? <span class="Statement">null</span> : (empty ? value : parseFloat(value));
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      ctrl.$setValidity(<span class="Constant">'number'</span>, <span class="Constant">false</span>);
      <span class="Statement">return</span> <span class="Statement">undefined</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>);

  ctrl.$formatters.push(<span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Statement">return</span> ctrl.$isEmpty(value) ? <span class="Constant">''</span> : <span class="Constant">''</span> + value;
  <span class="Identifier">}</span>);

  <span class="Statement">if</span> (attr.min) <span class="Identifier">{</span>
    <span class="Identifier">var</span> minValidator = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
      <span class="Identifier">var</span> min = parseFloat(attr.min);
      <span class="Statement">if</span> (!ctrl.$isEmpty(value) &amp;&amp; value &lt; min) <span class="Identifier">{</span>
        ctrl.$setValidity(<span class="Constant">'min'</span>, <span class="Constant">false</span>);
        <span class="Statement">return</span> <span class="Statement">undefined</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        ctrl.$setValidity(<span class="Constant">'min'</span>, <span class="Constant">true</span>);
        <span class="Statement">return</span> value;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;

    ctrl.$parsers.push(minValidator);
    ctrl.$formatters.push(minValidator);
  <span class="Identifier">}</span>

  <span class="Statement">if</span> (attr.max) <span class="Identifier">{</span>
    <span class="Identifier">var</span> maxValidator = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
      <span class="Identifier">var</span> max = parseFloat(attr.max);
      <span class="Statement">if</span> (!ctrl.$isEmpty(value) &amp;&amp; value &gt; max) <span class="Identifier">{</span>
        ctrl.$setValidity(<span class="Constant">'max'</span>, <span class="Constant">false</span>);
        <span class="Statement">return</span> <span class="Statement">undefined</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        ctrl.$setValidity(<span class="Constant">'max'</span>, <span class="Constant">true</span>);
        <span class="Statement">return</span> value;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;

    ctrl.$parsers.push(maxValidator);
    ctrl.$formatters.push(maxValidator);
  <span class="Identifier">}</span>

  ctrl.$formatters.push(<span class="Identifier">function</span>(value) <span class="Identifier">{</span>

    <span class="Statement">if</span> (ctrl.$isEmpty(value) || isNumber(value)) <span class="Identifier">{</span>
      ctrl.$setValidity(<span class="Constant">'number'</span>, <span class="Constant">true</span>);
      <span class="Statement">return</span> value;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      ctrl.$setValidity(<span class="Constant">'number'</span>, <span class="Constant">false</span>);
      <span class="Statement">return</span> <span class="Statement">undefined</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>);
<span class="Identifier">}</span>

<span class="Identifier">function</span> urlInputType(scope, element, attr, ctrl, $sniffer, $browser) <span class="Identifier">{</span>
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  <span class="Identifier">var</span> urlValidator = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Statement">if</span> (ctrl.$isEmpty(value) || URL_REGEXP.test(value)) <span class="Identifier">{</span>
      ctrl.$setValidity(<span class="Constant">'url'</span>, <span class="Constant">true</span>);
      <span class="Statement">return</span> value;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      ctrl.$setValidity(<span class="Constant">'url'</span>, <span class="Constant">false</span>);
      <span class="Statement">return</span> <span class="Statement">undefined</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  ctrl.$formatters.push(urlValidator);
  ctrl.$parsers.push(urlValidator);
<span class="Identifier">}</span>

<span class="Identifier">function</span> emailInputType(scope, element, attr, ctrl, $sniffer, $browser) <span class="Identifier">{</span>
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  <span class="Identifier">var</span> emailValidator = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Statement">if</span> (ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value)) <span class="Identifier">{</span>
      ctrl.$setValidity(<span class="Constant">'email'</span>, <span class="Constant">true</span>);
      <span class="Statement">return</span> value;
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      ctrl.$setValidity(<span class="Constant">'email'</span>, <span class="Constant">false</span>);
      <span class="Statement">return</span> <span class="Statement">undefined</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  ctrl.$formatters.push(emailValidator);
  ctrl.$parsers.push(emailValidator);
<span class="Identifier">}</span>

<span class="Identifier">function</span> radioInputType(scope, element, attr, ctrl) <span class="Identifier">{</span>
  <span class="Comment">// make the name unique, if not defined</span>
  <span class="Statement">if</span> (isUndefined(attr.name)) <span class="Identifier">{</span>
    element.attr(<span class="Constant">'name'</span>, nextUid());
  <span class="Identifier">}</span>

  element.on(<span class="Constant">'click'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Statement">if</span> (element<span class="Identifier">[</span>0<span class="Identifier">]</span>.checked) <span class="Identifier">{</span>
      scope.$apply(<span class="Identifier">function</span>() <span class="Identifier">{</span>
        ctrl.$setViewValue(attr.value);
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>);

  ctrl.$render = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Identifier">var</span> value = attr.value;
    element<span class="Identifier">[</span>0<span class="Identifier">]</span>.checked = (value == ctrl.$viewValue);
  <span class="Identifier">}</span>;

  attr.$observe(<span class="Constant">'value'</span>, ctrl.$render);
<span class="Identifier">}</span>

<span class="Identifier">function</span> checkboxInputType(scope, element, attr, ctrl) <span class="Identifier">{</span>
  <span class="Identifier">var</span> trueValue = attr.ngTrueValue,
      falseValue = attr.ngFalseValue;

  <span class="Statement">if</span> (!isString(trueValue)) trueValue = <span class="Constant">true</span>;
  <span class="Statement">if</span> (!isString(falseValue)) falseValue = <span class="Constant">false</span>;

  element.on(<span class="Constant">'click'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
    scope.$apply(<span class="Identifier">function</span>() <span class="Identifier">{</span>
      ctrl.$setViewValue(element<span class="Identifier">[</span>0<span class="Identifier">]</span>.checked);
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>);

  ctrl.$render = <span class="Identifier">function</span>() <span class="Identifier">{</span>
    element<span class="Identifier">[</span>0<span class="Identifier">]</span>.checked = ctrl.$viewValue;
  <span class="Identifier">}</span>;

  <span class="Comment">// Override the standard `$isEmpty` because a value of `false` means empty in a checkbox.</span>
  ctrl.$isEmpty = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Statement">return</span> value !== trueValue;
  <span class="Identifier">}</span>;

  ctrl.$formatters.push(<span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Statement">return</span> value === trueValue;
  <span class="Identifier">}</span>);

  ctrl.$parsers.push(<span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Statement">return</span> value ? trueValue : falseValue;
  <span class="Identifier">}</span>);
<span class="Identifier">}</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:textarea</span>
<span class="Comment"> * @restrict E</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * HTML textarea element control with angular data-binding. The data-binding and validation</span>
<span class="Comment"> * properties of this element are exactly the same as those of the</span>
<span class="Comment"> * {@link ng.directive:input input element}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} ngModel Assignable angular expression to data-bind to.</span>
<span class="Comment"> * @param {string=} name Property name of the form under which the control is published.</span>
<span class="Comment"> * @param {string=} required Sets `required` validation error key if the value is not entered.</span>
<span class="Comment"> * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to</span>
<span class="Comment"> *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of</span>
<span class="Comment"> *    `required` when you want to data-bind to the `required` attribute.</span>
<span class="Comment"> * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than</span>
<span class="Comment"> *    minlength.</span>
<span class="Comment"> * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than</span>
<span class="Comment"> *    maxlength.</span>
<span class="Comment"> * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the</span>
<span class="Comment"> *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for</span>
<span class="Comment"> *    patterns defined as scope expressions.</span>
<span class="Comment"> * @param {string=} ngChange Angular expression to be executed when input changes due to user</span>
<span class="Comment"> *    interaction with the input element.</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:input</span>
<span class="Comment"> * @restrict E</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * HTML input element control with angular data-binding. Input control follows HTML5 input types</span>
<span class="Comment"> * and polyfills the HTML5 validation behavior for older browsers.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} ngModel Assignable angular expression to data-bind to.</span>
<span class="Comment"> * @param {string=} name Property name of the form under which the control is published.</span>
<span class="Comment"> * @param {string=} required Sets `required` validation error key if the value is not entered.</span>
<span class="Comment"> * @param {boolean=} ngRequired Sets `required` attribute if set to true</span>
<span class="Comment"> * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than</span>
<span class="Comment"> *    minlength.</span>
<span class="Comment"> * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than</span>
<span class="Comment"> *    maxlength.</span>
<span class="Comment"> * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the</span>
<span class="Comment"> *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for</span>
<span class="Comment"> *    patterns defined as scope expressions.</span>
<span class="Comment"> * @param {string=} ngChange Angular expression to be executed when input changes due to user</span>
<span class="Comment"> *    interaction with the input element.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">    &lt;doc:example&gt;</span>
<span class="Comment">      &lt;doc:source&gt;</span>
<span class="Comment">       &lt;script&gt;</span>
<span class="Comment">         function Ctrl($scope) {</span>
<span class="Comment">           $scope.user = {name: 'guest', last: 'visitor'};</span>
<span class="Comment">         }</span>
<span class="Comment">       &lt;/script&gt;</span>
<span class="Comment">       &lt;div ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">         &lt;form name=&quot;myForm&quot;&gt;</span>
<span class="Comment">           User name: &lt;input type=&quot;text&quot; name=&quot;userName&quot; ng-model=&quot;user.name&quot; required&gt;</span>
<span class="Comment">           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.userName.$error.required&quot;&gt;</span>
<span class="Comment">             Required!&lt;/span&gt;&lt;br&gt;</span>
<span class="Comment">           Last name: &lt;input type=&quot;text&quot; name=&quot;lastName&quot; ng-model=&quot;user.last&quot;</span>
<span class="Comment">             ng-minlength=&quot;3&quot; ng-maxlength=&quot;10&quot;&gt;</span>
<span class="Comment">           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.lastName.$error.minlength&quot;&gt;</span>
<span class="Comment">             Too short!&lt;/span&gt;</span>
<span class="Comment">           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.lastName.$error.maxlength&quot;&gt;</span>
<span class="Comment">             Too long!&lt;/span&gt;&lt;br&gt;</span>
<span class="Comment">         &lt;/form&gt;</span>
<span class="Comment">         &lt;hr&gt;</span>
<span class="Comment">         &lt;tt&gt;user = {{user}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.userName.$valid = {{myForm.userName.$valid}}&lt;/tt&gt;&lt;br&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.userName.$error = {{myForm.userName.$error}}&lt;/tt&gt;&lt;br&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.lastName.$valid = {{myForm.lastName.$valid}}&lt;/tt&gt;&lt;br&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.lastName.$error = {{myForm.lastName.$error}}&lt;/tt&gt;&lt;br&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.$error.minlength = {{!!myForm.$error.minlength}}&lt;/tt&gt;&lt;br&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.$error.maxlength = {{!!myForm.$error.maxlength}}&lt;/tt&gt;&lt;br&gt;</span>
<span class="Comment">       &lt;/div&gt;</span>
<span class="Comment">      &lt;/doc:source&gt;</span>
<span class="Comment">      &lt;doc:scenario&gt;</span>
<span class="Comment">        it('should initialize to model', function() {</span>
<span class="Comment">          expect(binding('user')).toEqual('{&quot;name&quot;:&quot;guest&quot;,&quot;last&quot;:&quot;visitor&quot;}');</span>
<span class="Comment">          expect(binding('myForm.userName.$valid')).toEqual('true');</span>
<span class="Comment">          expect(binding('myForm.$valid')).toEqual('true');</span>
<span class="Comment">        });</span>

<span class="Comment">        it('should be invalid if empty when required', function() {</span>
<span class="Comment">          input('user.name').enter('');</span>
<span class="Comment">          expect(binding('user')).toEqual('{&quot;last&quot;:&quot;visitor&quot;}');</span>
<span class="Comment">          expect(binding('myForm.userName.$valid')).toEqual('false');</span>
<span class="Comment">          expect(binding('myForm.$valid')).toEqual('false');</span>
<span class="Comment">        });</span>

<span class="Comment">        it('should be valid if empty when min length is set', function() {</span>
<span class="Comment">          input('user.last').enter('');</span>
<span class="Comment">          expect(binding('user')).toEqual('{&quot;name&quot;:&quot;guest&quot;,&quot;last&quot;:&quot;&quot;}');</span>
<span class="Comment">          expect(binding('myForm.lastName.$valid')).toEqual('true');</span>
<span class="Comment">          expect(binding('myForm.$valid')).toEqual('true');</span>
<span class="Comment">        });</span>

<span class="Comment">        it('should be invalid if less than required min length', function() {</span>
<span class="Comment">          input('user.last').enter('xx');</span>
<span class="Comment">          expect(binding('user')).toEqual('{&quot;name&quot;:&quot;guest&quot;}');</span>
<span class="Comment">          expect(binding('myForm.lastName.$valid')).toEqual('false');</span>
<span class="Comment">          expect(binding('myForm.lastName.$error')).toMatch(/minlength/);</span>
<span class="Comment">          expect(binding('myForm.$valid')).toEqual('false');</span>
<span class="Comment">        });</span>

<span class="Comment">        it('should be invalid if longer than max length', function() {</span>
<span class="Comment">          input('user.last').enter('some ridiculously long name');</span>
<span class="Comment">          expect(binding('user'))</span>
<span class="Comment">            .toEqual('{&quot;name&quot;:&quot;guest&quot;}');</span>
<span class="Comment">          expect(binding('myForm.lastName.$valid')).toEqual('false');</span>
<span class="Comment">          expect(binding('myForm.lastName.$error')).toMatch(/maxlength/);</span>
<span class="Comment">          expect(binding('myForm.$valid')).toEqual('false');</span>
<span class="Comment">        });</span>
<span class="Comment">      &lt;/doc:scenario&gt;</span>
<span class="Comment">    &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> inputDirective = <span class="Identifier">[</span><span class="Constant">'$browser'</span>, <span class="Constant">'$sniffer'</span>, <span class="Identifier">function</span>($browser, $sniffer) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">{</span>
    restrict: <span class="Constant">'E'</span>,
    require: <span class="Constant">'?ngModel'</span>,
    link: <span class="Identifier">function</span>(scope, element, attr, ctrl) <span class="Identifier">{</span>
      <span class="Statement">if</span> (ctrl) <span class="Identifier">{</span>
        (inputType<span class="Identifier">[</span>lowercase(attr.type)<span class="Identifier">]</span> || inputType.text)(scope, element, attr, ctrl, $sniffer,
                                                            $browser);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}]</span>;

<span class="Identifier">var</span> VALID_CLASS = <span class="Constant">'ng-valid'</span>,
    INVALID_CLASS = <span class="Constant">'ng-invalid'</span>,
    PRISTINE_CLASS = <span class="Constant">'ng-pristine'</span>,
    DIRTY_CLASS = <span class="Constant">'ng-dirty'</span>;

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc object</span>
<span class="Comment"> * @name ng.directive:ngModel.NgModelController</span>
<span class="Comment"> *</span>
<span class="Comment"> * @property {string} $viewValue Actual string value in the view.</span>
<span class="Comment"> * @property {*} $modelValue The value in the model, that the control is bound to.</span>
<span class="Comment"> * @property {Array.&lt;Function&gt;} $parsers Array of functions to execute, as a pipeline, whenever</span>
<span class="Comment">       the control reads value from the DOM.  Each function is called, in turn, passing the value</span>
<span class="Comment">       through to the next. Used to sanitize / convert the value as well as validation.</span>
<span class="Comment">       For validation, the parsers should update the validity state using</span>
<span class="Comment">       {@link ng.directive:ngModel.NgModelController#methods_$setValidity $setValidity()},</span>
<span class="Comment">       and return `undefined` for invalid values.</span>

<span class="Comment"> *</span>
<span class="Comment"> * @property {Array.&lt;Function&gt;} $formatters Array of functions to execute, as a pipeline, whenever</span>
<span class="Comment">       the model value changes. Each function is called, in turn, passing the value through to the</span>
<span class="Comment">       next. Used to format / convert values for display in the control and validation.</span>
<span class="Comment"> *      &lt;pre&gt;</span>
<span class="Comment"> *      function formatter(value) {</span>
<span class="Comment"> *        if (value) {</span>
<span class="Comment"> *          return value.toUpperCase();</span>
<span class="Comment"> *        }</span>
<span class="Comment"> *      }</span>
<span class="Comment"> *      ngModel.$formatters.push(formatter);</span>
<span class="Comment"> *      &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @property {Array.&lt;Function&gt;} $viewChangeListeners Array of functions to execute whenever the</span>
<span class="Comment"> *     view value has changed. It is called with no arguments, and its return value is ignored.</span>
<span class="Comment"> *     This can be used in place of additional $watches against the model value.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @property {Object} $error An object hash with all errors as keys.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @property {boolean} $pristine True if user has not interacted with the control yet.</span>
<span class="Comment"> * @property {boolean} $dirty True if user has already interacted with the control.</span>
<span class="Comment"> * @property {boolean} $valid True if there is no error.</span>
<span class="Comment"> * @property {boolean} $invalid True if at least one error on the control.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> *</span>
<span class="Comment"> * `NgModelController` provides API for the `ng-model` directive. The controller contains</span>
<span class="Comment"> * services for data-binding, validation, CSS updates, and value formatting and parsing. It</span>
<span class="Comment"> * purposefully does not contain any logic which deals with DOM rendering or listening to</span>
<span class="Comment"> * DOM events. Such DOM related logic should be provided by other directives which make use of</span>
<span class="Comment"> * `NgModelController` for data-binding.</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## Custom Control Example</span>
<span class="Comment"> * This example shows how to use `NgModelController` with a custom control to achieve</span>
<span class="Comment"> * data-binding. Notice how different directives (`contenteditable`, `ng-model`, and `required`)</span>
<span class="Comment"> * collaborate together to achieve the desired result.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Note that `contenteditable` is an HTML5 attribute, which tells the browser to let the element</span>
<span class="Comment"> * contents be edited in place by the user.  This will not work on older browsers.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;example module=&quot;customControl&quot;&gt;</span>
<span class="Comment">    &lt;file name=&quot;style.css&quot;&gt;</span>
<span class="Comment">      [contenteditable] {</span>
<span class="Comment">        border: 1px solid black;</span>
<span class="Comment">        background-color: white;</span>
<span class="Comment">        min-height: 20px;</span>
<span class="Comment">      }</span>

<span class="Comment">      .ng-invalid {</span>
<span class="Comment">        border: 1px solid red;</span>
<span class="Comment">      }</span>

<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;script.js&quot;&gt;</span>
<span class="Comment">      angular.module('customControl', []).</span>
<span class="Comment">        directive('contenteditable', function() {</span>
<span class="Comment">          return {</span>
<span class="Comment">            restrict: 'A', // only activate on element attribute</span>
<span class="Comment">            require: '?ngModel', // get a hold of NgModelController</span>
<span class="Comment">            link: function(scope, element, attrs, ngModel) {</span>
<span class="Comment">              if(!ngModel) return; // do nothing if no ng-model</span>

<span class="Comment">              // Specify how UI should be updated</span>
<span class="Comment">              ngModel.$render = function() {</span>
<span class="Comment">                element.html(ngModel.$viewValue || '');</span>
<span class="Comment">              };</span>

<span class="Comment">              // Listen for change events to enable binding</span>
<span class="Comment">              element.on('blur keyup change', function() {</span>
<span class="Comment">                scope.$apply(read);</span>
<span class="Comment">              });</span>
<span class="Comment">              read(); // initialize</span>

<span class="Comment">              // Write data to the model</span>
<span class="Comment">              function read() {</span>
<span class="Comment">                var html = element.html();</span>
<span class="Comment">                // When we clear the content editable the browser leaves a &lt;br&gt; behind</span>
<span class="Comment">                // If strip-br attribute is provided then we strip this out</span>
<span class="Comment">                if( attrs.stripBr &amp;&amp; html == '&lt;br&gt;' ) {</span>
<span class="Comment">                  html = '';</span>
<span class="Comment">                }</span>
<span class="Comment">                ngModel.$setViewValue(html);</span>
<span class="Comment">              }</span>
<span class="Comment">            }</span>
<span class="Comment">          };</span>
<span class="Comment">        });</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">      &lt;form name=&quot;myForm&quot;&gt;</span>
<span class="Comment">       &lt;div contenteditable</span>
<span class="Comment">            name=&quot;myWidget&quot; ng-model=&quot;userContent&quot;</span>
<span class="Comment">            strip-br=&quot;true&quot;</span>
<span class="Comment">            required&gt;Change me!&lt;/div&gt;</span>
<span class="Comment">        &lt;span ng-show=&quot;myForm.myWidget.$error.required&quot;&gt;Required!&lt;/span&gt;</span>
<span class="Comment">       &lt;hr&gt;</span>
<span class="Comment">       &lt;textarea ng-model=&quot;userContent&quot;&gt;&lt;/textarea&gt;</span>
<span class="Comment">      &lt;/form&gt;</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;scenario.js&quot;&gt;</span>
<span class="Comment">      it('should data-bind and become invalid', function() {</span>
<span class="Comment">        var contentEditable = element('[contenteditable]');</span>

<span class="Comment">        expect(contentEditable.text()).toEqual('Change me!');</span>
<span class="Comment">        input('userContent').enter('');</span>
<span class="Comment">        expect(contentEditable.text()).toEqual('');</span>
<span class="Comment">        expect(contentEditable.prop('className')).toMatch(/ng-invalid-required/);</span>
<span class="Comment">      });</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment"> * &lt;/example&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> NgModelController = <span class="Identifier">[</span><span class="Constant">'$scope'</span>, <span class="Constant">'$exceptionHandler'</span>, <span class="Constant">'$attrs'</span>, <span class="Constant">'$element'</span>, <span class="Constant">'$parse'</span>,
    <span class="Identifier">function</span>($scope, $exceptionHandler, $attr, $element, $parse) <span class="Identifier">{</span>
  <span class="Identifier">this</span>.$viewValue = <span class="Type">Number</span>.NaN;
  <span class="Identifier">this</span>.$modelValue = <span class="Type">Number</span>.NaN;
  <span class="Identifier">this</span>.$parsers = <span class="Identifier">[]</span>;
  <span class="Identifier">this</span>.$formatters = <span class="Identifier">[]</span>;
  <span class="Identifier">this</span>.$viewChangeListeners = <span class="Identifier">[]</span>;
  <span class="Identifier">this</span>.$pristine = <span class="Constant">true</span>;
  <span class="Identifier">this</span>.$dirty = <span class="Constant">false</span>;
  <span class="Identifier">this</span>.$valid = <span class="Constant">true</span>;
  <span class="Identifier">this</span>.$invalid = <span class="Constant">false</span>;
  <span class="Identifier">this</span>.$name = $attr.name;

  <span class="Identifier">var</span> ngModelGet = $parse($attr.ngModel),
      ngModelSet = ngModelGet.assign;

  <span class="Statement">if</span> (!ngModelSet) <span class="Identifier">{</span>
    <span class="Statement">throw</span> minErr(<span class="Constant">'ngModel'</span>)(<span class="Constant">'nonassign'</span>, <span class="Constant">&quot;Expression '{0}' is non-assignable. Element: {1}&quot;</span>,
        $attr.ngModel, startingTag($element));
  <span class="Identifier">}</span>

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.directive:ngModel.NgModelController#$render</span>
<span class="Comment">   * @methodOf ng.directive:ngModel.NgModelController</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Called when the view needs to be updated. It is expected that the user of the ng-model</span>
<span class="Comment">   * directive will implement this method.</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.$render = noop;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name { ng.directive:ngModel.NgModelController#$isEmpty</span>
<span class="Comment">   * @methodOf ng.directive:ngModel.NgModelController</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * This is called when we need to determine if the value of the input is empty.</span>
<span class="Comment">   *</span>
<span class="Comment">   * For instance, the required directive does this to work out if the input has data or not.</span>
<span class="Comment">   * The default `$isEmpty` function checks whether the value is `undefined`, `''`, `null` or `NaN`.</span>
<span class="Comment">   *</span>
<span class="Comment">   * You can override this for input directives whose concept of being empty is different to the</span>
<span class="Comment">   * default. The `checkboxInputType` directive does this because in its case a value of `false`</span>
<span class="Comment">   * implies empty.</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.$isEmpty = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Statement">return</span> isUndefined(value) || value === <span class="Constant">''</span> || value === <span class="Statement">null</span> || value !== value;
  <span class="Identifier">}</span>;

  <span class="Identifier">var</span> parentForm = $element.inheritedData(<span class="Constant">'$formController'</span>) || nullFormCtrl,
      invalidCount = 0, <span class="Comment">// used to easily determine if we are valid</span>
      $error = <span class="Identifier">this</span>.$error = <span class="Identifier">{}</span>; <span class="Comment">// keep invalid keys here</span>


  <span class="Comment">// Setup initial state of the control</span>
  $element.addClass(PRISTINE_CLASS);
  toggleValidCss(<span class="Constant">true</span>);

  <span class="Comment">// convenience method for easy toggling of classes</span>
  <span class="Identifier">function</span> toggleValidCss(isValid, validationErrorKey) <span class="Identifier">{</span>
    validationErrorKey = validationErrorKey ? <span class="Constant">'-'</span> + snake_case(validationErrorKey, <span class="Constant">'-'</span>) : <span class="Constant">''</span>;
    $element.
      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
  <span class="Identifier">}</span>

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.directive:ngModel.NgModelController#$setValidity</span>
<span class="Comment">   * @methodOf ng.directive:ngModel.NgModelController</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Change the validity state, and notifies the form when the control changes validity. (i.e. it</span>
<span class="Comment">   * does not notify form if given validator is already marked as invalid).</span>
<span class="Comment">   *</span>
<span class="Comment">   * This method should be called by validators - i.e. the parser or formatter functions.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string} validationErrorKey Name of the validator. the `validationErrorKey` will assign</span>
<span class="Comment">   *        to `$error[validationErrorKey]=isValid` so that it is available for data-binding.</span>
<span class="Comment">   *        The `validationErrorKey` should be in camelCase and will get converted into dash-case</span>
<span class="Comment">   *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`</span>
<span class="Comment">   *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .</span>
<span class="Comment">   * @param {boolean} isValid Whether the current state is valid (true) or invalid (false).</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.$setValidity = <span class="Identifier">function</span>(validationErrorKey, isValid) <span class="Identifier">{</span>
    <span class="Comment">// Purposeful use of ! here to cast isValid to boolean in case it is undefined</span>
    <span class="Comment">// jshint -W018</span>
    <span class="Statement">if</span> ($error<span class="Identifier">[</span>validationErrorKey<span class="Identifier">]</span> === !isValid) <span class="Statement">return</span>;
    <span class="Comment">// jshint +W018</span>

    <span class="Statement">if</span> (isValid) <span class="Identifier">{</span>
      <span class="Statement">if</span> ($error<span class="Identifier">[</span>validationErrorKey<span class="Identifier">]</span>) invalidCount--;
      <span class="Statement">if</span> (!invalidCount) <span class="Identifier">{</span>
        toggleValidCss(<span class="Constant">true</span>);
        <span class="Identifier">this</span>.$valid = <span class="Constant">true</span>;
        <span class="Identifier">this</span>.$invalid = <span class="Constant">false</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
      toggleValidCss(<span class="Constant">false</span>);
      <span class="Identifier">this</span>.$invalid = <span class="Constant">true</span>;
      <span class="Identifier">this</span>.$valid = <span class="Constant">false</span>;
      invalidCount++;
    <span class="Identifier">}</span>

    $error<span class="Identifier">[</span>validationErrorKey<span class="Identifier">]</span> = !isValid;
    toggleValidCss(isValid, validationErrorKey);

    parentForm.$setValidity(validationErrorKey, isValid, <span class="Identifier">this</span>);
  <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.directive:ngModel.NgModelController#$setPristine</span>
<span class="Comment">   * @methodOf ng.directive:ngModel.NgModelController</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Sets the control to its pristine state.</span>
<span class="Comment">   *</span>
<span class="Comment">   * This method can be called to remove the 'ng-dirty' class and set the control to its pristine</span>
<span class="Comment">   * state (ng-pristine class).</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.$setPristine = <span class="Identifier">function</span> () <span class="Identifier">{</span>
    <span class="Identifier">this</span>.$dirty = <span class="Constant">false</span>;
    <span class="Identifier">this</span>.$pristine = <span class="Constant">true</span>;
    $element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);
  <span class="Identifier">}</span>;

  <span class="Comment">/**</span>
<span class="Comment">   * @ngdoc function</span>
<span class="Comment">   * @name ng.directive:ngModel.NgModelController#$setViewValue</span>
<span class="Comment">   * @methodOf ng.directive:ngModel.NgModelController</span>
<span class="Comment">   *</span>
<span class="Comment">   * @description</span>
<span class="Comment">   * Update the view value.</span>
<span class="Comment">   *</span>
<span class="Comment">   * This method should be called when the view value changes, typically from within a DOM event handler.</span>
<span class="Comment">   * For example {@link ng.directive:input input} and</span>
<span class="Comment">   * {@link ng.directive:select select} directives call it.</span>
<span class="Comment">   *</span>
<span class="Comment">   * It will update the $viewValue, then pass this value through each of the functions in `$parsers`,</span>
<span class="Comment">   * which includes any validators. The value that comes out of this `$parsers` pipeline, be applied to</span>
<span class="Comment">   * `$modelValue` and the **expression** specified in the `ng-model` attribute.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Lastly, all the registered change listeners, in the `$viewChangeListeners` list, are called.</span>
<span class="Comment">   *</span>
<span class="Comment">   * Note that calling this function does not trigger a `$digest`.</span>
<span class="Comment">   *</span>
<span class="Comment">   * @param {string} value Value from the view.</span>
<span class="Comment">   */</span>
  <span class="Identifier">this</span>.$setViewValue = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
    <span class="Identifier">this</span>.$viewValue = value;

    <span class="Comment">// change to dirty</span>
    <span class="Statement">if</span> (<span class="Identifier">this</span>.$pristine) <span class="Identifier">{</span>
      <span class="Identifier">this</span>.$dirty = <span class="Constant">true</span>;
      <span class="Identifier">this</span>.$pristine = <span class="Constant">false</span>;
      $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
      parentForm.$setDirty();
    <span class="Identifier">}</span>

    forEach(<span class="Identifier">this</span>.$parsers, <span class="Identifier">function</span>(fn) <span class="Identifier">{</span>
      value = fn(value);
    <span class="Identifier">}</span>);

    <span class="Statement">if</span> (<span class="Identifier">this</span>.$modelValue !== value) <span class="Identifier">{</span>
      <span class="Identifier">this</span>.$modelValue = value;
      ngModelSet($scope, value);
      forEach(<span class="Identifier">this</span>.$viewChangeListeners, <span class="Identifier">function</span>(listener) <span class="Identifier">{</span>
        <span class="Statement">try</span> <span class="Identifier">{</span>
          listener();
        <span class="Identifier">}</span> <span class="Statement">catch</span>(e) <span class="Identifier">{</span>
          $exceptionHandler(e);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Comment">// model -&gt; value</span>
  <span class="Identifier">var</span> ctrl = <span class="Identifier">this</span>;

  $scope.$watch(<span class="Identifier">function</span> ngModelWatch() <span class="Identifier">{</span>
    <span class="Identifier">var</span> value = ngModelGet($scope);

    <span class="Comment">// if scope model value and ngModel value are out of sync</span>
    <span class="Statement">if</span> (ctrl.$modelValue !== value) <span class="Identifier">{</span>

      <span class="Identifier">var</span> formatters = ctrl.$formatters,
          idx = formatters.length;

      ctrl.$modelValue = value;
      <span class="Statement">while</span>(idx--) <span class="Identifier">{</span>
        value = formatters<span class="Identifier">[</span>idx<span class="Identifier">]</span>(value);
      <span class="Identifier">}</span>

      <span class="Statement">if</span> (ctrl.$viewValue !== value) <span class="Identifier">{</span>
        ctrl.$viewValue = value;
        ctrl.$render();
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>

    <span class="Statement">return</span> value;
  <span class="Identifier">}</span>);
<span class="Identifier">}]</span>;


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngModel</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element input</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngModel` directive binds an `input`,`select`, `textarea` (or custom form control) to a</span>
<span class="Comment"> * property on the scope using {@link ng.directive:ngModel.NgModelController NgModelController},</span>
<span class="Comment"> * which is created and exposed by this directive.</span>
<span class="Comment"> *</span>
<span class="Comment"> * `ngModel` is responsible for:</span>
<span class="Comment"> *</span>
<span class="Comment"> * - Binding the view into the model, which other directives such as `input`, `textarea` or `select`</span>
<span class="Comment"> *   require.</span>
<span class="Comment"> * - Providing validation behavior (i.e. required, number, email, url).</span>
<span class="Comment"> * - Keeping the state of the control (valid/invalid, dirty/pristine, validation errors).</span>
<span class="Comment"> * - Setting related css classes on the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`).</span>
<span class="Comment"> * - Registering the control with its parent {@link ng.directive:form form}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Note: `ngModel` will try to bind to the property given by evaluating the expression on the</span>
<span class="Comment"> * current scope. If the property doesn't already exist on this scope, it will be created</span>
<span class="Comment"> * implicitly and added to the scope.</span>
<span class="Comment"> *</span>
<span class="Comment"> * For best practices on using `ngModel`, see:</span>
<span class="Comment"> *</span>
<span class="Comment"> *  - {@link <a href="https://github.com/angular/angular.js/wiki/Understanding-Scopes}">https://github.com/angular/angular.js/wiki/Understanding-Scopes}</a></span>
<span class="Comment"> *</span>
<span class="Comment"> * For basic examples, how to use `ngModel`, see:</span>
<span class="Comment"> *</span>
<span class="Comment"> *  - {@link ng.directive:input input}</span>
<span class="Comment"> *    - {@link ng.directive:input.text text}</span>
<span class="Comment"> *    - {@link ng.directive:input.checkbox checkbox}</span>
<span class="Comment"> *    - {@link ng.directive:input.radio radio}</span>
<span class="Comment"> *    - {@link ng.directive:input.number number}</span>
<span class="Comment"> *    - {@link ng.directive:input.email email}</span>
<span class="Comment"> *    - {@link ng.directive:input.url url}</span>
<span class="Comment"> *  - {@link ng.directive:select select}</span>
<span class="Comment"> *  - {@link ng.directive:textarea textarea}</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngModelDirective = <span class="Identifier">function</span>() <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">{</span>
    require: <span class="Identifier">[</span><span class="Constant">'ngModel'</span>, <span class="Constant">'^?form'</span><span class="Identifier">]</span>,
    controller: NgModelController,
    link: <span class="Identifier">function</span>(scope, element, attr, ctrls) <span class="Identifier">{</span>
      <span class="Comment">// notify others, especially parent forms</span>

      <span class="Identifier">var</span> modelCtrl = ctrls<span class="Identifier">[</span>0<span class="Identifier">]</span>,
          formCtrl = ctrls<span class="Identifier">[</span>1<span class="Identifier">]</span> || nullFormCtrl;

      formCtrl.$addControl(modelCtrl);

      scope.$on(<span class="Constant">'$destroy'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
        formCtrl.$removeControl(modelCtrl);
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>;


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngChange</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Evaluate given expression when user changes the input.</span>
<span class="Comment"> * The expression is not evaluated when the value change is coming from the model.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Note, this directive requires `ngModel` to be present.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element input</span>
<span class="Comment"> * @param {expression} ngChange {@link guide/expression Expression} to evaluate upon change</span>
<span class="Comment"> * in input value.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * &lt;doc:example&gt;</span>
<span class="Comment"> *   &lt;doc:source&gt;</span>
<span class="Comment"> *     &lt;script&gt;</span>
<span class="Comment"> *       function Controller($scope) {</span>
<span class="Comment"> *         $scope.counter = 0;</span>
<span class="Comment"> *         $scope.change = function() {</span>
<span class="Comment"> *           $scope.counter++;</span>
<span class="Comment"> *         };</span>
<span class="Comment"> *       }</span>
<span class="Comment"> *     &lt;/script&gt;</span>
<span class="Comment"> *     &lt;div ng-controller=&quot;Controller&quot;&gt;</span>
<span class="Comment"> *       &lt;input type=&quot;checkbox&quot; ng-model=&quot;confirmed&quot; ng-change=&quot;change()&quot; id=&quot;ng-change-example1&quot; /&gt;</span>
<span class="Comment"> *       &lt;input type=&quot;checkbox&quot; ng-model=&quot;confirmed&quot; id=&quot;ng-change-example2&quot; /&gt;</span>
<span class="Comment"> *       &lt;label for=&quot;ng-change-example2&quot;&gt;Confirmed&lt;/label&gt;&lt;br /&gt;</span>
<span class="Comment"> *       debug = {{confirmed}}&lt;br /&gt;</span>
<span class="Comment"> *       counter = {{counter}}</span>
<span class="Comment"> *     &lt;/div&gt;</span>
<span class="Comment"> *   &lt;/doc:source&gt;</span>
<span class="Comment"> *   &lt;doc:scenario&gt;</span>
<span class="Comment"> *     it('should evaluate the expression if changing from view', function() {</span>
<span class="Comment"> *       expect(binding('counter')).toEqual('0');</span>
<span class="Comment"> *       element('#ng-change-example1').click();</span>
<span class="Comment"> *       expect(binding('counter')).toEqual('1');</span>
<span class="Comment"> *       expect(binding('confirmed')).toEqual('true');</span>
<span class="Comment"> *     });</span>
<span class="Comment"> *</span>
<span class="Comment"> *     it('should not evaluate the expression if changing from model', function() {</span>
<span class="Comment"> *       element('#ng-change-example2').click();</span>
<span class="Comment"> *       expect(binding('counter')).toEqual('0');</span>
<span class="Comment"> *       expect(binding('confirmed')).toEqual('true');</span>
<span class="Comment"> *     });</span>
<span class="Comment"> *   &lt;/doc:scenario&gt;</span>
<span class="Comment"> * &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngChangeDirective = valueFn(<span class="Identifier">{</span>
  require: <span class="Constant">'ngModel'</span>,
  link: <span class="Identifier">function</span>(scope, element, attr, ctrl) <span class="Identifier">{</span>
    ctrl.$viewChangeListeners.push(<span class="Identifier">function</span>() <span class="Identifier">{</span>
      scope.$eval(attr.ngChange);
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>);


<span class="Identifier">var</span> requiredDirective = <span class="Identifier">function</span>() <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">{</span>
    require: <span class="Constant">'?ngModel'</span>,
    link: <span class="Identifier">function</span>(scope, elm, attr, ctrl) <span class="Identifier">{</span>
      <span class="Statement">if</span> (!ctrl) <span class="Statement">return</span>;
      attr.required = <span class="Constant">true</span>; <span class="Comment">// force truthy in case we are on non input element</span>

      <span class="Identifier">var</span> validator = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
        <span class="Statement">if</span> (attr.required &amp;&amp; ctrl.$isEmpty(value)) <span class="Identifier">{</span>
          ctrl.$setValidity(<span class="Constant">'required'</span>, <span class="Constant">false</span>);
          <span class="Statement">return</span>;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          ctrl.$setValidity(<span class="Constant">'required'</span>, <span class="Constant">true</span>);
          <span class="Statement">return</span> value;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>;

      ctrl.$formatters.push(validator);
      ctrl.$parsers.unshift(validator);

      attr.$observe(<span class="Constant">'required'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
        validator(ctrl.$viewValue);
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>;


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngList</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Text input that converts between a delimited string and an array of strings. The delimiter</span>
<span class="Comment"> * can be a fixed string (by default a comma) or a regular expression.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element input</span>
<span class="Comment"> * @param {string=} ngList optional delimiter that should be used to split the value. If</span>
<span class="Comment"> *   specified in form `/something/` then the value will be converted into a regular expression.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">    &lt;doc:example&gt;</span>
<span class="Comment">      &lt;doc:source&gt;</span>
<span class="Comment">       &lt;script&gt;</span>
<span class="Comment">         function Ctrl($scope) {</span>
<span class="Comment">           $scope.names = ['igor', 'misko', 'vojta'];</span>
<span class="Comment">         }</span>
<span class="Comment">       &lt;/script&gt;</span>
<span class="Comment">       &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">         List: &lt;input name=&quot;namesInput&quot; ng-model=&quot;names&quot; ng-list required&gt;</span>
<span class="Comment">         &lt;span class=&quot;error&quot; ng-show=&quot;myForm.namesInput.$error.required&quot;&gt;</span>
<span class="Comment">           Required!&lt;/span&gt;</span>
<span class="Comment">         &lt;br&gt;</span>
<span class="Comment">         &lt;tt&gt;names = {{names}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.namesInput.$valid = {{myForm.namesInput.$valid}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.namesInput.$error = {{myForm.namesInput.$error}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">         &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;</span>
<span class="Comment">        &lt;/form&gt;</span>
<span class="Comment">      &lt;/doc:source&gt;</span>
<span class="Comment">      &lt;doc:scenario&gt;</span>
<span class="Comment">        it('should initialize to model', function() {</span>
<span class="Comment">          expect(binding('names')).toEqual('[&quot;igor&quot;,&quot;misko&quot;,&quot;vojta&quot;]');</span>
<span class="Comment">          expect(binding('myForm.namesInput.$valid')).toEqual('true');</span>
<span class="Comment">          expect(element('span.error').css('display')).toBe('none');</span>
<span class="Comment">        });</span>

<span class="Comment">        it('should be invalid if empty', function() {</span>
<span class="Comment">          input('names').enter('');</span>
<span class="Comment">          expect(binding('names')).toEqual('');</span>
<span class="Comment">          expect(binding('myForm.namesInput.$valid')).toEqual('false');</span>
<span class="Comment">          expect(element('span.error').css('display')).not().toBe('none');</span>
<span class="Comment">        });</span>
<span class="Comment">      &lt;/doc:scenario&gt;</span>
<span class="Comment">    &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngListDirective = <span class="Identifier">function</span>() <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">{</span>
    require: <span class="Constant">'ngModel'</span>,
    link: <span class="Identifier">function</span>(scope, element, attr, ctrl) <span class="Identifier">{</span>
      <span class="Identifier">var</span> match = <span class="Constant">/\/(.*)\//</span>.exec(attr.ngList),
          separator = match &amp;&amp; <span class="Statement">new</span> <span class="Type">RegExp</span>(match<span class="Identifier">[</span>1<span class="Identifier">]</span>) || attr.ngList || <span class="Constant">','</span>;

      <span class="Identifier">var</span> parse = <span class="Identifier">function</span>(viewValue) <span class="Identifier">{</span>
        <span class="Comment">// If the viewValue is invalid (say required but empty) it will be `undefined`</span>
        <span class="Statement">if</span> (isUndefined(viewValue)) <span class="Statement">return</span>;

        <span class="Identifier">var</span> list = <span class="Identifier">[]</span>;

        <span class="Statement">if</span> (viewValue) <span class="Identifier">{</span>
          forEach(viewValue.split(separator), <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
            <span class="Statement">if</span> (value) list.push(trim(value));
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>

        <span class="Statement">return</span> list;
      <span class="Identifier">}</span>;

      ctrl.$parsers.push(parse);
      ctrl.$formatters.push(<span class="Identifier">function</span>(value) <span class="Identifier">{</span>
        <span class="Statement">if</span> (isArray(value)) <span class="Identifier">{</span>
          <span class="Statement">return</span> value.join(<span class="Constant">', '</span>);
        <span class="Identifier">}</span>

        <span class="Statement">return</span> <span class="Statement">undefined</span>;
      <span class="Identifier">}</span>);

      <span class="Comment">// Override the standard $isEmpty because an empty array means the input is empty.</span>
      ctrl.$isEmpty = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
        <span class="Statement">return</span> !value || !value.length;
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>;


<span class="Identifier">var</span> CONSTANT_VALUE_REGEXP = <span class="Constant">/^(true|false|\d+)$/</span>;
<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngValue</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Binds the given expression to the value of `input[select]` or `input[radio]`, so</span>
<span class="Comment"> * that when the element is selected, the `ngModel` of that element is set to the</span>
<span class="Comment"> * bound value.</span>
<span class="Comment"> *</span>
<span class="Comment"> * `ngValue` is useful when dynamically generating lists of radio buttons using `ng-repeat`, as</span>
<span class="Comment"> * shown below.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element input</span>
<span class="Comment"> * @param {string=} ngValue angular expression, whose value will be bound to the `value` attribute</span>
<span class="Comment"> *   of the `input` element</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">    &lt;doc:example&gt;</span>
<span class="Comment">      &lt;doc:source&gt;</span>
<span class="Comment">       &lt;script&gt;</span>
<span class="Comment">          function Ctrl($scope) {</span>
<span class="Comment">            $scope.names = ['pizza', 'unicorns', 'robots'];</span>
<span class="Comment">            $scope.my = { favorite: 'unicorns' };</span>
<span class="Comment">          }</span>
<span class="Comment">       &lt;/script&gt;</span>
<span class="Comment">        &lt;form ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">          &lt;h2&gt;Which is your favorite?&lt;/h2&gt;</span>
<span class="Comment">            &lt;label ng-repeat=&quot;name in names&quot; for=&quot;{{name}}&quot;&gt;</span>
<span class="Comment">              {{name}}</span>
<span class="Comment">              &lt;input type=&quot;radio&quot;</span>
<span class="Comment">                     ng-model=&quot;my.favorite&quot;</span>
<span class="Comment">                     ng-value=&quot;name&quot;</span>
<span class="Comment">                     id=&quot;{{name}}&quot;</span>
<span class="Comment">                     name=&quot;favorite&quot;&gt;</span>
<span class="Comment">            &lt;/label&gt;</span>
<span class="Comment">          &lt;/span&gt;</span>
<span class="Comment">          &lt;div&gt;You chose {{my.favorite}}&lt;/div&gt;</span>
<span class="Comment">        &lt;/form&gt;</span>
<span class="Comment">      &lt;/doc:source&gt;</span>
<span class="Comment">      &lt;doc:scenario&gt;</span>
<span class="Comment">        it('should initialize to model', function() {</span>
<span class="Comment">          expect(binding('my.favorite')).toEqual('unicorns');</span>
<span class="Comment">        });</span>
<span class="Comment">        it('should bind the values to the inputs', function() {</span>
<span class="Comment">          input('my.favorite').select('pizza');</span>
<span class="Comment">          expect(binding('my.favorite')).toEqual('pizza');</span>
<span class="Comment">        });</span>
<span class="Comment">      &lt;/doc:scenario&gt;</span>
<span class="Comment">    &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngValueDirective = <span class="Identifier">function</span>() <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">{</span>
    priority: 100,
    compile: <span class="Identifier">function</span>(tpl, tplAttr) <span class="Identifier">{</span>
      <span class="Statement">if</span> (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) <span class="Identifier">{</span>
        <span class="Statement">return</span> <span class="Identifier">function</span> ngValueConstantLink(scope, elm, attr) <span class="Identifier">{</span>
          attr.$set(<span class="Constant">'value'</span>, scope.$eval(attr.ngValue));
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
        <span class="Statement">return</span> <span class="Identifier">function</span> ngValueLink(scope, elm, attr) <span class="Identifier">{</span>
          scope.$watch(attr.ngValue, <span class="Identifier">function</span> valueWatchAction(value) <span class="Identifier">{</span>
            attr.$set(<span class="Constant">'value'</span>, value);
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>;
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>;

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngBind</span>
<span class="Comment"> * @restrict AC</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngBind` attribute tells Angular to replace the text content of the specified HTML element</span>
<span class="Comment"> * with the value of a given expression, and to update the text content when the value of that</span>
<span class="Comment"> * expression changes.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Typically, you don't use `ngBind` directly, but instead you use the double curly markup like</span>
<span class="Comment"> * `{{ expression }}` which is similar but less verbose.</span>
<span class="Comment"> *</span>
<span class="Comment"> * It is preferrable to use `ngBind` instead of `{{ expression }}` when a template is momentarily</span>
<span class="Comment"> * displayed by the browser in its raw state before Angular compiles it. Since `ngBind` is an</span>
<span class="Comment"> * element attribute, it makes the bindings invisible to the user while the page is loading.</span>
<span class="Comment"> *</span>
<span class="Comment"> * An alternative solution to this problem would be using the</span>
<span class="Comment"> * {@link ng.directive:ngCloak ngCloak} directive.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngBind {@link guide/expression Expression} to evaluate.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">       &lt;script&gt;</span>
<span class="Comment">         function Ctrl($scope) {</span>
<span class="Comment">           $scope.name = 'Whirled';</span>
<span class="Comment">         }</span>
<span class="Comment">       &lt;/script&gt;</span>
<span class="Comment">       &lt;div ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">         Enter name: &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;br&gt;</span>
<span class="Comment">         Hello &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt;!</span>
<span class="Comment">       &lt;/div&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should check ng-bind', function() {</span>
<span class="Comment">         expect(using('.doc-example-live').binding('name')).toBe('Whirled');</span>
<span class="Comment">         using('.doc-example-live').input('name').enter('world');</span>
<span class="Comment">         expect(using('.doc-example-live').binding('name')).toBe('world');</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngBindDirective = ngDirective(<span class="Identifier">function</span>(scope, element, attr) <span class="Identifier">{</span>
  element.addClass(<span class="Constant">'ng-binding'</span>).data(<span class="Constant">'$binding'</span>, attr.ngBind);
  scope.$watch(attr.ngBind, <span class="Identifier">function</span> ngBindWatchAction(value) <span class="Identifier">{</span>
    <span class="Comment">// We are purposefully using == here rather than === because we want to</span>
    <span class="Comment">// catch when value is &quot;null or undefined&quot;</span>
    <span class="Comment">// jshint -W041</span>
    element.text(value == <span class="Statement">undefined</span> ? <span class="Constant">''</span> : value);
  <span class="Identifier">}</span>);
<span class="Identifier">}</span>);


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngBindTemplate</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngBindTemplate` directive specifies that the element</span>
<span class="Comment"> * text content should be replaced with the interpolation of the template</span>
<span class="Comment"> * in the `ngBindTemplate` attribute.</span>
<span class="Comment"> * Unlike `ngBind`, the `ngBindTemplate` can contain multiple `{{` `}}`</span>
<span class="Comment"> * expressions. This directive is needed since some HTML elements</span>
<span class="Comment"> * (such as TITLE and OPTION) cannot contain SPAN elements.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {string} ngBindTemplate template of form</span>
<span class="Comment"> *   &lt;tt&gt;{{&lt;/tt&gt; &lt;tt&gt;expression&lt;/tt&gt; &lt;tt&gt;}}&lt;/tt&gt; to eval.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * Try it here: enter text in text box and watch the greeting change.</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">       &lt;script&gt;</span>
<span class="Comment">         function Ctrl($scope) {</span>
<span class="Comment">           $scope.salutation = 'Hello';</span>
<span class="Comment">           $scope.name = 'World';</span>
<span class="Comment">         }</span>
<span class="Comment">       &lt;/script&gt;</span>
<span class="Comment">       &lt;div ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">        Salutation: &lt;input type=&quot;text&quot; ng-model=&quot;salutation&quot;&gt;&lt;br&gt;</span>
<span class="Comment">        Name: &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;br&gt;</span>
<span class="Comment">        &lt;pre ng-bind-template=&quot;{{salutation}} {{name}}!&quot;&gt;&lt;/pre&gt;</span>
<span class="Comment">       &lt;/div&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should check ng-bind', function() {</span>
<span class="Comment">         expect(using('.doc-example-live').binding('salutation')).</span>
<span class="Comment">           toBe('Hello');</span>
<span class="Comment">         expect(using('.doc-example-live').binding('name')).</span>
<span class="Comment">           toBe('World');</span>
<span class="Comment">         using('.doc-example-live').input('salutation').enter('Greetings');</span>
<span class="Comment">         using('.doc-example-live').input('name').enter('user');</span>
<span class="Comment">         expect(using('.doc-example-live').binding('salutation')).</span>
<span class="Comment">           toBe('Greetings');</span>
<span class="Comment">         expect(using('.doc-example-live').binding('name')).</span>
<span class="Comment">           toBe('user');</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngBindTemplateDirective = <span class="Identifier">[</span><span class="Constant">'$interpolate'</span>, <span class="Identifier">function</span>($interpolate) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">function</span>(scope, element, attr) <span class="Identifier">{</span>
    <span class="Comment">// </span><span class="Todo">TODO</span><span class="Comment">: move this to scenario runner</span>
    <span class="Identifier">var</span> interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
    element.addClass(<span class="Constant">'ng-binding'</span>).data(<span class="Constant">'$binding'</span>, interpolateFn);
    attr.$observe(<span class="Constant">'ngBindTemplate'</span>, <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
      element.text(value);
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>;
<span class="Identifier">}]</span>;


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngBindHtml</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Creates a binding that will innerHTML the result of evaluating the `expression` into the current</span>
<span class="Comment"> * element in a secure way.  By default, the innerHTML-ed content will be sanitized using the {@link</span>
<span class="Comment"> * ngSanitize.$sanitize $sanitize} service.  To utilize this functionality, ensure that `$sanitize`</span>
<span class="Comment"> * is available, for example, by including {@link ngSanitize} in your module's dependencies (not in</span>
<span class="Comment"> * core Angular.)  You may also bypass sanitization for values you know are safe. To do so, bind to</span>
<span class="Comment"> * an explicitly trusted value via {@link ng.$sce#methods_trustAsHtml $sce.trustAsHtml}.  See the example</span>
<span class="Comment"> * under {@link ng.$sce#Example Strict Contextual Escaping (SCE)}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Note: If a `$sanitize` service is unavailable and the bound value isn't explicitly trusted, you</span>
<span class="Comment"> * will have an exception (instead of an exploit.)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngBindHtml {@link guide/expression Expression} to evaluate.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   Try it here: enter text in text box and watch the greeting change.</span>
<span class="Comment"> </span>
<span class="Comment">   &lt;example module=&quot;ngBindHtmlExample&quot; deps=&quot;angular-sanitize.js&quot;&gt;</span>
<span class="Comment">     &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">       &lt;div ng-controller=&quot;ngBindHtmlCtrl&quot;&gt;</span>
<span class="Comment">        &lt;p ng-bind-html=&quot;myHTML&quot;&gt;&lt;/p&gt;</span>
<span class="Comment">       &lt;/div&gt;</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">     </span>
<span class="Comment">     &lt;file name=&quot;script.js&quot;&gt;</span>
<span class="Comment">       angular.module('ngBindHtmlExample', ['ngSanitize'])</span>

<span class="Comment">       .controller('ngBindHtmlCtrl', ['$scope', function ngBindHtmlCtrl($scope) {</span>
<span class="Comment">         $scope.myHTML =</span>
<span class="Comment">            'I am an &lt;code&gt;HTML&lt;/code&gt;string with &lt;a href=&quot;#&quot;&gt;links!&lt;/a&gt; and other &lt;em&gt;stuff&lt;/em&gt;';</span>
<span class="Comment">       }]);</span>
<span class="Comment">     &lt;/file&gt;</span>

<span class="Comment">     &lt;file name=&quot;scenario.js&quot;&gt;</span>
<span class="Comment">       it('should check ng-bind-html', function() {</span>
<span class="Comment">         expect(using('.doc-example-live').binding('myHTML')).</span>
<span class="Comment">           toBe(</span>
<span class="Comment">           'I am an &lt;code&gt;HTML&lt;/code&gt;string with &lt;a href=&quot;#&quot;&gt;links!&lt;/a&gt; and other &lt;em&gt;stuff&lt;/em&gt;'</span>
<span class="Comment">           );</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">   &lt;/example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngBindHtmlDirective = <span class="Identifier">[</span><span class="Constant">'$sce'</span>, <span class="Constant">'$parse'</span>, <span class="Identifier">function</span>($sce, $parse) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">function</span>(scope, element, attr) <span class="Identifier">{</span>
    element.addClass(<span class="Constant">'ng-binding'</span>).data(<span class="Constant">'$binding'</span>, attr.ngBindHtml);

    <span class="Identifier">var</span> parsed = $parse(attr.ngBindHtml);
    <span class="Identifier">function</span> getStringValue() <span class="Identifier">{</span> <span class="Statement">return</span> (parsed(scope) || <span class="Constant">''</span>).toString(); <span class="Identifier">}</span>

    scope.$watch(getStringValue, <span class="Identifier">function</span> ngBindHtmlWatchAction(value) <span class="Identifier">{</span>
      element.html($sce.getTrustedHtml(parsed(scope)) || <span class="Constant">''</span>);
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>;
<span class="Identifier">}]</span>;

<span class="Identifier">function</span> classDirective(name, selector) <span class="Identifier">{</span>
  name = <span class="Constant">'ngClass'</span> + name;
  <span class="Statement">return</span> <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">{</span>
      restrict: <span class="Constant">'AC'</span>,
      link: <span class="Identifier">function</span>(scope, element, attr) <span class="Identifier">{</span>
        <span class="Identifier">var</span> oldVal;

        scope.$watch(attr<span class="Identifier">[</span>name<span class="Identifier">]</span>, ngClassWatchAction, <span class="Constant">true</span>);

        attr.$observe(<span class="Constant">'class'</span>, <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
          ngClassWatchAction(scope.$eval(attr<span class="Identifier">[</span>name<span class="Identifier">]</span>));
        <span class="Identifier">}</span>);


        <span class="Statement">if</span> (name !== <span class="Constant">'ngClass'</span>) <span class="Identifier">{</span>
          scope.$watch(<span class="Constant">'$index'</span>, <span class="Identifier">function</span>($index, old$index) <span class="Identifier">{</span>
            <span class="Comment">// jshint bitwise: false</span>
            <span class="Identifier">var</span> mod = $index &amp; 1;
            <span class="Statement">if</span> (mod !== old$index &amp; 1) <span class="Identifier">{</span>
              <span class="Identifier">var</span> classes = flattenClasses(scope.$eval(attr<span class="Identifier">[</span>name<span class="Identifier">]</span>));
              mod === selector ?
                attr.$addClass(classes) :
                attr.$removeClass(classes);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>


        <span class="Identifier">function</span> ngClassWatchAction(newVal) <span class="Identifier">{</span>
          <span class="Statement">if</span> (selector === <span class="Constant">true</span> || scope.$index % 2 === selector) <span class="Identifier">{</span>
            <span class="Identifier">var</span> newClasses = flattenClasses(newVal || <span class="Constant">''</span>);
            <span class="Statement">if</span>(!oldVal) <span class="Identifier">{</span>
              attr.$addClass(newClasses);
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span>(!equals(newVal,oldVal)) <span class="Identifier">{</span>
              attr.$updateClass(newClasses, flattenClasses(oldVal));
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
          oldVal = copy(newVal);
        <span class="Identifier">}</span>


        <span class="Identifier">function</span> flattenClasses(classVal) <span class="Identifier">{</span>
          <span class="Statement">if</span>(isArray(classVal)) <span class="Identifier">{</span>
            <span class="Statement">return</span> classVal.join(<span class="Constant">' '</span>);
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (isObject(classVal)) <span class="Identifier">{</span>
            <span class="Identifier">var</span> classes = <span class="Identifier">[]</span>, i = 0;
            forEach(classVal, <span class="Identifier">function</span>(v, k) <span class="Identifier">{</span>
              <span class="Statement">if</span> (v) <span class="Identifier">{</span>
                classes.push(k);
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>);
            <span class="Statement">return</span> classes.join(<span class="Constant">' '</span>);
          <span class="Identifier">}</span>

          <span class="Statement">return</span> classVal;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>;
<span class="Identifier">}</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngClass</span>
<span class="Comment"> * @restrict AC</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngClass` directive allows you to dynamically set CSS classes on an HTML element by databinding</span>
<span class="Comment"> * an expression that represents all classes to be added.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The directive won't add duplicate classes if a particular class was already set.</span>
<span class="Comment"> *</span>
<span class="Comment"> * When the expression changes, the previously added classes are removed and only then the</span>
<span class="Comment"> * new classes are added.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @animations</span>
<span class="Comment"> * add - happens just before the class is applied to the element</span>
<span class="Comment"> * remove - happens just before the class is removed from the element</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngClass {@link guide/expression Expression} to eval. The result</span>
<span class="Comment"> *   of the evaluation can be a string representing space delimited class</span>
<span class="Comment"> *   names, an array, or a map of class names to boolean values. In the case of a map, the</span>
<span class="Comment"> *   names of the properties whose values are truthy will be added as css classes to the</span>
<span class="Comment"> *   element.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example Example that demonstrates basic bindings via ngClass directive.</span>
<span class="Comment">   &lt;example&gt;</span>
<span class="Comment">     &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">       &lt;p ng-class=&quot;{strike: deleted, bold: important, red: error}&quot;&gt;Map Syntax Example&lt;/p&gt;</span>
<span class="Comment">       &lt;input type=&quot;checkbox&quot; ng-model=&quot;deleted&quot;&gt; deleted (apply &quot;strike&quot; class)&lt;br&gt;</span>
<span class="Comment">       &lt;input type=&quot;checkbox&quot; ng-model=&quot;important&quot;&gt; important (apply &quot;bold&quot; class)&lt;br&gt;</span>
<span class="Comment">       &lt;input type=&quot;checkbox&quot; ng-model=&quot;error&quot;&gt; error (apply &quot;red&quot; class)</span>
<span class="Comment">       &lt;hr&gt;</span>
<span class="Comment">       &lt;p ng-class=&quot;style&quot;&gt;Using String Syntax&lt;/p&gt;</span>
<span class="Comment">       &lt;input type=&quot;text&quot; ng-model=&quot;style&quot; placeholder=&quot;Type: bold strike red&quot;&gt;</span>
<span class="Comment">       &lt;hr&gt;</span>
<span class="Comment">       &lt;p ng-class=&quot;[style1, style2, style3]&quot;&gt;Using Array Syntax&lt;/p&gt;</span>
<span class="Comment">       &lt;input ng-model=&quot;style1&quot; placeholder=&quot;Type: bold, strike or red&quot;&gt;&lt;br&gt;</span>
<span class="Comment">       &lt;input ng-model=&quot;style2&quot; placeholder=&quot;Type: bold, strike or red&quot;&gt;&lt;br&gt;</span>
<span class="Comment">       &lt;input ng-model=&quot;style3&quot; placeholder=&quot;Type: bold, strike or red&quot;&gt;&lt;br&gt;</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">     &lt;file name=&quot;style.css&quot;&gt;</span>
<span class="Comment">       .strike {</span>
<span class="Comment">         text-decoration: line-through;</span>
<span class="Comment">       }</span>
<span class="Comment">       .bold {</span>
<span class="Comment">           font-weight: bold;</span>
<span class="Comment">       }</span>
<span class="Comment">       .red {</span>
<span class="Comment">           color: red;</span>
<span class="Comment">       }</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">     &lt;file name=&quot;scenario.js&quot;&gt;</span>
<span class="Comment">       it('should let you toggle the class', function() {</span>

<span class="Comment">         expect(element('.doc-example-live p:first').prop('className')).not().toMatch(/bold/);</span>
<span class="Comment">         expect(element('.doc-example-live p:first').prop('className')).not().toMatch(/red/);</span>

<span class="Comment">         input('important').check();</span>
<span class="Comment">         expect(element('.doc-example-live p:first').prop('className')).toMatch(/bold/);</span>

<span class="Comment">         input('error').check();</span>
<span class="Comment">         expect(element('.doc-example-live p:first').prop('className')).toMatch(/red/);</span>
<span class="Comment">       });</span>

<span class="Comment">       it('should let you toggle string example', function() {</span>
<span class="Comment">         expect(element('.doc-example-live p:nth-of-type(2)').prop('className')).toBe('');</span>
<span class="Comment">         input('style').enter('red');</span>
<span class="Comment">         expect(element('.doc-example-live p:nth-of-type(2)').prop('className')).toBe('red');</span>
<span class="Comment">       });</span>

<span class="Comment">       it('array example should have 3 classes', function() {</span>
<span class="Comment">         expect(element('.doc-example-live p:last').prop('className')).toBe('');</span>
<span class="Comment">         input('style1').enter('bold');</span>
<span class="Comment">         input('style2').enter('strike');</span>
<span class="Comment">         input('style3').enter('red');</span>
<span class="Comment">         expect(element('.doc-example-live p:last').prop('className')).toBe('bold strike red');</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">   &lt;/example&gt;</span>

<span class="Comment">   ## Animations</span>

<span class="Comment">   The example below demonstrates how to perform animations using ngClass.</span>

<span class="Comment">   &lt;example animations=&quot;true&quot;&gt;</span>
<span class="Comment">     &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">      &lt;input type=&quot;button&quot; value=&quot;set&quot; ng-click=&quot;myVar='my-class'&quot;&gt;</span>
<span class="Comment">      &lt;input type=&quot;button&quot; value=&quot;clear&quot; ng-click=&quot;myVar=''&quot;&gt;</span>
<span class="Comment">      &lt;br&gt;</span>
<span class="Comment">      &lt;span class=&quot;base-class&quot; ng-class=&quot;myVar&quot;&gt;Sample Text&lt;/span&gt;</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">     &lt;file name=&quot;style.css&quot;&gt;</span>
<span class="Comment">       .base-class {</span>
<span class="Comment">         -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;</span>
<span class="Comment">         transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;</span>
<span class="Comment">       }</span>

<span class="Comment">       .base-class.my-class {</span>
<span class="Comment">         color: red;</span>
<span class="Comment">         font-size:3em;</span>
<span class="Comment">       }</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">     &lt;file name=&quot;scenario.js&quot;&gt;</span>
<span class="Comment">       it('should check ng-class', function() {</span>
<span class="Comment">         expect(element('.doc-example-live span').prop('className')).not().</span>
<span class="Comment">           toMatch(/my-class/);</span>

<span class="Comment">         using('.doc-example-live').element(':button:first').click();</span>

<span class="Comment">         expect(element('.doc-example-live span').prop('className')).</span>
<span class="Comment">           toMatch(/my-class/);</span>

<span class="Comment">         using('.doc-example-live').element(':button:last').click();</span>

<span class="Comment">         expect(element('.doc-example-live span').prop('className')).not().</span>
<span class="Comment">           toMatch(/my-class/);</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">   &lt;/example&gt;</span>


<span class="Comment">   ## ngClass and pre-existing CSS3 Transitions/Animations</span>
<span class="Comment">   The ngClass directive still supports CSS3 Transitions/Animations even if they do not follow the ngAnimate CSS naming structure.</span>
<span class="Comment">   Upon animation ngAnimate will apply supplementary CSS classes to track the start and end of an animation, but this will not hinder</span>
<span class="Comment">   any pre-existing CSS transitions already on the element. To get an idea of what happens during a class-based animation, be sure</span>
<span class="Comment">   to view the step by step details of {@link ngAnimate.$animate#methods_addclass $animate.addClass} and</span>
<span class="Comment">   {@link ngAnimate.$animate#methods_removeclass $animate.removeClass}.</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngClassDirective = classDirective(<span class="Constant">''</span>, <span class="Constant">true</span>);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngClassOdd</span>
<span class="Comment"> * @restrict AC</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngClassOdd` and `ngClassEven` directives work exactly as</span>
<span class="Comment"> * {@link ng.directive:ngClass ngClass}, except they work in</span>
<span class="Comment"> * conjunction with `ngRepeat` and take effect only on odd (even) rows.</span>
<span class="Comment"> *</span>
<span class="Comment"> * This directive can be applied only within the scope of an</span>
<span class="Comment"> * {@link ng.directive:ngRepeat ngRepeat}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngClassOdd {@link guide/expression Expression} to eval. The result</span>
<span class="Comment"> *   of the evaluation can be a string representing space delimited class names or an array.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;example&gt;</span>
<span class="Comment">     &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">        &lt;ol ng-init=&quot;names=['John', 'Mary', 'Cate', 'Suz']&quot;&gt;</span>
<span class="Comment">          &lt;li ng-repeat=&quot;name in names&quot;&gt;</span>
<span class="Comment">           &lt;span ng-class-odd=&quot;'odd'&quot; ng-class-even=&quot;'even'&quot;&gt;</span>
<span class="Comment">             {{name}}</span>
<span class="Comment">           &lt;/span&gt;</span>
<span class="Comment">          &lt;/li&gt;</span>
<span class="Comment">        &lt;/ol&gt;</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">     &lt;file name=&quot;style.css&quot;&gt;</span>
<span class="Comment">       .odd {</span>
<span class="Comment">         color: red;</span>
<span class="Comment">       }</span>
<span class="Comment">       .even {</span>
<span class="Comment">         color: blue;</span>
<span class="Comment">       }</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">     &lt;file name=&quot;scenario.js&quot;&gt;</span>
<span class="Comment">       it('should check ng-class-odd and ng-class-even', function() {</span>
<span class="Comment">         expect(element('.doc-example-live li:first span').prop('className')).</span>
<span class="Comment">           toMatch(/odd/);</span>
<span class="Comment">         expect(element('.doc-example-live li:last span').prop('className')).</span>
<span class="Comment">           toMatch(/even/);</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">   &lt;/example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngClassOddDirective = classDirective(<span class="Constant">'Odd'</span>, 0);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngClassEven</span>
<span class="Comment"> * @restrict AC</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngClassOdd` and `ngClassEven` directives work exactly as</span>
<span class="Comment"> * {@link ng.directive:ngClass ngClass}, except they work in</span>
<span class="Comment"> * conjunction with `ngRepeat` and take effect only on odd (even) rows.</span>
<span class="Comment"> *</span>
<span class="Comment"> * This directive can be applied only within the scope of an</span>
<span class="Comment"> * {@link ng.directive:ngRepeat ngRepeat}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngClassEven {@link guide/expression Expression} to eval. The</span>
<span class="Comment"> *   result of the evaluation can be a string representing space delimited class names or an array.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;example&gt;</span>
<span class="Comment">     &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">        &lt;ol ng-init=&quot;names=['John', 'Mary', 'Cate', 'Suz']&quot;&gt;</span>
<span class="Comment">          &lt;li ng-repeat=&quot;name in names&quot;&gt;</span>
<span class="Comment">           &lt;span ng-class-odd=&quot;'odd'&quot; ng-class-even=&quot;'even'&quot;&gt;</span>
<span class="Comment">             {{name}} &amp;nbsp; &amp;nbsp; &amp;nbsp;</span>
<span class="Comment">           &lt;/span&gt;</span>
<span class="Comment">          &lt;/li&gt;</span>
<span class="Comment">        &lt;/ol&gt;</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">     &lt;file name=&quot;style.css&quot;&gt;</span>
<span class="Comment">       .odd {</span>
<span class="Comment">         color: red;</span>
<span class="Comment">       }</span>
<span class="Comment">       .even {</span>
<span class="Comment">         color: blue;</span>
<span class="Comment">       }</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">     &lt;file name=&quot;scenario.js&quot;&gt;</span>
<span class="Comment">       it('should check ng-class-odd and ng-class-even', function() {</span>
<span class="Comment">         expect(element('.doc-example-live li:first span').prop('className')).</span>
<span class="Comment">           toMatch(/odd/);</span>
<span class="Comment">         expect(element('.doc-example-live li:last span').prop('className')).</span>
<span class="Comment">           toMatch(/even/);</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">   &lt;/example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngClassEvenDirective = classDirective(<span class="Constant">'Even'</span>, 1);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngCloak</span>
<span class="Comment"> * @restrict AC</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngCloak` directive is used to prevent the Angular html template from being briefly</span>
<span class="Comment"> * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this</span>
<span class="Comment"> * directive to avoid the undesirable flicker effect caused by the html template display.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The directive can be applied to the `&lt;body&gt;` element, but the preferred usage is to apply</span>
<span class="Comment"> * multiple `ngCloak` directives to small portions of the page to permit progressive rendering</span>
<span class="Comment"> * of the browser view.</span>
<span class="Comment"> *</span>
<span class="Comment"> * `ngCloak` works in cooperation with the following css rule embedded within `angular.js` and</span>
<span class="Comment"> * `angular.min.js`.</span>
<span class="Comment"> * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {</span>
<span class="Comment"> *   display: none !important;</span>
<span class="Comment"> * }</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * When this css rule is loaded by the browser, all html elements (including their children) that</span>
<span class="Comment"> * are tagged with the `ngCloak` directive are hidden. When Angular encounters this directive</span>
<span class="Comment"> * during the compilation of the template it deletes the `ngCloak` element attribute, making</span>
<span class="Comment"> * the compiled element visible.</span>
<span class="Comment"> *</span>
<span class="Comment"> * For the best result, the `angular.js` script must be loaded in the head section of the html</span>
<span class="Comment"> * document; alternatively, the css rule above must be included in the external stylesheet of the</span>
<span class="Comment"> * application.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Legacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they</span>
<span class="Comment"> * cannot match the `[ng\:cloak]` selector. To work around this limitation, you must add the css</span>
<span class="Comment"> * class `ngCloak` in addition to the `ngCloak` directive as shown in the example below.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">        &lt;div id=&quot;template1&quot; ng-cloak&gt;{{ 'hello' }}&lt;/div&gt;</span>
<span class="Comment">        &lt;div id=&quot;template2&quot; ng-cloak class=&quot;ng-cloak&quot;&gt;{{ 'hello IE7' }}&lt;/div&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should remove the template directive and css class', function() {</span>
<span class="Comment">         expect(element('.doc-example-live #template1').attr('ng-cloak')).</span>
<span class="Comment">           not().toBeDefined();</span>
<span class="Comment">         expect(element('.doc-example-live #template2').attr('ng-cloak')).</span>
<span class="Comment">           not().toBeDefined();</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngCloakDirective = ngDirective(<span class="Identifier">{</span>
  compile: <span class="Identifier">function</span>(element, attr) <span class="Identifier">{</span>
    attr.$set(<span class="Constant">'ngCloak'</span>, <span class="Statement">undefined</span>);
    element.removeClass(<span class="Constant">'ng-cloak'</span>);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngController</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngController` directive attaches a controller class to the view. This is a key aspect of how angular</span>
<span class="Comment"> * supports the principles behind the Model-View-Controller design pattern.</span>
<span class="Comment"> *</span>
<span class="Comment"> * MVC components in angular:</span>
<span class="Comment"> *</span>
<span class="Comment"> * * Model — The Model is scope properties; scopes are attached to the DOM where scope properties</span>
<span class="Comment"> *   are accessed through bindings.</span>
<span class="Comment"> * * View — The template (HTML with data bindings) that is rendered into the View.</span>
<span class="Comment"> * * Controller — The `ngController` directive specifies a Controller class; the class contains business</span>
<span class="Comment"> *   logic behind the application to decorate the scope with functions and values</span>
<span class="Comment"> *</span>
<span class="Comment"> * Note that you can also attach controllers to the DOM by declaring it in a route definition</span>
<span class="Comment"> * via the {@link ngRoute.$route $route} service. A common mistake is to declare the controller</span>
<span class="Comment"> * again using `ng-controller` in the template itself.  This will cause the controller to be attached</span>
<span class="Comment"> * and executed twice.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @scope</span>
<span class="Comment"> * @param {expression} ngController Name of a globally accessible constructor function or an</span>
<span class="Comment"> *     {@link guide/expression expression} that on the current scope evaluates to a</span>
<span class="Comment"> *     constructor function. The controller instance can be published into a scope property</span>
<span class="Comment"> *     by specifying `as propertyName`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * Here is a simple form for editing user contact information. Adding, removing, clearing, and</span>
<span class="Comment"> * greeting are methods declared on the controller (see source tab). These methods can</span>
<span class="Comment"> * easily be called from the angular markup. Notice that the scope becomes the `this` for the</span>
<span class="Comment"> * controller's instance. This allows for easy access to the view data from the controller. Also</span>
<span class="Comment"> * notice that any changes to the data are automatically reflected in the View without the need</span>
<span class="Comment"> * for a manual update. The example is shown in two different declaration styles you may use</span>
<span class="Comment"> * according to preference.</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">      &lt;script&gt;</span>
<span class="Comment">        function SettingsController1() {</span>
<span class="Comment">          this.name = &quot;John Smith&quot;;</span>
<span class="Comment">          this.contacts = [</span>
<span class="Comment">            {type: 'phone', value: '408 555 1212'},</span>
<span class="Comment">            {type: 'email', value: 'john.smith@example.org'} ];</span>
<span class="Comment">          };</span>

<span class="Comment">        SettingsController1.prototype.greet = function() {</span>
<span class="Comment">          alert(this.name);</span>
<span class="Comment">        };</span>

<span class="Comment">        SettingsController1.prototype.addContact = function() {</span>
<span class="Comment">          this.contacts.push({type: 'email', value: 'yourname@example.org'});</span>
<span class="Comment">        };</span>

<span class="Comment">        SettingsController1.prototype.removeContact = function(contactToRemove) {</span>
<span class="Comment">         var index = this.contacts.indexOf(contactToRemove);</span>
<span class="Comment">          this.contacts.splice(index, 1);</span>
<span class="Comment">        };</span>

<span class="Comment">        SettingsController1.prototype.clearContact = function(contact) {</span>
<span class="Comment">          contact.type = 'phone';</span>
<span class="Comment">          contact.value = '';</span>
<span class="Comment">        };</span>
<span class="Comment">      &lt;/script&gt;</span>
<span class="Comment">      &lt;div id=&quot;ctrl-as-exmpl&quot; ng-controller=&quot;SettingsController1 as settings&quot;&gt;</span>
<span class="Comment">        Name: &lt;input type=&quot;text&quot; ng-model=&quot;settings.name&quot;/&gt;</span>
<span class="Comment">        [ &lt;a href=&quot;&quot; ng-click=&quot;settings.greet()&quot;&gt;greet&lt;/a&gt; ]&lt;br/&gt;</span>
<span class="Comment">        Contact:</span>
<span class="Comment">        &lt;ul&gt;</span>
<span class="Comment">          &lt;li ng-repeat=&quot;contact in settings.contacts&quot;&gt;</span>
<span class="Comment">            &lt;select ng-model=&quot;contact.type&quot;&gt;</span>
<span class="Comment">               &lt;option&gt;phone&lt;/option&gt;</span>
<span class="Comment">               &lt;option&gt;email&lt;/option&gt;</span>
<span class="Comment">            &lt;/select&gt;</span>
<span class="Comment">            &lt;input type=&quot;text&quot; ng-model=&quot;contact.value&quot;/&gt;</span>
<span class="Comment">            [ &lt;a href=&quot;&quot; ng-click=&quot;settings.clearContact(contact)&quot;&gt;clear&lt;/a&gt;</span>
<span class="Comment">            | &lt;a href=&quot;&quot; ng-click=&quot;settings.removeContact(contact)&quot;&gt;X&lt;/a&gt; ]</span>
<span class="Comment">          &lt;/li&gt;</span>
<span class="Comment">          &lt;li&gt;[ &lt;a href=&quot;&quot; ng-click=&quot;settings.addContact()&quot;&gt;add&lt;/a&gt; ]&lt;/li&gt;</span>
<span class="Comment">       &lt;/ul&gt;</span>
<span class="Comment">      &lt;/div&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should check controller as', function() {</span>
<span class="Comment">         expect(element('#ctrl-as-exmpl&gt;:input').val()).toBe('John Smith');</span>
<span class="Comment">         expect(element('#ctrl-as-exmpl li:nth-child(1) input').val())</span>
<span class="Comment">           .toBe('408 555 1212');</span>
<span class="Comment">         expect(element('#ctrl-as-exmpl li:nth-child(2) input').val())</span>
<span class="Comment">           .toBe('john.smith@example.org');</span>

<span class="Comment">         element('#ctrl-as-exmpl li:first a:contains(&quot;clear&quot;)').click();</span>
<span class="Comment">         expect(element('#ctrl-as-exmpl li:first input').val()).toBe('');</span>

<span class="Comment">         element('#ctrl-as-exmpl li:last a:contains(&quot;add&quot;)').click();</span>
<span class="Comment">         expect(element('#ctrl-as-exmpl li:nth-child(3) input').val())</span>
<span class="Comment">           .toBe('yourname@example.org');</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment">    &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">      &lt;script&gt;</span>
<span class="Comment">        function SettingsController2($scope) {</span>
<span class="Comment">          $scope.name = &quot;John Smith&quot;;</span>
<span class="Comment">          $scope.contacts = [</span>
<span class="Comment">            {type:'phone', value:'408 555 1212'},</span>
<span class="Comment">            {type:'email', value:'john.smith@example.org'} ];</span>

<span class="Comment">          $scope.greet = function() {</span>
<span class="Comment">           alert(this.name);</span>
<span class="Comment">          };</span>

<span class="Comment">          $scope.addContact = function() {</span>
<span class="Comment">           this.contacts.push({type:'email', value:'yourname@example.org'});</span>
<span class="Comment">          };</span>

<span class="Comment">          $scope.removeContact = function(contactToRemove) {</span>
<span class="Comment">           var index = this.contacts.indexOf(contactToRemove);</span>
<span class="Comment">           this.contacts.splice(index, 1);</span>
<span class="Comment">          };</span>

<span class="Comment">          $scope.clearContact = function(contact) {</span>
<span class="Comment">           contact.type = 'phone';</span>
<span class="Comment">           contact.value = '';</span>
<span class="Comment">          };</span>
<span class="Comment">        }</span>
<span class="Comment">      &lt;/script&gt;</span>
<span class="Comment">      &lt;div id=&quot;ctrl-exmpl&quot; ng-controller=&quot;SettingsController2&quot;&gt;</span>
<span class="Comment">        Name: &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;/&gt;</span>
<span class="Comment">        [ &lt;a href=&quot;&quot; ng-click=&quot;greet()&quot;&gt;greet&lt;/a&gt; ]&lt;br/&gt;</span>
<span class="Comment">        Contact:</span>
<span class="Comment">        &lt;ul&gt;</span>
<span class="Comment">          &lt;li ng-repeat=&quot;contact in contacts&quot;&gt;</span>
<span class="Comment">            &lt;select ng-model=&quot;contact.type&quot;&gt;</span>
<span class="Comment">               &lt;option&gt;phone&lt;/option&gt;</span>
<span class="Comment">               &lt;option&gt;email&lt;/option&gt;</span>
<span class="Comment">            &lt;/select&gt;</span>
<span class="Comment">            &lt;input type=&quot;text&quot; ng-model=&quot;contact.value&quot;/&gt;</span>
<span class="Comment">            [ &lt;a href=&quot;&quot; ng-click=&quot;clearContact(contact)&quot;&gt;clear&lt;/a&gt;</span>
<span class="Comment">            | &lt;a href=&quot;&quot; ng-click=&quot;removeContact(contact)&quot;&gt;X&lt;/a&gt; ]</span>
<span class="Comment">          &lt;/li&gt;</span>
<span class="Comment">          &lt;li&gt;[ &lt;a href=&quot;&quot; ng-click=&quot;addContact()&quot;&gt;add&lt;/a&gt; ]&lt;/li&gt;</span>
<span class="Comment">       &lt;/ul&gt;</span>
<span class="Comment">      &lt;/div&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should check controller', function() {</span>
<span class="Comment">         expect(element('#ctrl-exmpl&gt;:input').val()).toBe('John Smith');</span>
<span class="Comment">         expect(element('#ctrl-exmpl li:nth-child(1) input').val())</span>
<span class="Comment">           .toBe('408 555 1212');</span>
<span class="Comment">         expect(element('#ctrl-exmpl li:nth-child(2) input').val())</span>
<span class="Comment">           .toBe('john.smith@example.org');</span>

<span class="Comment">         element('#ctrl-exmpl li:first a:contains(&quot;clear&quot;)').click();</span>
<span class="Comment">         expect(element('#ctrl-exmpl li:first input').val()).toBe('');</span>

<span class="Comment">         element('#ctrl-exmpl li:last a:contains(&quot;add&quot;)').click();</span>
<span class="Comment">         expect(element('#ctrl-exmpl li:nth-child(3) input').val())</span>
<span class="Comment">           .toBe('yourname@example.org');</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>

<span class="Comment"> */</span>
<span class="Identifier">var</span> ngControllerDirective = <span class="Identifier">[</span><span class="Identifier">function</span>() <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">{</span>
    scope: <span class="Constant">true</span>,
    controller: <span class="Constant">'@'</span>,
    priority: 500
  <span class="Identifier">}</span>;
<span class="Identifier">}]</span>;

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngCsp</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element html</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Enables [CSP (Content Security Policy)](<a href="https://developer.mozilla.org/en/Security/CSP)">https://developer.mozilla.org/en/Security/CSP)</a> support.</span>
<span class="Comment"> *</span>
<span class="Comment"> * This is necessary when developing things like Google Chrome Extensions.</span>
<span class="Comment"> *</span>
<span class="Comment"> * CSP forbids apps to use `eval` or `Function(string)` generated functions (among other things).</span>
<span class="Comment"> * For us to be compatible, we just need to implement the &quot;getterFn&quot; in $parse without violating</span>
<span class="Comment"> * any of these restrictions.</span>
<span class="Comment"> *</span>
<span class="Comment"> * AngularJS uses `Function(string)` generated functions as a speed optimization. Applying the `ngCsp`</span>
<span class="Comment"> * directive will cause Angular to use CSP compatibility mode. When this mode is on AngularJS will</span>
<span class="Comment"> * evaluate all expressions up to 30% slower than in non-CSP mode, but no security violations will</span>
<span class="Comment"> * be raised.</span>
<span class="Comment"> *</span>
<span class="Comment"> * CSP forbids JavaScript to inline stylesheet rules. In non CSP mode Angular automatically</span>
<span class="Comment"> * includes some CSS rules (e.g. {@link ng.directive:ngCloak ngCloak}).</span>
<span class="Comment"> * To make those directives work in CSP mode, include the `angular-csp.css` manually.</span>
<span class="Comment"> *</span>
<span class="Comment"> * In order to use this feature put the `ngCsp` directive on the root element of the application.</span>
<span class="Comment"> *</span>
<span class="Comment"> * *Note: This directive is only available in the `ng-csp` and `data-ng-csp` attribute form.*</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * This example shows how to apply the `ngCsp` directive to the `html` tag.</span>
<span class="Comment">   &lt;pre&gt;</span>
<span class="Comment">     &lt;!doctype html&gt;</span>
<span class="Comment">     &lt;html ng-app ng-csp&gt;</span>
<span class="Comment">     ...</span>
<span class="Comment">     ...</span>
<span class="Comment">     &lt;/html&gt;</span>
<span class="Comment">   &lt;/pre&gt;</span>
<span class="Comment"> */</span>

<span class="Comment">// ngCsp is not implemented as a proper directive any more, because we need it be processed while we bootstrap</span>
<span class="Comment">// the system (before $parse is instantiated), for this reason we just have a csp() fn that looks for ng-csp attribute</span>
<span class="Comment">// anywhere in the current doc</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngClick</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The ngClick directive allows you to specify custom behavior when</span>
<span class="Comment"> * an element is clicked.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngClick {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * click. (Event object is available as `$event`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">      &lt;button ng-click=&quot;count = count + 1&quot; ng-init=&quot;count=0&quot;&gt;</span>
<span class="Comment">        Increment</span>
<span class="Comment">      &lt;/button&gt;</span>
<span class="Comment">      count: {{count}}</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should check ng-click', function() {</span>
<span class="Comment">         expect(binding('count')).toBe('0');</span>
<span class="Comment">         element('.doc-example-live :button').click();</span>
<span class="Comment">         expect(binding('count')).toBe('1');</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Comment">/*</span>
<span class="Comment"> * A directive that allows creation of custom onclick handlers that are defined as angular</span>
<span class="Comment"> * expressions and are compiled and executed within the current scope.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Events that are handled via these handler are always configured not to propagate further.</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngEventDirectives = <span class="Identifier">{}</span>;
forEach(
  <span class="Constant">'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'</span>.split(<span class="Constant">' '</span>),
  <span class="Identifier">function</span>(name) <span class="Identifier">{</span>
    <span class="Identifier">var</span> directiveName = directiveNormalize(<span class="Constant">'ng-'</span> + name);
    ngEventDirectives<span class="Identifier">[</span>directiveName<span class="Identifier">]</span> = <span class="Identifier">[</span><span class="Constant">'$parse'</span>, <span class="Identifier">function</span>($parse) <span class="Identifier">{</span>
      <span class="Statement">return</span> <span class="Identifier">{</span>
        compile: <span class="Identifier">function</span>($element, attr) <span class="Identifier">{</span>
          <span class="Identifier">var</span> fn = $parse(attr<span class="Identifier">[</span>directiveName<span class="Identifier">]</span>);
          <span class="Statement">return</span> <span class="Identifier">function</span>(scope, element, attr) <span class="Identifier">{</span>
            element.on(lowercase(name), <span class="Identifier">function</span>(<span class="Statement">event</span>) <span class="Identifier">{</span>
              scope.$apply(<span class="Identifier">function</span>() <span class="Identifier">{</span>
                fn(scope, <span class="Identifier">{</span>$<span class="Statement">event</span>:<span class="Statement">event</span><span class="Identifier">}</span>);
              <span class="Identifier">}</span>);
            <span class="Identifier">}</span>);
          <span class="Identifier">}</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>;
    <span class="Identifier">}]</span>;
  <span class="Identifier">}</span>
);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngDblclick</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngDblclick` directive allows you to specify custom behavior on a dblclick event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * a dblclick. (The Event object is available as `$event`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngMousedown</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The ngMousedown directive allows you to specify custom behavior on mousedown event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * mousedown. (Event object is available as `$event`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngMouseup</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Specify custom behavior on mouseup event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * mouseup. (Event object is available as `$event`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngMouseover</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Specify custom behavior on mouseover event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * mouseover. (Event object is available as `$event`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngMouseenter</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Specify custom behavior on mouseenter event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * mouseenter. (Event object is available as `$event`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngMouseleave</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Specify custom behavior on mouseleave event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * mouseleave. (Event object is available as `$event`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngMousemove</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Specify custom behavior on mousemove event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * mousemove. (Event object is available as `$event`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngKeydown</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Specify custom behavior on keydown event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * keydown. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngKeyup</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Specify custom behavior on keyup event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * keyup. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngKeypress</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Specify custom behavior on keypress event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * keypress. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngSubmit</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Enables binding angular expressions to onsubmit events.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Additionally it prevents the default action (which for form means sending the request to the</span>
<span class="Comment"> * server and reloading the current page) **but only if the form does not contain an `action`</span>
<span class="Comment"> * attribute**.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element form</span>
<span class="Comment"> * @param {expression} ngSubmit {@link guide/expression Expression} to eval. (Event object is available as `$event`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">      &lt;script&gt;</span>
<span class="Comment">        function Ctrl($scope) {</span>
<span class="Comment">          $scope.list = [];</span>
<span class="Comment">          $scope.text = 'hello';</span>
<span class="Comment">          $scope.submit = function() {</span>
<span class="Comment">            if (this.text) {</span>
<span class="Comment">              this.list.push(this.text);</span>
<span class="Comment">              this.text = '';</span>
<span class="Comment">            }</span>
<span class="Comment">          };</span>
<span class="Comment">        }</span>
<span class="Comment">      &lt;/script&gt;</span>
<span class="Comment">      &lt;form ng-submit=&quot;submit()&quot; ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">        Enter text and hit enter:</span>
<span class="Comment">        &lt;input type=&quot;text&quot; ng-model=&quot;text&quot; name=&quot;text&quot; /&gt;</span>
<span class="Comment">        &lt;input type=&quot;submit&quot; id=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span>
<span class="Comment">        &lt;pre&gt;list={{list}}&lt;/pre&gt;</span>
<span class="Comment">      &lt;/form&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should check ng-submit', function() {</span>
<span class="Comment">         expect(binding('list')).toBe('[]');</span>
<span class="Comment">         element('.doc-example-live #submit').click();</span>
<span class="Comment">         expect(binding('list')).toBe('[&quot;hello&quot;]');</span>
<span class="Comment">         expect(input('text').val()).toBe('');</span>
<span class="Comment">       });</span>
<span class="Comment">       it('should ignore empty strings', function() {</span>
<span class="Comment">         expect(binding('list')).toBe('[]');</span>
<span class="Comment">         element('.doc-example-live #submit').click();</span>
<span class="Comment">         element('.doc-example-live #submit').click();</span>
<span class="Comment">         expect(binding('list')).toBe('[&quot;hello&quot;]');</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngFocus</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Specify custom behavior on focus event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element window, input, select, textarea, a</span>
<span class="Comment"> * @param {expression} ngFocus {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * focus. (Event object is available as `$event`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngBlur</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Specify custom behavior on blur event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element window, input, select, textarea, a</span>
<span class="Comment"> * @param {expression} ngBlur {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * blur. (Event object is available as `$event`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngCopy</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Specify custom behavior on copy event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element window, input, select, textarea, a</span>
<span class="Comment"> * @param {expression} ngCopy {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * copy. (Event object is available as `$event`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngCut</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Specify custom behavior on cut event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element window, input, select, textarea, a</span>
<span class="Comment"> * @param {expression} ngCut {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * cut. (Event object is available as `$event`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngPaste</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Specify custom behavior on paste event.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element window, input, select, textarea, a</span>
<span class="Comment"> * @param {expression} ngPaste {@link guide/expression Expression} to evaluate upon</span>
<span class="Comment"> * paste. (Event object is available as `$event`)</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * See {@link ng.directive:ngClick ngClick}</span>
<span class="Comment"> */</span>

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngIf</span>
<span class="Comment"> * @restrict A</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngIf` directive removes or recreates a portion of the DOM tree based on an</span>
<span class="Comment"> * {expression}. If the expression assigned to `ngIf` evaluates to a false</span>
<span class="Comment"> * value then the element is removed from the DOM, otherwise a clone of the</span>
<span class="Comment"> * element is reinserted into the DOM.</span>
<span class="Comment"> *</span>
<span class="Comment"> * `ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely removes and recreates the</span>
<span class="Comment"> * element in the DOM rather than changing its visibility via the `display` css property.  A common</span>
<span class="Comment"> * case when this difference is significant is when using css selectors that rely on an element's</span>
<span class="Comment"> * position within the DOM, such as the `:first-child` or `:last-child` pseudo-classes.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Note that when an element is removed using `ngIf` its scope is destroyed and a new scope</span>
<span class="Comment"> * is created when the element is restored.  The scope created within `ngIf` inherits from</span>
<span class="Comment"> * its parent scope using</span>
<span class="Comment"> * {@link <a href="https://github.com/angular/angular.js/wiki/The-Nuances-of-Scope-Prototypal-Inheritance">https://github.com/angular/angular.js/wiki/The-Nuances-of-Scope-Prototypal-Inheritance</a> prototypal inheritance}.</span>
<span class="Comment"> * An important implication of this is if `ngModel` is used within `ngIf` to bind to</span>
<span class="Comment"> * a javascript primitive defined in the parent scope. In this case any modifications made to the</span>
<span class="Comment"> * variable within the child scope will override (hide) the value in the parent scope.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Also, `ngIf` recreates elements using their compiled state. An example of this behavior</span>
<span class="Comment"> * is if an element's class attribute is directly modified after it's compiled, using something like</span>
<span class="Comment"> * jQuery's `.addClass()` method, and the element is later removed. When `ngIf` recreates the element</span>
<span class="Comment"> * the added class will be lost because the original compiled state is used to regenerate the element.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Additionally, you can provide animations via the `ngAnimate` module to animate the `enter`</span>
<span class="Comment"> * and `leave` effects.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @animations</span>
<span class="Comment"> * enter - happens just after the ngIf contents change and a new DOM element is created and injected into the ngIf container</span>
<span class="Comment"> * leave - happens just before the ngIf contents are removed from the DOM</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @scope</span>
<span class="Comment"> * @priority 600</span>
<span class="Comment"> * @param {expression} ngIf If the {@link guide/expression expression} is falsy then</span>
<span class="Comment"> *     the element is removed from the DOM tree. If it is truthy a copy of the compiled</span>
<span class="Comment"> *     element is added to the DOM tree.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">  &lt;example animations=&quot;true&quot;&gt;</span>
<span class="Comment">    &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">      Click me: &lt;input type=&quot;checkbox&quot; ng-model=&quot;checked&quot; ng-init=&quot;checked=true&quot; /&gt;&lt;br/&gt;</span>
<span class="Comment">      Show when checked:</span>
<span class="Comment">      &lt;span ng-if=&quot;checked&quot; class=&quot;animate-if&quot;&gt;</span>
<span class="Comment">        I'm removed when the checkbox is unchecked.</span>
<span class="Comment">      &lt;/span&gt;</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;animations.css&quot;&gt;</span>
<span class="Comment">      .animate-if {</span>
<span class="Comment">        background:white;</span>
<span class="Comment">        border:1px solid black;</span>
<span class="Comment">        padding:10px;</span>
<span class="Comment">      }</span>

<span class="Comment">      /&amp;#42;</span>
<span class="Comment">        The transition styles can also be placed on the CSS base class above</span>
<span class="Comment">      &amp;#42;/</span>
<span class="Comment">      .animate-if.ng-enter, .animate-if.ng-leave {</span>
<span class="Comment">        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;</span>
<span class="Comment">        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;</span>
<span class="Comment">      }</span>

<span class="Comment">      .animate-if.ng-enter,</span>
<span class="Comment">      .animate-if.ng-leave.ng-leave-active {</span>
<span class="Comment">        opacity:0;</span>
<span class="Comment">      }</span>

<span class="Comment">      .animate-if.ng-leave,</span>
<span class="Comment">      .animate-if.ng-enter.ng-enter-active {</span>
<span class="Comment">        opacity:1;</span>
<span class="Comment">      }</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">  &lt;/example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngIfDirective = <span class="Identifier">[</span><span class="Constant">'$animate'</span>, <span class="Identifier">function</span>($animate) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">{</span>
    transclude: <span class="Constant">'element'</span>,
    priority: 600,
    terminal: <span class="Constant">true</span>,
    restrict: <span class="Constant">'A'</span>,
    $$tlb: <span class="Constant">true</span>,
    link: <span class="Identifier">function</span> ($scope, $element, $attr, ctrl, $transclude) <span class="Identifier">{</span>
        <span class="Identifier">var</span> block, childScope;
        $scope.$watch($attr.ngIf, <span class="Identifier">function</span> ngIfWatchAction(value) <span class="Identifier">{</span>

          <span class="Statement">if</span> (toBoolean(value)) <span class="Identifier">{</span>
            <span class="Statement">if</span> (!childScope) <span class="Identifier">{</span>
              childScope = $scope.$<span class="Statement">new</span>();
              $transclude(childScope, <span class="Identifier">function</span> (clone) <span class="Identifier">{</span>
                clone<span class="Identifier">[</span>clone.length++<span class="Identifier">]</span> = <span class="Statement">document</span>.createComment(<span class="Constant">' end ngIf: '</span> + $attr.ngIf + <span class="Constant">' '</span>);
                <span class="Comment">// Note: We only need the first/last node of the cloned nodes.</span>
                <span class="Comment">// However, we need to keep the reference to the jqlite wrapper as it might be changed later</span>
                <span class="Comment">// by a directive with templateUrl when it's template arrives.</span>
                block = <span class="Identifier">{</span>
                  clone: clone
                <span class="Identifier">}</span>;
                $animate.enter(clone, $element.<span class="Statement">parent</span>(), $element);
              <span class="Identifier">}</span>);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>

            <span class="Statement">if</span> (childScope) <span class="Identifier">{</span>
              childScope.$destroy();
              childScope = <span class="Statement">null</span>;
            <span class="Identifier">}</span>

            <span class="Statement">if</span> (block) <span class="Identifier">{</span>
              $animate.leave(getBlockElements(block.clone));
              block = <span class="Statement">null</span>;
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}]</span>;

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngInclude</span>
<span class="Comment"> * @restrict ECA</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Fetches, compiles and includes an external HTML fragment.</span>
<span class="Comment"> *</span>
<span class="Comment"> * By default, the template URL is restricted to the same domain and protocol as the</span>
<span class="Comment"> * application document. This is done by calling {@link ng.$sce#methods_getTrustedResourceUrl</span>
<span class="Comment"> * $sce.getTrustedResourceUrl} on it. To load templates from other domains or protocols</span>
<span class="Comment"> * you may either {@link ng.$sceDelegateProvider#methods_resourceUrlWhitelist whitelist them} or</span>
<span class="Comment"> * {@link ng.$sce#methods_trustAsResourceUrl wrap them} as trusted values. Refer to Angular's {@link</span>
<span class="Comment"> * ng.$sce Strict Contextual Escaping}.</span>
<span class="Comment"> *</span>
<span class="Comment"> * In addition, the browser's</span>
<span class="Comment"> * {@link <a href="https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest">https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest</a></span>
<span class="Comment"> * Same Origin Policy} and {@link <a href="http://www.w3.org/TR/cors/">http://www.w3.org/TR/cors/</a> Cross-Origin Resource Sharing</span>
<span class="Comment"> * (CORS)} policy may further restrict whether the template is successfully loaded.</span>
<span class="Comment"> * For example, `ngInclude` won't work for cross-domain requests on all browsers and for `file://`</span>
<span class="Comment"> * access on some browsers.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @animations</span>
<span class="Comment"> * enter - animation is used to bring new content into the browser.</span>
<span class="Comment"> * leave - animation is used to animate existing content away.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The enter and leave animation occur concurrently.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @scope</span>
<span class="Comment"> * @priority 400</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} ngInclude|src angular expression evaluating to URL. If the source is a string constant,</span>
<span class="Comment"> *                 make sure you wrap it in quotes, e.g. `src=&quot;'myPartialTemplate.html'&quot;`.</span>
<span class="Comment"> * @param {string=} onload Expression to evaluate when a new partial is loaded.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string=} autoscroll Whether `ngInclude` should call {@link ng.$anchorScroll</span>
<span class="Comment"> *                  $anchorScroll} to scroll the viewport after the content is loaded.</span>
<span class="Comment"> *</span>
<span class="Comment"> *                  - If the attribute is not set, disable scrolling.</span>
<span class="Comment"> *                  - If the attribute is set without value, enable scrolling.</span>
<span class="Comment"> *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">  &lt;example animations=&quot;true&quot;&gt;</span>
<span class="Comment">    &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">     &lt;div ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">       &lt;select ng-model=&quot;template&quot; ng-options=&quot;t.name for t in templates&quot;&gt;</span>
<span class="Comment">        &lt;option value=&quot;&quot;&gt;(blank)&lt;/option&gt;</span>
<span class="Comment">       &lt;/select&gt;</span>
<span class="Comment">       url of the template: &lt;tt&gt;{{template.url}}&lt;/tt&gt;</span>
<span class="Comment">       &lt;hr/&gt;</span>
<span class="Comment">       &lt;div class=&quot;slide-animate-container&quot;&gt;</span>
<span class="Comment">         &lt;div class=&quot;slide-animate&quot; ng-include=&quot;template.url&quot;&gt;&lt;/div&gt;</span>
<span class="Comment">       &lt;/div&gt;</span>
<span class="Comment">     &lt;/div&gt;</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;script.js&quot;&gt;</span>
<span class="Comment">      function Ctrl($scope) {</span>
<span class="Comment">        $scope.templates =</span>
<span class="Comment">          [ { name: 'template1.html', url: 'template1.html'}</span>
<span class="Comment">          , { name: 'template2.html', url: 'template2.html'} ];</span>
<span class="Comment">        $scope.template = $scope.templates[0];</span>
<span class="Comment">      }</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;template1.html&quot;&gt;</span>
<span class="Comment">      Content of template1.html</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;template2.html&quot;&gt;</span>
<span class="Comment">      Content of template2.html</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;animations.css&quot;&gt;</span>
<span class="Comment">      .slide-animate-container {</span>
<span class="Comment">        position:relative;</span>
<span class="Comment">        background:white;</span>
<span class="Comment">        border:1px solid black;</span>
<span class="Comment">        height:40px;</span>
<span class="Comment">        overflow:hidden;</span>
<span class="Comment">      }</span>

<span class="Comment">      .slide-animate {</span>
<span class="Comment">        padding:10px;</span>
<span class="Comment">      }</span>

<span class="Comment">      .slide-animate.ng-enter, .slide-animate.ng-leave {</span>
<span class="Comment">        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;</span>
<span class="Comment">        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;</span>

<span class="Comment">        position:absolute;</span>
<span class="Comment">        top:0;</span>
<span class="Comment">        left:0;</span>
<span class="Comment">        right:0;</span>
<span class="Comment">        bottom:0;</span>
<span class="Comment">        display:block;</span>
<span class="Comment">        padding:10px;</span>
<span class="Comment">      }</span>

<span class="Comment">      .slide-animate.ng-enter {</span>
<span class="Comment">        top:-50px;</span>
<span class="Comment">      }</span>
<span class="Comment">      .slide-animate.ng-enter.ng-enter-active {</span>
<span class="Comment">        top:0;</span>
<span class="Comment">      }</span>

<span class="Comment">      .slide-animate.ng-leave {</span>
<span class="Comment">        top:0;</span>
<span class="Comment">      }</span>
<span class="Comment">      .slide-animate.ng-leave.ng-leave-active {</span>
<span class="Comment">        top:50px;</span>
<span class="Comment">      }</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;scenario.js&quot;&gt;</span>
<span class="Comment">      it('should load template1.html', function() {</span>
<span class="Comment">       expect(element('.doc-example-live [ng-include]').text()).</span>
<span class="Comment">         toMatch(/Content of template1.html/);</span>
<span class="Comment">      });</span>
<span class="Comment">      it('should load template2.html', function() {</span>
<span class="Comment">       select('template').option('1');</span>
<span class="Comment">       expect(element('.doc-example-live [ng-include]').text()).</span>
<span class="Comment">         toMatch(/Content of template2.html/);</span>
<span class="Comment">      });</span>
<span class="Comment">      it('should change to blank', function() {</span>
<span class="Comment">       select('template').option('');</span>
<span class="Comment">       expect(element('.doc-example-live [ng-include]')).toBe(undefined);</span>
<span class="Comment">      });</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">  &lt;/example&gt;</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc event</span>
<span class="Comment"> * @name ng.directive:ngInclude#$includeContentRequested</span>
<span class="Comment"> * @eventOf ng.directive:ngInclude</span>
<span class="Comment"> * @eventType emit on the scope ngInclude was declared in</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Emitted every time the ngInclude content is requested.</span>
<span class="Comment"> */</span>


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc event</span>
<span class="Comment"> * @name ng.directive:ngInclude#$includeContentLoaded</span>
<span class="Comment"> * @eventOf ng.directive:ngInclude</span>
<span class="Comment"> * @eventType emit on the current ngInclude scope</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Emitted every time the ngInclude content is reloaded.</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngIncludeDirective = <span class="Identifier">[</span><span class="Constant">'$http'</span>, <span class="Constant">'$templateCache'</span>, <span class="Constant">'$anchorScroll'</span>, <span class="Constant">'$compile'</span>, <span class="Constant">'$animate'</span>, <span class="Constant">'$sce'</span>,
                  <span class="Identifier">function</span>($http,   $templateCache,   $anchorScroll,   $compile,   $animate,   $sce) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">{</span>
    restrict: <span class="Constant">'ECA'</span>,
    priority: 400,
    terminal: <span class="Constant">true</span>,
    transclude: <span class="Constant">'element'</span>,
    compile: <span class="Identifier">function</span>(element, attr) <span class="Identifier">{</span>
      <span class="Identifier">var</span> srcExp = attr.ngInclude || attr.src,
          onloadExp = attr.onload || <span class="Constant">''</span>,
          autoScrollExp = attr.autoscroll;

      <span class="Statement">return</span> <span class="Identifier">function</span>(scope, $element, $attr, ctrl, $transclude) <span class="Identifier">{</span>
        <span class="Identifier">var</span> changeCounter = 0,
            currentScope,
            currentElement;

        <span class="Identifier">var</span> cleanupLastIncludeContent = <span class="Identifier">function</span>() <span class="Identifier">{</span>
          <span class="Statement">if</span> (currentScope) <span class="Identifier">{</span>
            currentScope.$destroy();
            currentScope = <span class="Statement">null</span>;
          <span class="Identifier">}</span>
          <span class="Statement">if</span>(currentElement) <span class="Identifier">{</span>
            $animate.leave(currentElement);
            currentElement = <span class="Statement">null</span>;
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>;

        scope.$watch($sce.parseAsResourceUrl(srcExp), <span class="Identifier">function</span> ngIncludeWatchAction(src) <span class="Identifier">{</span>
          <span class="Identifier">var</span> afterAnimation = <span class="Identifier">function</span>() <span class="Identifier">{</span>
            <span class="Statement">if</span> (isDefined(autoScrollExp) &amp;&amp; (!autoScrollExp || scope.$eval(autoScrollExp))) <span class="Identifier">{</span>
              $anchorScroll();
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>;
          <span class="Identifier">var</span> thisChangeId = ++changeCounter;

          <span class="Statement">if</span> (src) <span class="Identifier">{</span>
            $http.get(src, <span class="Identifier">{</span>cache: $templateCache<span class="Identifier">}</span>).success(<span class="Identifier">function</span>(response) <span class="Identifier">{</span>
              <span class="Statement">if</span> (thisChangeId !== changeCounter) <span class="Statement">return</span>;
              <span class="Identifier">var</span> newScope = scope.$<span class="Statement">new</span>();

              <span class="Comment">// Note: This will also link all children of ng-include that were contained in the original</span>
              <span class="Comment">// html. If that content contains controllers, ... they could pollute/change the scope.</span>
              <span class="Comment">// However, using ng-include on an element with additional content does not make sense...</span>
              <span class="Comment">// Note: We can't remove them in the cloneAttchFn of $transclude as that</span>
              <span class="Comment">// function is called before linking the content, which would apply child</span>
              <span class="Comment">// directives to non existing elements.</span>
              <span class="Identifier">var</span> clone = $transclude(newScope, noop);
              cleanupLastIncludeContent();

              currentScope = newScope;
              currentElement = clone;

              currentElement.html(response);
              $animate.enter(currentElement, <span class="Statement">null</span>, $element, afterAnimation);
              $compile(currentElement.contents())(currentScope);
              currentScope.$emit(<span class="Constant">'$includeContentLoaded'</span>);
              scope.$eval(onloadExp);
            <span class="Identifier">}</span>).error(<span class="Identifier">function</span>() <span class="Identifier">{</span>
              <span class="Statement">if</span> (thisChangeId === changeCounter) cleanupLastIncludeContent();
            <span class="Identifier">}</span>);
            scope.$emit(<span class="Constant">'$includeContentRequested'</span>);
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            cleanupLastIncludeContent();
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>);
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}]</span>;

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngInit</span>
<span class="Comment"> * @restrict AC</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngInit` directive allows you to evaluate an expression in the</span>
<span class="Comment"> * current scope.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;div class=&quot;alert alert-error&quot;&gt;</span>
<span class="Comment"> * The only appropriate use of `ngInit` for aliasing special properties of</span>
<span class="Comment"> * {@link api/ng.directive:ngRepeat `ngRepeat`}, as seen in the demo below. Besides this case, you</span>
<span class="Comment"> * should use {@link guide/controller controllers} rather than `ngInit`</span>
<span class="Comment"> * to initialize values on a scope.</span>
<span class="Comment"> * &lt;/div&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @priority 450</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngInit {@link guide/expression Expression} to eval.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;doc:example&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">   &lt;script&gt;</span>
<span class="Comment">     function Ctrl($scope) {</span>
<span class="Comment">       $scope.list = [['a', 'b'], ['c', 'd']];</span>
<span class="Comment">     }</span>
<span class="Comment">   &lt;/script&gt;</span>
<span class="Comment">   &lt;div ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">     &lt;div ng-repeat=&quot;innerList in list&quot; ng-init=&quot;outerIndex = $index&quot;&gt;</span>
<span class="Comment">       &lt;div ng-repeat=&quot;value in innerList&quot; ng-init=&quot;innerIndex = $index&quot;&gt;</span>
<span class="Comment">          &lt;span class=&quot;example-init&quot;&gt;list[ {{outerIndex}} ][ {{innerIndex}} ] = {{value}};&lt;/span&gt;</span>
<span class="Comment">       &lt;/div&gt;</span>
<span class="Comment">     &lt;/div&gt;</span>
<span class="Comment">   &lt;/div&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should alias index positions', function() {</span>
<span class="Comment">         expect(element('.example-init').text())</span>
<span class="Comment">           .toBe('list[ 0 ][ 0 ] = a;' +</span>
<span class="Comment">                 'list[ 0 ][ 1 ] = b;' +</span>
<span class="Comment">                 'list[ 1 ][ 0 ] = c;' +</span>
<span class="Comment">                 'list[ 1 ][ 1 ] = d;');</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngInitDirective = ngDirective(<span class="Identifier">{</span>
  priority: 450,
  compile: <span class="Identifier">function</span>() <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">{</span>
      pre: <span class="Identifier">function</span>(scope, element, attrs) <span class="Identifier">{</span>
        scope.$eval(attrs.ngInit);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>
<span class="Identifier">}</span>);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngNonBindable</span>
<span class="Comment"> * @restrict AC</span>
<span class="Comment"> * @priority 1000</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngNonBindable` directive tells Angular not to compile or bind the contents of the current</span>
<span class="Comment"> * DOM element. This is useful if the element contains what appears to be Angular directives and</span>
<span class="Comment"> * bindings but which should be ignored by Angular. This could be the case if you have a site that</span>
<span class="Comment"> * displays snippets of code, for instance.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * In this example there are two locations where a simple interpolation binding (`{{}}`) is present,</span>
<span class="Comment"> * but the one wrapped in `ngNonBindable` is left alone.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">    &lt;doc:example&gt;</span>
<span class="Comment">      &lt;doc:source&gt;</span>
<span class="Comment">        &lt;div&gt;Normal: {{1 + 2}}&lt;/div&gt;</span>
<span class="Comment">        &lt;div ng-non-bindable&gt;Ignored: {{1 + 2}}&lt;/div&gt;</span>
<span class="Comment">      &lt;/doc:source&gt;</span>
<span class="Comment">      &lt;doc:scenario&gt;</span>
<span class="Comment">       it('should check ng-non-bindable', function() {</span>
<span class="Comment">         expect(using('.doc-example-live').binding('1 + 2')).toBe('3');</span>
<span class="Comment">         expect(using('.doc-example-live').element('div:last').text()).</span>
<span class="Comment">           toMatch(/1 \+ 2/);</span>
<span class="Comment">       });</span>
<span class="Comment">      &lt;/doc:scenario&gt;</span>
<span class="Comment">    &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngNonBindableDirective = ngDirective(<span class="Identifier">{</span> terminal: <span class="Constant">true</span>, priority: 1000 <span class="Identifier">}</span>);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngPluralize</span>
<span class="Comment"> * @restrict EA</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * # Overview</span>
<span class="Comment"> * `ngPluralize` is a directive that displays messages according to en-US localization rules.</span>
<span class="Comment"> * These rules are bundled with angular.js, but can be overridden</span>
<span class="Comment"> * (see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive</span>
<span class="Comment"> * by specifying the mappings between</span>
<span class="Comment"> * {@link <a href="http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html">http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html</a></span>
<span class="Comment"> * plural categories} and the strings to be displayed.</span>
<span class="Comment"> *</span>
<span class="Comment"> * # Plural categories and explicit number rules</span>
<span class="Comment"> * There are two</span>
<span class="Comment"> * {@link <a href="http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html">http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html</a></span>
<span class="Comment"> * plural categories} in Angular's default en-US locale: &quot;one&quot; and &quot;other&quot;.</span>
<span class="Comment"> *</span>
<span class="Comment"> * While a plural category may match many numbers (for example, in en-US locale, &quot;other&quot; can match</span>
<span class="Comment"> * any number that is not 1), an explicit number rule can only match one number. For example, the</span>
<span class="Comment"> * explicit number rule for &quot;3&quot; matches the number 3. There are examples of plural categories</span>
<span class="Comment"> * and explicit number rules throughout the rest of this documentation.</span>
<span class="Comment"> *</span>
<span class="Comment"> * # Configuring ngPluralize</span>
<span class="Comment"> * You configure ngPluralize by providing 2 attributes: `count` and `when`.</span>
<span class="Comment"> * You can also provide an optional attribute, `offset`.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The value of the `count` attribute can be either a string or an {@link guide/expression</span>
<span class="Comment"> * Angular expression}; these are evaluated on the current scope for its bound value.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The `when` attribute specifies the mappings between plural categories and the actual</span>
<span class="Comment"> * string to be displayed. The value of the attribute should be a JSON object.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The following example shows how to configure ngPluralize:</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * &lt;ng-pluralize count=&quot;personCount&quot;</span>
<span class="Comment">                 when=&quot;{'0': 'Nobody is viewing.',</span>
<span class="Comment"> *                      'one': '1 person is viewing.',</span>
<span class="Comment"> *                      'other': '{} people are viewing.'}&quot;&gt;</span>
<span class="Comment"> * &lt;/ng-pluralize&gt;</span>
<span class="Comment"> *&lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * In the example, `&quot;0: Nobody is viewing.&quot;` is an explicit number rule. If you did not</span>
<span class="Comment"> * specify this rule, 0 would be matched to the &quot;other&quot; category and &quot;0 people are viewing&quot;</span>
<span class="Comment"> * would be shown instead of &quot;Nobody is viewing&quot;. You can specify an explicit number rule for</span>
<span class="Comment"> * other numbers, for example 12, so that instead of showing &quot;12 people are viewing&quot;, you can</span>
<span class="Comment"> * show &quot;a dozen people are viewing&quot;.</span>
<span class="Comment"> *</span>
<span class="Comment"> * You can use a set of closed braces (`{}`) as a placeholder for the number that you want substituted</span>
<span class="Comment"> * into pluralized strings. In the previous example, Angular will replace `{}` with</span>
<span class="Comment"> * &lt;span ng-non-bindable&gt;`{{personCount}}`&lt;/span&gt;. The closed braces `{}` is a placeholder</span>
<span class="Comment"> * for &lt;span ng-non-bindable&gt;{{numberExpression}}&lt;/span&gt;.</span>
<span class="Comment"> *</span>
<span class="Comment"> * # Configuring ngPluralize with offset</span>
<span class="Comment"> * The `offset` attribute allows further customization of pluralized text, which can result in</span>
<span class="Comment"> * a better user experience. For example, instead of the message &quot;4 people are viewing this document&quot;,</span>
<span class="Comment"> * you might display &quot;John, Kate and 2 others are viewing this document&quot;.</span>
<span class="Comment"> * The offset attribute allows you to offset a number by any desired value.</span>
<span class="Comment"> * Let's take a look at an example:</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * &lt;ng-pluralize count=&quot;personCount&quot; offset=2</span>
<span class="Comment"> *               when=&quot;{'0': 'Nobody is viewing.',</span>
<span class="Comment"> *                      '1': '{{person1}} is viewing.',</span>
<span class="Comment"> *                      '2': '{{person1}} and {{person2}} are viewing.',</span>
<span class="Comment"> *                      'one': '{{person1}}, {{person2}} and one other person are viewing.',</span>
<span class="Comment"> *                      'other': '{{person1}}, {{person2}} and {} other people are viewing.'}&quot;&gt;</span>
<span class="Comment"> * &lt;/ng-pluralize&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * Notice that we are still using two plural categories(one, other), but we added</span>
<span class="Comment"> * three explicit number rules 0, 1 and 2.</span>
<span class="Comment"> * When one person, perhaps John, views the document, &quot;John is viewing&quot; will be shown.</span>
<span class="Comment"> * When three people view the document, no explicit number rule is found, so</span>
<span class="Comment"> * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.</span>
<span class="Comment"> * In this case, plural category 'one' is matched and &quot;John, Marry and one other person are viewing&quot;</span>
<span class="Comment"> * is shown.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Note that when you specify offsets, you must provide explicit number rules for</span>
<span class="Comment"> * numbers from 0 up to and including the offset. If you use an offset of 3, for example,</span>
<span class="Comment"> * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for</span>
<span class="Comment"> * plural categories &quot;one&quot; and &quot;other&quot;.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string|expression} count The variable to be bounded to.</span>
<span class="Comment"> * @param {string} when The mapping between plural category to its corresponding strings.</span>
<span class="Comment"> * @param {number=} offset Offset to deduct from the total number.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">    &lt;doc:example&gt;</span>
<span class="Comment">      &lt;doc:source&gt;</span>
<span class="Comment">        &lt;script&gt;</span>
<span class="Comment">          function Ctrl($scope) {</span>
<span class="Comment">            $scope.person1 = 'Igor';</span>
<span class="Comment">            $scope.person2 = 'Misko';</span>
<span class="Comment">            $scope.personCount = 1;</span>
<span class="Comment">          }</span>
<span class="Comment">        &lt;/script&gt;</span>
<span class="Comment">        &lt;div ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">          Person 1:&lt;input type=&quot;text&quot; ng-model=&quot;person1&quot; value=&quot;Igor&quot; /&gt;&lt;br/&gt;</span>
<span class="Comment">          Person 2:&lt;input type=&quot;text&quot; ng-model=&quot;person2&quot; value=&quot;Misko&quot; /&gt;&lt;br/&gt;</span>
<span class="Comment">          Number of People:&lt;input type=&quot;text&quot; ng-model=&quot;personCount&quot; value=&quot;1&quot; /&gt;&lt;br/&gt;</span>

<span class="Comment">          &lt;!--- Example with simple pluralization rules for en locale ---&gt;</span>
<span class="Comment">          Without Offset:</span>
<span class="Comment">          &lt;ng-pluralize count=&quot;personCount&quot;</span>
<span class="Comment">                        when=&quot;{'0': 'Nobody is viewing.',</span>
<span class="Comment">                               'one': '1 person is viewing.',</span>
<span class="Comment">                               'other': '{} people are viewing.'}&quot;&gt;</span>
<span class="Comment">          &lt;/ng-pluralize&gt;&lt;br&gt;</span>

<span class="Comment">          &lt;!--- Example with offset ---&gt;</span>
<span class="Comment">          With Offset(2):</span>
<span class="Comment">          &lt;ng-pluralize count=&quot;personCount&quot; offset=2</span>
<span class="Comment">                        when=&quot;{'0': 'Nobody is viewing.',</span>
<span class="Comment">                               '1': '{{person1}} is viewing.',</span>
<span class="Comment">                               '2': '{{person1}} and {{person2}} are viewing.',</span>
<span class="Comment">                               'one': '{{person1}}, {{person2}} and one other person are viewing.',</span>
<span class="Comment">                               'other': '{{person1}}, {{person2}} and {} other people are viewing.'}&quot;&gt;</span>
<span class="Comment">          &lt;/ng-pluralize&gt;</span>
<span class="Comment">        &lt;/div&gt;</span>
<span class="Comment">      &lt;/doc:source&gt;</span>
<span class="Comment">      &lt;doc:scenario&gt;</span>
<span class="Comment">        it('should show correct pluralized string', function() {</span>
<span class="Comment">          expect(element('.doc-example-live ng-pluralize:first').text()).</span>
<span class="Comment">                                             toBe('1 person is viewing.');</span>
<span class="Comment">          expect(element('.doc-example-live ng-pluralize:last').text()).</span>
<span class="Comment">                                                toBe('Igor is viewing.');</span>

<span class="Comment">          using('.doc-example-live').input('personCount').enter('0');</span>
<span class="Comment">          expect(element('.doc-example-live ng-pluralize:first').text()).</span>
<span class="Comment">                                               toBe('Nobody is viewing.');</span>
<span class="Comment">          expect(element('.doc-example-live ng-pluralize:last').text()).</span>
<span class="Comment">                                              toBe('Nobody is viewing.');</span>

<span class="Comment">          using('.doc-example-live').input('personCount').enter('2');</span>
<span class="Comment">          expect(element('.doc-example-live ng-pluralize:first').text()).</span>
<span class="Comment">                                            toBe('2 people are viewing.');</span>
<span class="Comment">          expect(element('.doc-example-live ng-pluralize:last').text()).</span>
<span class="Comment">                              toBe('Igor and Misko are viewing.');</span>

<span class="Comment">          using('.doc-example-live').input('personCount').enter('3');</span>
<span class="Comment">          expect(element('.doc-example-live ng-pluralize:first').text()).</span>
<span class="Comment">                                            toBe('3 people are viewing.');</span>
<span class="Comment">          expect(element('.doc-example-live ng-pluralize:last').text()).</span>
<span class="Comment">                              toBe('Igor, Misko and one other person are viewing.');</span>

<span class="Comment">          using('.doc-example-live').input('personCount').enter('4');</span>
<span class="Comment">          expect(element('.doc-example-live ng-pluralize:first').text()).</span>
<span class="Comment">                                            toBe('4 people are viewing.');</span>
<span class="Comment">          expect(element('.doc-example-live ng-pluralize:last').text()).</span>
<span class="Comment">                              toBe('Igor, Misko and 2 other people are viewing.');</span>
<span class="Comment">        });</span>

<span class="Comment">        it('should show data-binded names', function() {</span>
<span class="Comment">          using('.doc-example-live').input('personCount').enter('4');</span>
<span class="Comment">          expect(element('.doc-example-live ng-pluralize:last').text()).</span>
<span class="Comment">              toBe('Igor, Misko and 2 other people are viewing.');</span>

<span class="Comment">          using('.doc-example-live').input('person1').enter('Di');</span>
<span class="Comment">          using('.doc-example-live').input('person2').enter('Vojta');</span>
<span class="Comment">          expect(element('.doc-example-live ng-pluralize:last').text()).</span>
<span class="Comment">              toBe('Di, Vojta and 2 other people are viewing.');</span>
<span class="Comment">        });</span>
<span class="Comment">      &lt;/doc:scenario&gt;</span>
<span class="Comment">    &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngPluralizeDirective = <span class="Identifier">[</span><span class="Constant">'$locale'</span>, <span class="Constant">'$interpolate'</span>, <span class="Identifier">function</span>($locale, $interpolate) <span class="Identifier">{</span>
  <span class="Identifier">var</span> BRACE = <span class="Constant">/{}/g</span>;
  <span class="Statement">return</span> <span class="Identifier">{</span>
    restrict: <span class="Constant">'EA'</span>,
    link: <span class="Identifier">function</span>(scope, element, attr) <span class="Identifier">{</span>
      <span class="Identifier">var</span> numberExp = attr.count,
          whenExp = attr.$attr.when &amp;&amp; element.attr(attr.$attr.when), <span class="Comment">// we have {{}} in attrs</span>
          offset = attr.offset || 0,
          whens = scope.$eval(whenExp) || <span class="Identifier">{}</span>,
          whensExpFns = <span class="Identifier">{}</span>,
          startSymbol = $interpolate.startSymbol(),
          endSymbol = $interpolate.endSymbol(),
          isWhen = <span class="Constant">/^when(Minus)?(.+)$/</span>;

      forEach(attr, <span class="Identifier">function</span>(expression, attributeName) <span class="Identifier">{</span>
        <span class="Statement">if</span> (isWhen.test(attributeName)) <span class="Identifier">{</span>
          whens<span class="Identifier">[</span>lowercase(attributeName.replace(<span class="Constant">'when'</span>, <span class="Constant">''</span>).replace(<span class="Constant">'Minus'</span>, <span class="Constant">'-'</span>))<span class="Identifier">]</span> =
            element.attr(attr.$attr<span class="Identifier">[</span>attributeName<span class="Identifier">]</span>);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>);
      forEach(whens, <span class="Identifier">function</span>(expression, key) <span class="Identifier">{</span>
        whensExpFns<span class="Identifier">[</span>key<span class="Identifier">]</span> =
          $interpolate(expression.replace(BRACE, startSymbol + numberExp + <span class="Constant">'-'</span> +
            offset + endSymbol));
      <span class="Identifier">}</span>);

      scope.$watch(<span class="Identifier">function</span> ngPluralizeWatch() <span class="Identifier">{</span>
        <span class="Identifier">var</span> value = parseFloat(scope.$eval(numberExp));

        <span class="Statement">if</span> (!isNaN(value)) <span class="Identifier">{</span>
          <span class="Comment">//if explicit number rule such as 1, 2, 3... is defined, just use it. Otherwise,</span>
          <span class="Comment">//check it against pluralization rules in $locale service</span>
          <span class="Statement">if</span> (!(value <span class="Statement">in</span> whens)) value = $locale.pluralCat(value - offset);
           <span class="Statement">return</span> whensExpFns<span class="Identifier">[</span>value<span class="Identifier">]</span>(scope, element, <span class="Constant">true</span>);
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          <span class="Statement">return</span> <span class="Constant">''</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>, <span class="Identifier">function</span> ngPluralizeWatchAction(newVal) <span class="Identifier">{</span>
        element.text(newVal);
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}]</span>;

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngRepeat</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngRepeat` directive instantiates a template once per item from a collection. Each template</span>
<span class="Comment"> * instance gets its own scope, where the given loop variable is set to the current collection item,</span>
<span class="Comment"> * and `$index` is set to the item index or key.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Special properties are exposed on the local scope of each template instance, including:</span>
<span class="Comment"> *</span>
<span class="Comment"> * | Variable  | Type            | Details                                                                     |</span>
<span class="Comment"> * |-----------|-----------------|-----------------------------------------------------------------------------|</span>
<span class="Comment"> * | `$index`  | {@type number}  | iterator offset of the repeated element (0..length-1)                       |</span>
<span class="Comment"> * | `$first`  | {@type boolean} | true if the repeated element is first in the iterator.                      |</span>
<span class="Comment"> * | `$middle` | {@type boolean} | true if the repeated element is between the first and last in the iterator. |</span>
<span class="Comment"> * | `$last`   | {@type boolean} | true if the repeated element is last in the iterator.                       |</span>
<span class="Comment"> * | `$even`   | {@type boolean} | true if the iterator position `$index` is even (otherwise false).           |</span>
<span class="Comment"> * | `$odd`    | {@type boolean} | true if the iterator position `$index` is odd (otherwise false).            |</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * # Special repeat start and end points</span>
<span class="Comment"> * To repeat a series of elements instead of just one parent element, ngRepeat (as well as other ng directives) supports extending</span>
<span class="Comment"> * the range of the repeater by defining explicit start and end points by using **ng-repeat-start** and **ng-repeat-end** respectively.</span>
<span class="Comment"> * The **ng-repeat-start** directive works the same as **ng-repeat**, but will repeat all the HTML code (including the tag it's defined on)</span>
<span class="Comment"> * up to and including the ending HTML tag where **ng-repeat-end** is placed.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The example below makes use of this feature:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   &lt;header ng-repeat-start=&quot;item in items&quot;&gt;</span>
<span class="Comment"> *     Header {{ item }}</span>
<span class="Comment"> *   &lt;/header&gt;</span>
<span class="Comment"> *   &lt;div class=&quot;body&quot;&gt;</span>
<span class="Comment"> *     Body {{ item }}</span>
<span class="Comment"> *   &lt;/div&gt;</span>
<span class="Comment"> *   &lt;footer ng-repeat-end&gt;</span>
<span class="Comment"> *     Footer {{ item }}</span>
<span class="Comment"> *   &lt;/footer&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * And with an input of {@type ['A','B']} for the items variable in the example above, the output will evaluate to:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> *   &lt;header&gt;</span>
<span class="Comment"> *     Header A</span>
<span class="Comment"> *   &lt;/header&gt;</span>
<span class="Comment"> *   &lt;div class=&quot;body&quot;&gt;</span>
<span class="Comment"> *     Body A</span>
<span class="Comment"> *   &lt;/div&gt;</span>
<span class="Comment"> *   &lt;footer&gt;</span>
<span class="Comment"> *     Footer A</span>
<span class="Comment"> *   &lt;/footer&gt;</span>
<span class="Comment"> *   &lt;header&gt;</span>
<span class="Comment"> *     Header B</span>
<span class="Comment"> *   &lt;/header&gt;</span>
<span class="Comment"> *   &lt;div class=&quot;body&quot;&gt;</span>
<span class="Comment"> *     Body B</span>
<span class="Comment"> *   &lt;/div&gt;</span>
<span class="Comment"> *   &lt;footer&gt;</span>
<span class="Comment"> *     Footer B</span>
<span class="Comment"> *   &lt;/footer&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * The custom start and end points for ngRepeat also support all other HTML directive syntax flavors provided in AngularJS (such</span>
<span class="Comment"> * as **data-ng-repeat-start**, **x-ng-repeat-start** and **ng:repeat-start**).</span>
<span class="Comment"> *</span>
<span class="Comment"> * @animations</span>
<span class="Comment"> * enter - when a new item is added to the list or when an item is revealed after a filter</span>
<span class="Comment"> * leave - when an item is removed from the list or when an item is filtered out</span>
<span class="Comment"> * move - when an adjacent item is filtered out causing a reorder or when the item contents are reordered</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @scope</span>
<span class="Comment"> * @priority 1000</span>
<span class="Comment"> * @param {repeat_expression} ngRepeat The expression indicating how to enumerate a collection. These</span>
<span class="Comment"> *   formats are currently supported:</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * `variable in expression` – where variable is the user defined loop variable and `expression`</span>
<span class="Comment"> *     is a scope expression giving the collection to enumerate.</span>
<span class="Comment"> *</span>
<span class="Comment"> *     For example: `album in artist.albums`.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * `(key, value) in expression` – where `key` and `value` can be any user defined identifiers,</span>
<span class="Comment"> *     and `expression` is the scope expression giving the collection to enumerate.</span>
<span class="Comment"> *</span>
<span class="Comment"> *     For example: `(name, age) in {'adam':10, 'amalie':12}`.</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * `variable in expression track by tracking_expression` – You can also provide an optional tracking function</span>
<span class="Comment"> *     which can be used to associate the objects in the collection with the DOM elements. If no tracking function</span>
<span class="Comment"> *     is specified the ng-repeat associates elements by identity in the collection. It is an error to have</span>
<span class="Comment"> *     more than one tracking function to resolve to the same key. (This would mean that two distinct objects are</span>
<span class="Comment"> *     mapped to the same DOM element, which is not possible.)  Filters should be applied to the expression,</span>
<span class="Comment"> *     before specifying a tracking expression.</span>
<span class="Comment"> *</span>
<span class="Comment"> *     For example: `item in items` is equivalent to `item in items track by $id(item)'. This implies that the DOM elements</span>
<span class="Comment"> *     will be associated by item identity in the array.</span>
<span class="Comment"> *</span>
<span class="Comment"> *     For example: `item in items track by $id(item)`. A built in `$id()` function can be used to assign a unique</span>
<span class="Comment"> *     `$$hashKey` property to each item in the array. This property is then used as a key to associated DOM elements</span>
<span class="Comment"> *     with the corresponding item in the array by identity. Moving the same object in array would move the DOM</span>
<span class="Comment"> *     element in the same way in the DOM.</span>
<span class="Comment"> *</span>
<span class="Comment"> *     For example: `item in items track by item.id` is a typical pattern when the items come from the database. In this</span>
<span class="Comment"> *     case the object identity does not matter. Two objects are considered equivalent as long as their `id`</span>
<span class="Comment"> *     property is same.</span>
<span class="Comment"> *</span>
<span class="Comment"> *     For example: `item in items | filter:searchText track by item.id` is a pattern that might be used to apply a filter</span>
<span class="Comment"> *     to items in conjunction with a tracking expression.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment"> * This example initializes the scope to a list of names and</span>
<span class="Comment"> * then uses `ngRepeat` to display every person:</span>
<span class="Comment">  &lt;example animations=&quot;true&quot;&gt;</span>
<span class="Comment">    &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">      &lt;div ng-init=&quot;friends = [</span>
<span class="Comment">        {name:'John', age:25, gender:'boy'},</span>
<span class="Comment">        {name:'Jessie', age:30, gender:'girl'},</span>
<span class="Comment">        {name:'Johanna', age:28, gender:'girl'},</span>
<span class="Comment">        {name:'Joy', age:15, gender:'girl'},</span>
<span class="Comment">        {name:'Mary', age:28, gender:'girl'},</span>
<span class="Comment">        {name:'Peter', age:95, gender:'boy'},</span>
<span class="Comment">        {name:'Sebastian', age:50, gender:'boy'},</span>
<span class="Comment">        {name:'Erika', age:27, gender:'girl'},</span>
<span class="Comment">        {name:'Patrick', age:40, gender:'boy'},</span>
<span class="Comment">        {name:'Samantha', age:60, gender:'girl'}</span>
<span class="Comment">      ]&quot;&gt;</span>
<span class="Comment">        I have {{friends.length}} friends. They are:</span>
<span class="Comment">        &lt;input type=&quot;search&quot; ng-model=&quot;q&quot; placeholder=&quot;filter friends...&quot; /&gt;</span>
<span class="Comment">        &lt;ul class=&quot;example-animate-container&quot;&gt;</span>
<span class="Comment">          &lt;li class=&quot;animate-repeat&quot; ng-repeat=&quot;friend in friends | filter:q&quot;&gt;</span>
<span class="Comment">            [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.</span>
<span class="Comment">          &lt;/li&gt;</span>
<span class="Comment">        &lt;/ul&gt;</span>
<span class="Comment">      &lt;/div&gt;</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;animations.css&quot;&gt;</span>
<span class="Comment">      .example-animate-container {</span>
<span class="Comment">        background:white;</span>
<span class="Comment">        border:1px solid black;</span>
<span class="Comment">        list-style:none;</span>
<span class="Comment">        margin:0;</span>
<span class="Comment">        padding:0 10px;</span>
<span class="Comment">      }</span>

<span class="Comment">      .animate-repeat {</span>
<span class="Comment">        line-height:40px;</span>
<span class="Comment">        list-style:none;</span>
<span class="Comment">        box-sizing:border-box;</span>
<span class="Comment">      }</span>

<span class="Comment">      .animate-repeat.ng-move,</span>
<span class="Comment">      .animate-repeat.ng-enter,</span>
<span class="Comment">      .animate-repeat.ng-leave {</span>
<span class="Comment">        -webkit-transition:all linear 0.5s;</span>
<span class="Comment">        transition:all linear 0.5s;</span>
<span class="Comment">      }</span>

<span class="Comment">      .animate-repeat.ng-leave.ng-leave-active,</span>
<span class="Comment">      .animate-repeat.ng-move,</span>
<span class="Comment">      .animate-repeat.ng-enter {</span>
<span class="Comment">        opacity:0;</span>
<span class="Comment">        max-height:0;</span>
<span class="Comment">      }</span>

<span class="Comment">      .animate-repeat.ng-leave,</span>
<span class="Comment">      .animate-repeat.ng-move.ng-move-active,</span>
<span class="Comment">      .animate-repeat.ng-enter.ng-enter-active {</span>
<span class="Comment">        opacity:1;</span>
<span class="Comment">        max-height:40px;</span>
<span class="Comment">      }</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;scenario.js&quot;&gt;</span>
<span class="Comment">       it('should render initial data set', function() {</span>
<span class="Comment">         var r = using('.doc-example-live').repeater('ul li');</span>
<span class="Comment">         expect(r.count()).toBe(10);</span>
<span class="Comment">         expect(r.row(0)).toEqual([&quot;1&quot;,&quot;John&quot;,&quot;25&quot;]);</span>
<span class="Comment">         expect(r.row(1)).toEqual([&quot;2&quot;,&quot;Jessie&quot;,&quot;30&quot;]);</span>
<span class="Comment">         expect(r.row(9)).toEqual([&quot;10&quot;,&quot;Samantha&quot;,&quot;60&quot;]);</span>
<span class="Comment">         expect(binding('friends.length')).toBe(&quot;10&quot;);</span>
<span class="Comment">       });</span>

<span class="Comment">       it('should update repeater when filter predicate changes', function() {</span>
<span class="Comment">         var r = using('.doc-example-live').repeater('ul li');</span>
<span class="Comment">         expect(r.count()).toBe(10);</span>

<span class="Comment">         input('q').enter('ma');</span>

<span class="Comment">         expect(r.count()).toBe(2);</span>
<span class="Comment">         expect(r.row(0)).toEqual([&quot;1&quot;,&quot;Mary&quot;,&quot;28&quot;]);</span>
<span class="Comment">         expect(r.row(1)).toEqual([&quot;2&quot;,&quot;Samantha&quot;,&quot;60&quot;]);</span>
<span class="Comment">       });</span>
<span class="Comment">      &lt;/file&gt;</span>
<span class="Comment">    &lt;/example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngRepeatDirective = <span class="Identifier">[</span><span class="Constant">'$parse'</span>, <span class="Constant">'$animate'</span>, <span class="Identifier">function</span>($parse, $animate) <span class="Identifier">{</span>
  <span class="Identifier">var</span> NG_REMOVED = <span class="Constant">'$$NG_REMOVED'</span>;
  <span class="Identifier">var</span> ngRepeatMinErr = minErr(<span class="Constant">'ngRepeat'</span>);
  <span class="Statement">return</span> <span class="Identifier">{</span>
    transclude: <span class="Constant">'element'</span>,
    priority: 1000,
    terminal: <span class="Constant">true</span>,
    $$tlb: <span class="Constant">true</span>,
    link: <span class="Identifier">function</span>($scope, $element, $attr, ctrl, $transclude)<span class="Identifier">{</span>
        <span class="Identifier">var</span> expression = $attr.ngRepeat;
        <span class="Identifier">var</span> match = expression.match(<span class="Constant">/^\s*(.+)\s+in\s+(.*?)\s*(\s+track\s+by\s+(.+)\s*)?$/</span>),
          trackByExp, trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn,
          lhs, rhs, valueIdentifier, keyIdentifier,
          hashFnLocals = <span class="Identifier">{</span>$id: hashKey<span class="Identifier">}</span>;

        <span class="Statement">if</span> (!match) <span class="Identifier">{</span>
          <span class="Statement">throw</span> ngRepeatMinErr(<span class="Constant">'iexp'</span>, <span class="Constant">&quot;Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.&quot;</span>,
            expression);
        <span class="Identifier">}</span>

        lhs = match<span class="Identifier">[</span>1<span class="Identifier">]</span>;
        rhs = match<span class="Identifier">[</span>2<span class="Identifier">]</span>;
        trackByExp = match<span class="Identifier">[</span>4<span class="Identifier">]</span>;

        <span class="Statement">if</span> (trackByExp) <span class="Identifier">{</span>
          trackByExpGetter = $parse(trackByExp);
          trackByIdExpFn = <span class="Identifier">function</span>(key, value, index) <span class="Identifier">{</span>
            <span class="Comment">// assign key, value, and $index to the locals so that they can be used in hash functions</span>
            <span class="Statement">if</span> (keyIdentifier) hashFnLocals<span class="Identifier">[</span>keyIdentifier<span class="Identifier">]</span> = key;
            hashFnLocals<span class="Identifier">[</span>valueIdentifier<span class="Identifier">]</span> = value;
            hashFnLocals.$index = index;
            <span class="Statement">return</span> trackByExpGetter($scope, hashFnLocals);
          <span class="Identifier">}</span>;
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          trackByIdArrayFn = <span class="Identifier">function</span>(key, value) <span class="Identifier">{</span>
            <span class="Statement">return</span> hashKey(value);
          <span class="Identifier">}</span>;
          trackByIdObjFn = <span class="Identifier">function</span>(key) <span class="Identifier">{</span>
            <span class="Statement">return</span> key;
          <span class="Identifier">}</span>;
        <span class="Identifier">}</span>

        match = lhs.match(<span class="Constant">/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/</span>);
        <span class="Statement">if</span> (!match) <span class="Identifier">{</span>
          <span class="Statement">throw</span> ngRepeatMinErr(<span class="Constant">'iidexp'</span>, <span class="Constant">&quot;'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.&quot;</span>,
                                                                    lhs);
        <span class="Identifier">}</span>
        valueIdentifier = match<span class="Identifier">[</span>3<span class="Identifier">]</span> || match<span class="Identifier">[</span>1<span class="Identifier">]</span>;
        keyIdentifier = match<span class="Identifier">[</span>2<span class="Identifier">]</span>;

        <span class="Comment">// Store a list of elements from previous run. This is a hash where key is the item from the</span>
        <span class="Comment">// iterator, and the value is objects with following properties.</span>
        <span class="Comment">//   - scope: bound scope</span>
        <span class="Comment">//   - element: previous element.</span>
        <span class="Comment">//   - index: position</span>
        <span class="Identifier">var</span> lastBlockMap = <span class="Identifier">{}</span>;

        <span class="Comment">//watch props</span>
        $scope.$watchCollection(rhs, <span class="Identifier">function</span> ngRepeatAction(collection)<span class="Identifier">{</span>
          <span class="Identifier">var</span> index, length,
              previousNode = $element<span class="Identifier">[</span>0<span class="Identifier">]</span>,     <span class="Comment">// current position of the node</span>
              nextNode,
              <span class="Comment">// Same as lastBlockMap but it has the current state. It will become the</span>
              <span class="Comment">// lastBlockMap on the next iteration.</span>
              nextBlockMap = <span class="Identifier">{}</span>,
              arrayLength,
              childScope,
              key, value, <span class="Comment">// key/value of iteration</span>
              trackById,
              trackByIdFn,
              collectionKeys,
              block,       <span class="Comment">// last object information {scope, element, id}</span>
              nextBlockOrder = <span class="Identifier">[]</span>,
              elementsToRemove;


          <span class="Statement">if</span> (isArrayLike(collection)) <span class="Identifier">{</span>
            collectionKeys = collection;
            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
            <span class="Comment">// if object, extract keys, sort them and use to determine order of iteration over obj props</span>
            collectionKeys = <span class="Identifier">[]</span>;
            <span class="Statement">for</span> (key <span class="Statement">in</span> collection) <span class="Identifier">{</span>
              <span class="Statement">if</span> (collection.hasOwnProperty(key) &amp;&amp; key.charAt(0) != <span class="Constant">'$'</span>) <span class="Identifier">{</span>
                collectionKeys.push(key);
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>
            collectionKeys.sort();
          <span class="Identifier">}</span>

          arrayLength = collectionKeys.length;

          <span class="Comment">// locate existing items</span>
          length = nextBlockOrder.length = collectionKeys.length;
          <span class="Statement">for</span>(index = 0; index &lt; length; index++) <span class="Identifier">{</span>
           key = (collection === collectionKeys) ? index : collectionKeys<span class="Identifier">[</span>index<span class="Identifier">]</span>;
           value = collection<span class="Identifier">[</span>key<span class="Identifier">]</span>;
           trackById = trackByIdFn(key, value, index);
           assertNotHasOwnProperty(trackById, <span class="Constant">'`track by` id'</span>);
           <span class="Statement">if</span>(lastBlockMap.hasOwnProperty(trackById)) <span class="Identifier">{</span>
             block = lastBlockMap<span class="Identifier">[</span>trackById<span class="Identifier">]</span>;
             <span class="Statement">delete</span> lastBlockMap<span class="Identifier">[</span>trackById<span class="Identifier">]</span>;
             nextBlockMap<span class="Identifier">[</span>trackById<span class="Identifier">]</span> = block;
             nextBlockOrder<span class="Identifier">[</span>index<span class="Identifier">]</span> = block;
           <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (nextBlockMap.hasOwnProperty(trackById)) <span class="Identifier">{</span>
             <span class="Comment">// restore lastBlockMap</span>
             forEach(nextBlockOrder, <span class="Identifier">function</span>(block) <span class="Identifier">{</span>
               <span class="Statement">if</span> (block &amp;&amp; block.scope) lastBlockMap<span class="Identifier">[</span>block.id<span class="Identifier">]</span> = block;
             <span class="Identifier">}</span>);
             <span class="Comment">// This is a duplicate and we need to throw an error</span>
             <span class="Statement">throw</span> ngRepeatMinErr(<span class="Constant">'dupes'</span>, <span class="Constant">&quot;Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}&quot;</span>,
                                                                                                                                                    expression,       trackById);
           <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
             <span class="Comment">// new never before seen block</span>
             nextBlockOrder<span class="Identifier">[</span>index<span class="Identifier">]</span> = <span class="Identifier">{</span> id: trackById <span class="Identifier">}</span>;
             nextBlockMap<span class="Identifier">[</span>trackById<span class="Identifier">]</span> = <span class="Constant">false</span>;
           <span class="Identifier">}</span>
         <span class="Identifier">}</span>

          <span class="Comment">// remove existing items</span>
          <span class="Statement">for</span> (key <span class="Statement">in</span> lastBlockMap) <span class="Identifier">{</span>
            <span class="Comment">// lastBlockMap is our own object so we don't need to use special hasOwnPropertyFn</span>
            <span class="Statement">if</span> (lastBlockMap.hasOwnProperty(key)) <span class="Identifier">{</span>
              block = lastBlockMap<span class="Identifier">[</span>key<span class="Identifier">]</span>;
              elementsToRemove = getBlockElements(block.clone);
              $animate.leave(elementsToRemove);
              forEach(elementsToRemove, <span class="Identifier">function</span>(element) <span class="Identifier">{</span> element<span class="Identifier">[</span>NG_REMOVED<span class="Identifier">]</span> = <span class="Constant">true</span>; <span class="Identifier">}</span>);
              block.scope.$destroy();
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>

          <span class="Comment">// we are not using forEach for perf reasons (trying to avoid #call)</span>
          <span class="Statement">for</span> (index = 0, length = collectionKeys.length; index &lt; length; index++) <span class="Identifier">{</span>
            key = (collection === collectionKeys) ? index : collectionKeys<span class="Identifier">[</span>index<span class="Identifier">]</span>;
            value = collection<span class="Identifier">[</span>key<span class="Identifier">]</span>;
            block = nextBlockOrder<span class="Identifier">[</span>index<span class="Identifier">]</span>;
            <span class="Statement">if</span> (nextBlockOrder<span class="Identifier">[</span>index - 1<span class="Identifier">]</span>) previousNode = getBlockEnd(nextBlockOrder<span class="Identifier">[</span>index - 1<span class="Identifier">]</span>);

            <span class="Statement">if</span> (block.scope) <span class="Identifier">{</span>
              <span class="Comment">// if we have already seen this object, then we need to reuse the</span>
              <span class="Comment">// associated scope/element</span>
              childScope = block.scope;

              nextNode = previousNode;
              <span class="Statement">do</span> <span class="Identifier">{</span>
                nextNode = nextNode.nextSibling;
              <span class="Identifier">}</span> <span class="Statement">while</span>(nextNode &amp;&amp; nextNode<span class="Identifier">[</span>NG_REMOVED<span class="Identifier">]</span>);

              <span class="Statement">if</span> (getBlockStart(block) != nextNode) <span class="Identifier">{</span>
                <span class="Comment">// existing item which got moved</span>
                $animate.move(getBlockElements(block.clone), <span class="Statement">null</span>, jqLite(previousNode));
              <span class="Identifier">}</span>
              previousNode = getBlockEnd(block);
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
              <span class="Comment">// new item which we don't know about</span>
              childScope = $scope.$<span class="Statement">new</span>();
            <span class="Identifier">}</span>

            childScope<span class="Identifier">[</span>valueIdentifier<span class="Identifier">]</span> = value;
            <span class="Statement">if</span> (keyIdentifier) childScope<span class="Identifier">[</span>keyIdentifier<span class="Identifier">]</span> = key;
            childScope.$index = index;
            childScope.$first = (index === 0);
            childScope.$last = (index === (arrayLength - 1));
            childScope.$middle = !(childScope.$first || childScope.$last);
            <span class="Comment">// jshint bitwise: false</span>
            childScope.$odd = !(childScope.$even = (index&amp;1) === 0);
            <span class="Comment">// jshint bitwise: true</span>

            <span class="Statement">if</span> (!block.scope) <span class="Identifier">{</span>
              $transclude(childScope, <span class="Identifier">function</span>(clone) <span class="Identifier">{</span>
                clone<span class="Identifier">[</span>clone.length++<span class="Identifier">]</span> = <span class="Statement">document</span>.createComment(<span class="Constant">' end ngRepeat: '</span> + expression + <span class="Constant">' '</span>);
                $animate.enter(clone, <span class="Statement">null</span>, jqLite(previousNode));
                previousNode = clone;
                block.scope = childScope;
                <span class="Comment">// Note: We only need the first/last node of the cloned nodes.</span>
                <span class="Comment">// However, we need to keep the reference to the jqlite wrapper as it might be changed later</span>
                <span class="Comment">// by a directive with templateUrl when it's template arrives.</span>
                block.clone = clone;
                nextBlockMap<span class="Identifier">[</span>block.id<span class="Identifier">]</span> = block;
              <span class="Identifier">}</span>);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
          lastBlockMap = nextBlockMap;
        <span class="Identifier">}</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;

  <span class="Identifier">function</span> getBlockStart(block) <span class="Identifier">{</span>
    <span class="Statement">return</span> block.clone<span class="Identifier">[</span>0<span class="Identifier">]</span>;
  <span class="Identifier">}</span>

  <span class="Identifier">function</span> getBlockEnd(block) <span class="Identifier">{</span>
    <span class="Statement">return</span> block.clone<span class="Identifier">[</span>block.clone.length - 1<span class="Identifier">]</span>;
  <span class="Identifier">}</span>
<span class="Identifier">}]</span>;

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngShow</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngShow` directive shows or hides the given HTML element based on the expression</span>
<span class="Comment"> * provided to the ngShow attribute. The element is shown or hidden by removing or adding</span>
<span class="Comment"> * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined</span>
<span class="Comment"> * in AngularJS and sets the display style to none (using an !important flag).</span>
<span class="Comment"> * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * &lt;!-- when $scope.myValue is truthy (element is visible) --&gt;</span>
<span class="Comment"> * &lt;div ng-show=&quot;myValue&quot;&gt;&lt;/div&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;!-- when $scope.myValue is falsy (element is hidden) --&gt;</span>
<span class="Comment"> * &lt;div ng-show=&quot;myValue&quot; class=&quot;ng-hide&quot;&gt;&lt;/div&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * When the ngShow expression evaluates to false then the ng-hide CSS class is added to the class attribute</span>
<span class="Comment"> * on the element causing it to become hidden. When true, the ng-hide CSS class is removed</span>
<span class="Comment"> * from the element causing the element not to appear hidden.</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## Why is !important used?</span>
<span class="Comment"> *</span>
<span class="Comment"> * You may be wondering why !important is used for the .ng-hide CSS class. This is because the `.ng-hide` selector</span>
<span class="Comment"> * can be easily overridden by heavier selectors. For example, something as simple</span>
<span class="Comment"> * as changing the display style on a HTML list item would make hidden elements appear visible.</span>
<span class="Comment"> * This also becomes a bigger issue when dealing with CSS frameworks.</span>
<span class="Comment"> *</span>
<span class="Comment"> * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector</span>
<span class="Comment"> * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the</span>
<span class="Comment"> * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.</span>
<span class="Comment"> *</span>
<span class="Comment"> * ### Overriding .ng-hide</span>
<span class="Comment"> *</span>
<span class="Comment"> * If you wish to change the hide behavior with ngShow/ngHide then this can be achieved by</span>
<span class="Comment"> * restating the styles for the .ng-hide class in CSS:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * .ng-hide {</span>
<span class="Comment"> *   //!annotate CSS Specificity|Not to worry, this will override the AngularJS default...</span>
<span class="Comment"> *   display:block!important;</span>
<span class="Comment"> *</span>
<span class="Comment"> *   //this is just another form of hiding an element</span>
<span class="Comment"> *   position:absolute;</span>
<span class="Comment"> *   top:-9999px;</span>
<span class="Comment"> *   left:-9999px;</span>
<span class="Comment"> * }</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * Just remember to include the important flag so the CSS override will function.</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## A note about animations with ngShow</span>
<span class="Comment"> *</span>
<span class="Comment"> * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression</span>
<span class="Comment"> * is true and false. This system works like the animation system present with ngClass except that</span>
<span class="Comment"> * you must also include the !important flag to override the display property</span>
<span class="Comment"> * so that you can perform an animation when the element is hidden during the time of the animation.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * //</span>
<span class="Comment"> * //a working example can be found at the bottom of this page</span>
<span class="Comment"> * //</span>
<span class="Comment"> * .my-element.ng-hide-add, .my-element.ng-hide-remove {</span>
<span class="Comment"> *   transition:0.5s linear all;</span>
<span class="Comment"> *   display:block!important;</span>
<span class="Comment"> * }</span>
<span class="Comment"> *</span>
<span class="Comment"> * .my-element.ng-hide-add { ... }</span>
<span class="Comment"> * .my-element.ng-hide-add.ng-hide-add-active { ... }</span>
<span class="Comment"> * .my-element.ng-hide-remove { ... }</span>
<span class="Comment"> * .my-element.ng-hide-remove.ng-hide-remove-active { ... }</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @animations</span>
<span class="Comment"> * addClass: .ng-hide - happens after the ngShow expression evaluates to a truthy value and the just before contents are set to visible</span>
<span class="Comment"> * removeClass: .ng-hide - happens after the ngShow expression evaluates to a non truthy value and just before the contents are set to hidden</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngShow If the {@link guide/expression expression} is truthy</span>
<span class="Comment"> *     then the element is shown or hidden respectively.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">  &lt;example animations=&quot;true&quot;&gt;</span>
<span class="Comment">    &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">      Click me: &lt;input type=&quot;checkbox&quot; ng-model=&quot;checked&quot;&gt;&lt;br/&gt;</span>
<span class="Comment">      &lt;div&gt;</span>
<span class="Comment">        Show:</span>
<span class="Comment">        &lt;div class=&quot;check-element animate-show&quot; ng-show=&quot;checked&quot;&gt;</span>
<span class="Comment">          &lt;span class=&quot;icon-thumbs-up&quot;&gt;&lt;/span&gt; I show up when your checkbox is checked.</span>
<span class="Comment">        &lt;/div&gt;</span>
<span class="Comment">      &lt;/div&gt;</span>
<span class="Comment">      &lt;div&gt;</span>
<span class="Comment">        Hide:</span>
<span class="Comment">        &lt;div class=&quot;check-element animate-show&quot; ng-hide=&quot;checked&quot;&gt;</span>
<span class="Comment">          &lt;span class=&quot;icon-thumbs-down&quot;&gt;&lt;/span&gt; I hide when your checkbox is checked.</span>
<span class="Comment">        &lt;/div&gt;</span>
<span class="Comment">      &lt;/div&gt;</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;animations.css&quot;&gt;</span>
<span class="Comment">      .animate-show {</span>
<span class="Comment">        -webkit-transition:all linear 0.5s;</span>
<span class="Comment">        transition:all linear 0.5s;</span>
<span class="Comment">        line-height:20px;</span>
<span class="Comment">        opacity:1;</span>
<span class="Comment">        padding:10px;</span>
<span class="Comment">        border:1px solid black;</span>
<span class="Comment">        background:white;</span>
<span class="Comment">      }</span>

<span class="Comment">      .animate-show.ng-hide-add,</span>
<span class="Comment">      .animate-show.ng-hide-remove {</span>
<span class="Comment">        display:block!important;</span>
<span class="Comment">      }</span>

<span class="Comment">      .animate-show.ng-hide {</span>
<span class="Comment">        line-height:0;</span>
<span class="Comment">        opacity:0;</span>
<span class="Comment">        padding:0 10px;</span>
<span class="Comment">      }</span>

<span class="Comment">      .check-element {</span>
<span class="Comment">        padding:10px;</span>
<span class="Comment">        border:1px solid black;</span>
<span class="Comment">        background:white;</span>
<span class="Comment">      }</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;scenario.js&quot;&gt;</span>
<span class="Comment">       it('should check ng-show / ng-hide', function() {</span>
<span class="Comment">         expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);</span>
<span class="Comment">         expect(element('.doc-example-live span:last:visible').count()).toEqual(1);</span>

<span class="Comment">         input('checked').check();</span>

<span class="Comment">         expect(element('.doc-example-live span:first:visible').count()).toEqual(1);</span>
<span class="Comment">         expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);</span>
<span class="Comment">       });</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">  &lt;/example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngShowDirective = <span class="Identifier">[</span><span class="Constant">'$animate'</span>, <span class="Identifier">function</span>($animate) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">function</span>(scope, element, attr) <span class="Identifier">{</span>
    scope.$watch(attr.ngShow, <span class="Identifier">function</span> ngShowWatchAction(value)<span class="Identifier">{</span>
      $animate<span class="Identifier">[</span>toBoolean(value) ? <span class="Constant">'removeClass'</span> : <span class="Constant">'addClass'</span><span class="Identifier">]</span>(element, <span class="Constant">'ng-hide'</span>);
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>;
<span class="Identifier">}]</span>;


<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngHide</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngHide` directive shows or hides the given HTML element based on the expression</span>
<span class="Comment"> * provided to the ngHide attribute. The element is shown or hidden by removing or adding</span>
<span class="Comment"> * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined</span>
<span class="Comment"> * in AngularJS and sets the display style to none (using an !important flag).</span>
<span class="Comment"> * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * &lt;!-- when $scope.myValue is truthy (element is hidden) --&gt;</span>
<span class="Comment"> * &lt;div ng-hide=&quot;myValue&quot;&gt;&lt;/div&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;!-- when $scope.myValue is falsy (element is visible) --&gt;</span>
<span class="Comment"> * &lt;div ng-hide=&quot;myValue&quot; class=&quot;ng-hide&quot;&gt;&lt;/div&gt;</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * When the ngHide expression evaluates to true then the .ng-hide CSS class is added to the class attribute</span>
<span class="Comment"> * on the element causing it to become hidden. When false, the ng-hide CSS class is removed</span>
<span class="Comment"> * from the element causing the element not to appear hidden.</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## Why is !important used?</span>
<span class="Comment"> *</span>
<span class="Comment"> * You may be wondering why !important is used for the .ng-hide CSS class. This is because the `.ng-hide` selector</span>
<span class="Comment"> * can be easily overridden by heavier selectors. For example, something as simple</span>
<span class="Comment"> * as changing the display style on a HTML list item would make hidden elements appear visible.</span>
<span class="Comment"> * This also becomes a bigger issue when dealing with CSS frameworks.</span>
<span class="Comment"> *</span>
<span class="Comment"> * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector</span>
<span class="Comment"> * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the</span>
<span class="Comment"> * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.</span>
<span class="Comment"> *</span>
<span class="Comment"> * ### Overriding .ng-hide</span>
<span class="Comment"> *</span>
<span class="Comment"> * If you wish to change the hide behavior with ngShow/ngHide then this can be achieved by</span>
<span class="Comment"> * restating the styles for the .ng-hide class in CSS:</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * .ng-hide {</span>
<span class="Comment"> *   //!annotate CSS Specificity|Not to worry, this will override the AngularJS default...</span>
<span class="Comment"> *   display:block!important;</span>
<span class="Comment"> *</span>
<span class="Comment"> *   //this is just another form of hiding an element</span>
<span class="Comment"> *   position:absolute;</span>
<span class="Comment"> *   top:-9999px;</span>
<span class="Comment"> *   left:-9999px;</span>
<span class="Comment"> * }</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * Just remember to include the important flag so the CSS override will function.</span>
<span class="Comment"> *</span>
<span class="Comment"> * ## A note about animations with ngHide</span>
<span class="Comment"> *</span>
<span class="Comment"> * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression</span>
<span class="Comment"> * is true and false. This system works like the animation system present with ngClass, except that</span>
<span class="Comment"> * you must also include the !important flag to override the display property so</span>
<span class="Comment"> * that you can perform an animation when the element is hidden during the time of the animation.</span>
<span class="Comment"> *</span>
<span class="Comment"> * &lt;pre&gt;</span>
<span class="Comment"> * //</span>
<span class="Comment"> * //a working example can be found at the bottom of this page</span>
<span class="Comment"> * //</span>
<span class="Comment"> * .my-element.ng-hide-add, .my-element.ng-hide-remove {</span>
<span class="Comment"> *   transition:0.5s linear all;</span>
<span class="Comment"> *   display:block!important;</span>
<span class="Comment"> * }</span>
<span class="Comment"> *</span>
<span class="Comment"> * .my-element.ng-hide-add { ... }</span>
<span class="Comment"> * .my-element.ng-hide-add.ng-hide-add-active { ... }</span>
<span class="Comment"> * .my-element.ng-hide-remove { ... }</span>
<span class="Comment"> * .my-element.ng-hide-remove.ng-hide-remove-active { ... }</span>
<span class="Comment"> * &lt;/pre&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @animations</span>
<span class="Comment"> * removeClass: .ng-hide - happens after the ngHide expression evaluates to a truthy value and just before the contents are set to hidden</span>
<span class="Comment"> * addClass: .ng-hide - happens after the ngHide expression evaluates to a non truthy value and just before the contents are set to visible</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngHide If the {@link guide/expression expression} is truthy then</span>
<span class="Comment"> *     the element is shown or hidden respectively.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">  &lt;example animations=&quot;true&quot;&gt;</span>
<span class="Comment">    &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">      Click me: &lt;input type=&quot;checkbox&quot; ng-model=&quot;checked&quot;&gt;&lt;br/&gt;</span>
<span class="Comment">      &lt;div&gt;</span>
<span class="Comment">        Show:</span>
<span class="Comment">        &lt;div class=&quot;check-element animate-hide&quot; ng-show=&quot;checked&quot;&gt;</span>
<span class="Comment">          &lt;span class=&quot;icon-thumbs-up&quot;&gt;&lt;/span&gt; I show up when your checkbox is checked.</span>
<span class="Comment">        &lt;/div&gt;</span>
<span class="Comment">      &lt;/div&gt;</span>
<span class="Comment">      &lt;div&gt;</span>
<span class="Comment">        Hide:</span>
<span class="Comment">        &lt;div class=&quot;check-element animate-hide&quot; ng-hide=&quot;checked&quot;&gt;</span>
<span class="Comment">          &lt;span class=&quot;icon-thumbs-down&quot;&gt;&lt;/span&gt; I hide when your checkbox is checked.</span>
<span class="Comment">        &lt;/div&gt;</span>
<span class="Comment">      &lt;/div&gt;</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;animations.css&quot;&gt;</span>
<span class="Comment">      .animate-hide {</span>
<span class="Comment">        -webkit-transition:all linear 0.5s;</span>
<span class="Comment">        transition:all linear 0.5s;</span>
<span class="Comment">        line-height:20px;</span>
<span class="Comment">        opacity:1;</span>
<span class="Comment">        padding:10px;</span>
<span class="Comment">        border:1px solid black;</span>
<span class="Comment">        background:white;</span>
<span class="Comment">      }</span>

<span class="Comment">      .animate-hide.ng-hide-add,</span>
<span class="Comment">      .animate-hide.ng-hide-remove {</span>
<span class="Comment">        display:block!important;</span>
<span class="Comment">      }</span>

<span class="Comment">      .animate-hide.ng-hide {</span>
<span class="Comment">        line-height:0;</span>
<span class="Comment">        opacity:0;</span>
<span class="Comment">        padding:0 10px;</span>
<span class="Comment">      }</span>

<span class="Comment">      .check-element {</span>
<span class="Comment">        padding:10px;</span>
<span class="Comment">        border:1px solid black;</span>
<span class="Comment">        background:white;</span>
<span class="Comment">      }</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;scenario.js&quot;&gt;</span>
<span class="Comment">       it('should check ng-show / ng-hide', function() {</span>
<span class="Comment">         expect(element('.doc-example-live .check-element:first:hidden').count()).toEqual(1);</span>
<span class="Comment">         expect(element('.doc-example-live .check-element:last:visible').count()).toEqual(1);</span>

<span class="Comment">         input('checked').check();</span>

<span class="Comment">         expect(element('.doc-example-live .check-element:first:visible').count()).toEqual(1);</span>
<span class="Comment">         expect(element('.doc-example-live .check-element:last:hidden').count()).toEqual(1);</span>
<span class="Comment">       });</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">  &lt;/example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngHideDirective = <span class="Identifier">[</span><span class="Constant">'$animate'</span>, <span class="Identifier">function</span>($animate) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">function</span>(scope, element, attr) <span class="Identifier">{</span>
    scope.$watch(attr.ngHide, <span class="Identifier">function</span> ngHideWatchAction(value)<span class="Identifier">{</span>
      $animate<span class="Identifier">[</span>toBoolean(value) ? <span class="Constant">'addClass'</span> : <span class="Constant">'removeClass'</span><span class="Identifier">]</span>(element, <span class="Constant">'ng-hide'</span>);
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>;
<span class="Identifier">}]</span>;

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngStyle</span>
<span class="Comment"> * @restrict AC</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The `ngStyle` directive allows you to set CSS style on an HTML element conditionally.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> * @param {expression} ngStyle {@link guide/expression Expression} which evals to an</span>
<span class="Comment"> *      object whose keys are CSS style names and values are corresponding values for those CSS</span>
<span class="Comment"> *      keys.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;example&gt;</span>
<span class="Comment">     &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">        &lt;input type=&quot;button&quot; value=&quot;set&quot; ng-click=&quot;myStyle={color:'red'}&quot;&gt;</span>
<span class="Comment">        &lt;input type=&quot;button&quot; value=&quot;clear&quot; ng-click=&quot;myStyle={}&quot;&gt;</span>
<span class="Comment">        &lt;br/&gt;</span>
<span class="Comment">        &lt;span ng-style=&quot;myStyle&quot;&gt;Sample Text&lt;/span&gt;</span>
<span class="Comment">        &lt;pre&gt;myStyle={{myStyle}}&lt;/pre&gt;</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">     &lt;file name=&quot;style.css&quot;&gt;</span>
<span class="Comment">       span {</span>
<span class="Comment">         color: black;</span>
<span class="Comment">       }</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">     &lt;file name=&quot;scenario.js&quot;&gt;</span>
<span class="Comment">       it('should check ng-style', function() {</span>
<span class="Comment">         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');</span>
<span class="Comment">         element('.doc-example-live :button[value=set]').click();</span>
<span class="Comment">         expect(element('.doc-example-live span').css('color')).toBe('rgb(255, 0, 0)');</span>
<span class="Comment">         element('.doc-example-live :button[value=clear]').click();</span>
<span class="Comment">         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');</span>
<span class="Comment">       });</span>
<span class="Comment">     &lt;/file&gt;</span>
<span class="Comment">   &lt;/example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngStyleDirective = ngDirective(<span class="Identifier">function</span>(scope, element, attr) <span class="Identifier">{</span>
  scope.$watch(attr.ngStyle, <span class="Identifier">function</span> ngStyleWatchAction(newStyles, oldStyles) <span class="Identifier">{</span>
    <span class="Statement">if</span> (oldStyles &amp;&amp; (newStyles !== oldStyles)) <span class="Identifier">{</span>
      forEach(oldStyles, <span class="Identifier">function</span>(val, style) <span class="Identifier">{</span> element.css(style, <span class="Constant">''</span>);<span class="Identifier">}</span>);
    <span class="Identifier">}</span>
    <span class="Statement">if</span> (newStyles) element.css(newStyles);
  <span class="Identifier">}</span>, <span class="Constant">true</span>);
<span class="Identifier">}</span>);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngSwitch</span>
<span class="Comment"> * @restrict EA</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * The ngSwitch directive is used to conditionally swap DOM structure on your template based on a scope expression.</span>
<span class="Comment"> * Elements within ngSwitch but without ngSwitchWhen or ngSwitchDefault directives will be preserved at the location</span>
<span class="Comment"> * as specified in the template.</span>
<span class="Comment"> *</span>
<span class="Comment"> * The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it</span>
<span class="Comment"> * from the template cache), ngSwitch simply choses one of the nested elements and makes it visible based on which element</span>
<span class="Comment"> * matches the value obtained from the evaluated expression. In other words, you define a container element</span>
<span class="Comment"> * (where you place the directive), place an expression on the **on=&quot;...&quot; attribute**</span>
<span class="Comment"> * (or the **ng-switch=&quot;...&quot; attribute**), define any inner elements inside of the directive and place</span>
<span class="Comment"> * a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on</span>
<span class="Comment"> * expression is evaluated. If a matching expression is not found via a when attribute then an element with the default</span>
<span class="Comment"> * attribute is displayed.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @animations</span>
<span class="Comment"> * enter - happens after the ngSwitch contents change and the matched child element is placed inside the container</span>
<span class="Comment"> * leave - happens just after the ngSwitch contents change and just before the former contents are removed from the DOM</span>
<span class="Comment"> *</span>
<span class="Comment"> * @usage</span>
<span class="Comment"> * &lt;ANY ng-switch=&quot;expression&quot;&gt;</span>
<span class="Comment"> *   &lt;ANY ng-switch-when=&quot;matchValue1&quot;&gt;...&lt;/ANY&gt;</span>
<span class="Comment"> *   &lt;ANY ng-switch-when=&quot;matchValue2&quot;&gt;...&lt;/ANY&gt;</span>
<span class="Comment"> *   &lt;ANY ng-switch-default&gt;...&lt;/ANY&gt;</span>
<span class="Comment"> * &lt;/ANY&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> * @scope</span>
<span class="Comment"> * @priority 800</span>
<span class="Comment"> * @param {*} ngSwitch|on expression to match against &lt;tt&gt;ng-switch-when&lt;/tt&gt;.</span>
<span class="Comment"> * @paramDescription</span>
<span class="Comment"> * On child elements add:</span>
<span class="Comment"> *</span>
<span class="Comment"> * * `ngSwitchWhen`: the case statement to match against. If match then this</span>
<span class="Comment"> *   case will be displayed. If the same match appears multiple times, all the</span>
<span class="Comment"> *   elements will be displayed.</span>
<span class="Comment"> * * `ngSwitchDefault`: the default case when no other case match. If there</span>
<span class="Comment"> *   are multiple default cases, all of them will be displayed when no other</span>
<span class="Comment"> *   case match.</span>
<span class="Comment"> *</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">  &lt;example animations=&quot;true&quot;&gt;</span>
<span class="Comment">    &lt;file name=&quot;index.html&quot;&gt;</span>
<span class="Comment">      &lt;div ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">        &lt;select ng-model=&quot;selection&quot; ng-options=&quot;item for item in items&quot;&gt;</span>
<span class="Comment">        &lt;/select&gt;</span>
<span class="Comment">        &lt;tt&gt;selection={{selection}}&lt;/tt&gt;</span>
<span class="Comment">        &lt;hr/&gt;</span>
<span class="Comment">        &lt;div class=&quot;animate-switch-container&quot;</span>
<span class="Comment">          ng-switch on=&quot;selection&quot;&gt;</span>
<span class="Comment">            &lt;div class=&quot;animate-switch&quot; ng-switch-when=&quot;settings&quot;&gt;Settings Div&lt;/div&gt;</span>
<span class="Comment">            &lt;div class=&quot;animate-switch&quot; ng-switch-when=&quot;home&quot;&gt;Home Span&lt;/div&gt;</span>
<span class="Comment">            &lt;div class=&quot;animate-switch&quot; ng-switch-default&gt;default&lt;/div&gt;</span>
<span class="Comment">        &lt;/div&gt;</span>
<span class="Comment">      &lt;/div&gt;</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;script.js&quot;&gt;</span>
<span class="Comment">      function Ctrl($scope) {</span>
<span class="Comment">        $scope.items = ['settings', 'home', 'other'];</span>
<span class="Comment">        $scope.selection = $scope.items[0];</span>
<span class="Comment">      }</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;animations.css&quot;&gt;</span>
<span class="Comment">      .animate-switch-container {</span>
<span class="Comment">        position:relative;</span>
<span class="Comment">        background:white;</span>
<span class="Comment">        border:1px solid black;</span>
<span class="Comment">        height:40px;</span>
<span class="Comment">        overflow:hidden;</span>
<span class="Comment">      }</span>

<span class="Comment">      .animate-switch {</span>
<span class="Comment">        padding:10px;</span>
<span class="Comment">      }</span>

<span class="Comment">      .animate-switch.ng-animate {</span>
<span class="Comment">        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;</span>
<span class="Comment">        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;</span>

<span class="Comment">        position:absolute;</span>
<span class="Comment">        top:0;</span>
<span class="Comment">        left:0;</span>
<span class="Comment">        right:0;</span>
<span class="Comment">        bottom:0;</span>
<span class="Comment">      }</span>

<span class="Comment">      .animate-switch.ng-leave.ng-leave-active,</span>
<span class="Comment">      .animate-switch.ng-enter {</span>
<span class="Comment">        top:-50px;</span>
<span class="Comment">      }</span>
<span class="Comment">      .animate-switch.ng-leave,</span>
<span class="Comment">      .animate-switch.ng-enter.ng-enter-active {</span>
<span class="Comment">        top:0;</span>
<span class="Comment">      }</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">    &lt;file name=&quot;scenario.js&quot;&gt;</span>
<span class="Comment">      it('should start in settings', function() {</span>
<span class="Comment">        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Settings Div/);</span>
<span class="Comment">      });</span>
<span class="Comment">      it('should change to home', function() {</span>
<span class="Comment">        select('selection').option('home');</span>
<span class="Comment">        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Home Span/);</span>
<span class="Comment">      });</span>
<span class="Comment">      it('should select default', function() {</span>
<span class="Comment">        select('selection').option('other');</span>
<span class="Comment">        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/default/);</span>
<span class="Comment">      });</span>
<span class="Comment">    &lt;/file&gt;</span>
<span class="Comment">  &lt;/example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngSwitchDirective = <span class="Identifier">[</span><span class="Constant">'$animate'</span>, <span class="Identifier">function</span>($animate) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">{</span>
    restrict: <span class="Constant">'EA'</span>,
    require: <span class="Constant">'ngSwitch'</span>,

    <span class="Comment">// asks for $scope to fool the BC controller module</span>
    controller: <span class="Identifier">[</span><span class="Constant">'$scope'</span>, <span class="Identifier">function</span> ngSwitchController() <span class="Identifier">{</span>
     <span class="Identifier">this</span>.cases = <span class="Identifier">{}</span>;
    <span class="Identifier">}]</span>,
    link: <span class="Identifier">function</span>(scope, element, attr, ngSwitchController) <span class="Identifier">{</span>
      <span class="Identifier">var</span> watchExpr = attr.ngSwitch || attr.on,
          selectedTranscludes,
          selectedElements,
          selectedScopes = <span class="Identifier">[]</span>;

      scope.$watch(watchExpr, <span class="Identifier">function</span> ngSwitchWatchAction(value) <span class="Identifier">{</span>
        <span class="Statement">for</span> (<span class="Identifier">var</span> i= 0, ii=selectedScopes.length; i&lt;ii; i++) <span class="Identifier">{</span>
          selectedScopes<span class="Identifier">[</span>i<span class="Identifier">]</span>.$destroy();
          $animate.leave(selectedElements<span class="Identifier">[</span>i<span class="Identifier">]</span>);
        <span class="Identifier">}</span>

        selectedElements = <span class="Identifier">[]</span>;
        selectedScopes = <span class="Identifier">[]</span>;

        <span class="Statement">if</span> ((selectedTranscludes = ngSwitchController.cases<span class="Identifier">[</span><span class="Constant">'!'</span> + value<span class="Identifier">]</span> || ngSwitchController.cases<span class="Identifier">[</span><span class="Constant">'?'</span><span class="Identifier">]</span>)) <span class="Identifier">{</span>
          scope.$eval(attr.change);
          forEach(selectedTranscludes, <span class="Identifier">function</span>(selectedTransclude) <span class="Identifier">{</span>
            <span class="Identifier">var</span> selectedScope = scope.$<span class="Statement">new</span>();
            selectedScopes.push(selectedScope);
            selectedTransclude.transclude(selectedScope, <span class="Identifier">function</span>(caseElement) <span class="Identifier">{</span>
              <span class="Identifier">var</span> anchor = selectedTransclude.element;

              selectedElements.push(caseElement);
              $animate.enter(caseElement, anchor.<span class="Statement">parent</span>(), anchor);
            <span class="Identifier">}</span>);
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>);
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}]</span>;

<span class="Identifier">var</span> ngSwitchWhenDirective = ngDirective(<span class="Identifier">{</span>
  transclude: <span class="Constant">'element'</span>,
  priority: 800,
  require: <span class="Constant">'^ngSwitch'</span>,
  compile: <span class="Identifier">function</span>(element, attrs) <span class="Identifier">{</span>
    <span class="Statement">return</span> <span class="Identifier">function</span>(scope, element, attr, ctrl, $transclude) <span class="Identifier">{</span>
      ctrl.cases<span class="Identifier">[</span><span class="Constant">'!'</span> + attrs.ngSwitchWhen<span class="Identifier">]</span> = (ctrl.cases<span class="Identifier">[</span><span class="Constant">'!'</span> + attrs.ngSwitchWhen<span class="Identifier">]</span> || <span class="Identifier">[]</span>);
      ctrl.cases<span class="Identifier">[</span><span class="Constant">'!'</span> + attrs.ngSwitchWhen<span class="Identifier">]</span>.push(<span class="Identifier">{</span> transclude: $transclude, element: element <span class="Identifier">}</span>);
    <span class="Identifier">}</span>;
  <span class="Identifier">}</span>
<span class="Identifier">}</span>);

<span class="Identifier">var</span> ngSwitchDefaultDirective = ngDirective(<span class="Identifier">{</span>
  transclude: <span class="Constant">'element'</span>,
  priority: 800,
  require: <span class="Constant">'^ngSwitch'</span>,
  link: <span class="Identifier">function</span>(scope, element, attr, ctrl, $transclude) <span class="Identifier">{</span>
    ctrl.cases<span class="Identifier">[</span><span class="Constant">'?'</span><span class="Identifier">]</span> = (ctrl.cases<span class="Identifier">[</span><span class="Constant">'?'</span><span class="Identifier">]</span> || <span class="Identifier">[]</span>);
    ctrl.cases<span class="Identifier">[</span><span class="Constant">'?'</span><span class="Identifier">]</span>.push(<span class="Identifier">{</span> transclude: $transclude, element: element <span class="Identifier">}</span>);
   <span class="Identifier">}</span>
<span class="Identifier">}</span>);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:ngTransclude</span>
<span class="Comment"> * @restrict AC</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Directive that marks the insertion point for the transcluded DOM of the nearest parent directive that uses transclusion.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Any existing content of the element that this directive is placed on will be removed before the transcluded content is inserted.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @element ANY</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">   &lt;doc:example module=&quot;transclude&quot;&gt;</span>
<span class="Comment">     &lt;doc:source&gt;</span>
<span class="Comment">       &lt;script&gt;</span>
<span class="Comment">         function Ctrl($scope) {</span>
<span class="Comment">           $scope.title = 'Lorem Ipsum';</span>
<span class="Comment">           $scope.text = 'Neque porro quisquam est qui dolorem ipsum quia dolor...';</span>
<span class="Comment">         }</span>

<span class="Comment">         angular.module('transclude', [])</span>
<span class="Comment">          .directive('pane', function(){</span>
<span class="Comment">             return {</span>
<span class="Comment">               restrict: 'E',</span>
<span class="Comment">               transclude: true,</span>
<span class="Comment">               scope: { title:'@' },</span>
<span class="Comment">               template: '&lt;div style=&quot;border: 1px solid black;&quot;&gt;' +</span>
<span class="Comment">                           '&lt;div style=&quot;background-color: gray&quot;&gt;{{title}}&lt;/div&gt;' +</span>
<span class="Comment">                           '&lt;div ng-transclude&gt;&lt;/div&gt;' +</span>
<span class="Comment">                         '&lt;/div&gt;'</span>
<span class="Comment">             };</span>
<span class="Comment">         });</span>
<span class="Comment">       &lt;/script&gt;</span>
<span class="Comment">       &lt;div ng-controller=&quot;Ctrl&quot;&gt;</span>
<span class="Comment">         &lt;input ng-model=&quot;title&quot;&gt;&lt;br&gt;</span>
<span class="Comment">         &lt;textarea ng-model=&quot;text&quot;&gt;&lt;/textarea&gt; &lt;br/&gt;</span>
<span class="Comment">         &lt;pane title=&quot;{{title}}&quot;&gt;{{text}}&lt;/pane&gt;</span>
<span class="Comment">       &lt;/div&gt;</span>
<span class="Comment">     &lt;/doc:source&gt;</span>
<span class="Comment">     &lt;doc:scenario&gt;</span>
<span class="Comment">        it('should have transcluded', function() {</span>
<span class="Comment">          input('title').enter('TITLE');</span>
<span class="Comment">          input('text').enter('TEXT');</span>
<span class="Comment">          expect(binding('title')).toEqual('TITLE');</span>
<span class="Comment">          expect(binding('text')).toEqual('TEXT');</span>
<span class="Comment">        });</span>
<span class="Comment">     &lt;/doc:scenario&gt;</span>
<span class="Comment">   &lt;/doc:example&gt;</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> ngTranscludeDirective = ngDirective(<span class="Identifier">{</span>
  controller: <span class="Identifier">[</span><span class="Constant">'$element'</span>, <span class="Constant">'$transclude'</span>, <span class="Identifier">function</span>($element, $transclude) <span class="Identifier">{</span>
    <span class="Statement">if</span> (!$transclude) <span class="Identifier">{</span>
      <span class="Statement">throw</span> minErr(<span class="Constant">'ngTransclude'</span>)(<span class="Constant">'orphan'</span>,
          <span class="Constant">'Illegal use of ngTransclude directive in the template! '</span> +
          <span class="Constant">'No parent directive that requires a transclusion found. '</span> +
          <span class="Constant">'Element: {0}'</span>,
          startingTag($element));
    <span class="Identifier">}</span>

    <span class="Comment">// remember the transclusion fn but call it during linking so that we don't process transclusion before directives on</span>
    <span class="Comment">// the parent element even when the transclusion replaces the current element. (we can't use priority here because</span>
    <span class="Comment">// that applies only to compile fns and not controllers</span>
    <span class="Identifier">this</span>.$transclude = $transclude;
  <span class="Identifier">}]</span>,

  link: <span class="Identifier">function</span>($scope, $element, $attrs, controller) <span class="Identifier">{</span>
    controller.$transclude(<span class="Identifier">function</span>(clone) <span class="Identifier">{</span>
      $element.html(<span class="Constant">''</span>);
      $element.append(clone);
    <span class="Identifier">}</span>);
  <span class="Identifier">}</span>
<span class="Identifier">}</span>);

<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:script</span>
<span class="Comment"> * @restrict E</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * Load content of a script tag, with type `text/ng-template`, into `$templateCache`, so that the</span>
<span class="Comment"> * template can be used by `ngInclude`, `ngView` or directive templates.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {'text/ng-template'} type must be set to `'text/ng-template'`</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">  &lt;doc:example&gt;</span>
<span class="Comment">    &lt;doc:source&gt;</span>
<span class="Comment">      &lt;script type=&quot;text/ng-template&quot; id=&quot;/tpl.html&quot;&gt;</span>
<span class="Comment">        Content of the template.</span>
<span class="Comment">      &lt;/script&gt;</span>

<span class="Comment">      &lt;a ng-click=&quot;currentTpl='/tpl.html'&quot; id=&quot;tpl-link&quot;&gt;Load inlined template&lt;/a&gt;</span>
<span class="Comment">      &lt;div id=&quot;tpl-content&quot; ng-include src=&quot;currentTpl&quot;&gt;&lt;/div&gt;</span>
<span class="Comment">    &lt;/doc:source&gt;</span>
<span class="Comment">    &lt;doc:scenario&gt;</span>
<span class="Comment">      it('should load template defined inside script tag', function() {</span>
<span class="Comment">        element('#tpl-link').click();</span>
<span class="Comment">        expect(element('#tpl-content').text()).toMatch(/Content of the template/);</span>
<span class="Comment">      });</span>
<span class="Comment">    &lt;/doc:scenario&gt;</span>
<span class="Comment">  &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>
<span class="Identifier">var</span> scriptDirective = <span class="Identifier">[</span><span class="Constant">'$templateCache'</span>, <span class="Identifier">function</span>($templateCache) <span class="Identifier">{</span>
  <span class="Statement">return</span> <span class="Identifier">{</span>
    restrict: <span class="Constant">'E'</span>,
    terminal: <span class="Constant">true</span>,
    compile: <span class="Identifier">function</span>(element, attr) <span class="Identifier">{</span>
      <span class="Statement">if</span> (attr.type == <span class="Constant">'text/ng-template'</span>) <span class="Identifier">{</span>
        <span class="Identifier">var</span> templateUrl = attr.id,
            <span class="Comment">// IE is not consistent, in scripts we have to read .text but in other nodes we have to read .textContent</span>
            text = element<span class="Identifier">[</span>0<span class="Identifier">]</span>.text;

        $templateCache.put(templateUrl, text);
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}]</span>;

<span class="Identifier">var</span> ngOptionsMinErr = minErr(<span class="Constant">'ngOptions'</span>);
<span class="Comment">/**</span>
<span class="Comment"> * @ngdoc directive</span>
<span class="Comment"> * @name ng.directive:select</span>
<span class="Comment"> * @restrict E</span>
<span class="Comment"> *</span>
<span class="Comment"> * @description</span>
<span class="Comment"> * HTML `SELECT` element with angular data-binding.</span>
<span class="Comment"> *</span>
<span class="Comment"> * # `ngOptions`</span>
<span class="Comment"> *</span>
<span class="Comment"> * The `ngOptions` attribute can be used to dynamically generate a list of `&lt;option&gt;`</span>
<span class="Comment"> * elements for the `&lt;select&gt;` element using the array or object obtained by evaluating the</span>
<span class="Comment"> * `ngOptions` comprehension_expression.</span>
<span class="Comment"> *</span>
<span class="Comment"> * When an item in the `&lt;select&gt;` menu is selected, the array element or object property</span>
<span class="Comment"> * represented by the selected option will be bound to the model identified by the `ngModel`</span>
<span class="Comment"> * directive.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Optionally, a single hard-coded `&lt;option&gt;` element, with the value set to an empty string, can</span>
<span class="Comment"> * be nested into the `&lt;select&gt;` element. This element will then represent the `null` or &quot;not selected&quot;</span>
<span class="Comment"> * option. See example below for demonstration.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Note: `ngOptions` provides iterator facility for `&lt;option&gt;` element which should be used instead</span>
<span class="Comment"> * of {@link ng.directive:ngRepeat ngRepeat} when you want the</span>
<span class="Comment"> * `select` model to be bound to a non-string value. This is because an option element can only</span>
<span class="Comment"> * be bound to string values at present.</span>
<span class="Comment"> *</span>
<span class="Comment"> * @param {string} ngModel Assignable angular expression to data-bind to.</span>
<span class="Comment"> * @param {string=} name Property name of the form under which the control is published.</span>
<span class="Comment"> * @param {string=} required The control is considered valid only if value is entered.</span>
<span class="Comment"> * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to</span>
<span class="Comment"> *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of</span>
<span class="Comment"> *    `required` when you want to data-bind to the `required` attribute.</span>
<span class="Comment"> * @param {comprehension_expression=} ngOptions in one of the following forms:</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * for array data sources:</span>
<span class="Comment"> *     * `label` **`for`** `value` **`in`** `array`</span>
<span class="Comment"> *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`</span>
<span class="Comment"> *     * `label`  **`group by`** `group` **`for`** `value` **`in`** `array`</span>
<span class="Comment"> *     * `select` **`as`** `label` **`group by`** `group` **`for`** `value` **`in`** `array` **`track by`** `trackexpr`</span>
<span class="Comment"> *   * for object data sources:</span>
<span class="Comment"> *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`</span>
<span class="Comment"> *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) in`** `object`</span>
<span class="Comment"> *     * `label` **`group by`** `group` **`for (`**`key`**`,`** `value`**`) in`** `object`</span>
<span class="Comment"> *     * `select` **`as`** `label` **`group by`** `group`</span>
<span class="Comment"> *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`</span>
<span class="Comment"> *</span>
<span class="Comment"> * Where:</span>
<span class="Comment"> *</span>
<span class="Comment"> *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.</span>
<span class="Comment"> *   * `value`: local variable which will refer to each item in the `array` or each property value</span>
<span class="Comment"> *      of `object` during iteration.</span>
<span class="Comment"> *   * `key`: local variable which will refer to a property name in `object` during iteration.</span>
<span class="Comment"> *   * `label`: The result of this expression will be the label for `&lt;option&gt;` element. The</span>
<span class="Comment"> *     `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).</span>
<span class="Comment"> *   * `select`: The result of this expression will be bound to the model of the parent `&lt;select&gt;`</span>
<span class="Comment"> *      element. If not specified, `select` expression will default to `value`.</span>
<span class="Comment"> *   * `group`: The result of this expression will be used to group options using the `&lt;optgroup&gt;`</span>
<span class="Comment"> *      DOM element.</span>
<span class="Comment"> *   * `trackexpr`: Used when working with an array of objects. The result of this expression will be</span>
<span class="Comment"> *      used to identify the objects in the array. The `trackexpr` will most likely refer to the</span>
<span class="Comment"> *     `value` variable (e.g. `value.propertyName`).</span>
<span class="Comment"> *</span>
<span class="Comment"> * @example</span>
<span class="Comment">    &lt;doc:example&gt;</span>
<span class="Comment">      &lt;doc:source&gt;</span>
<span class="Comment">        &lt;script&gt;</span>
<span class="Comment">        function MyCntrl($scope) {</span>
<span class="Comment">          $scope.colors = [</span>
<span class="Comment">            {name:'black', shade:'dark'},</span>
<span class="Comment">            {name:'white', shade:'light'},</span>
<span class="Comment">            {name:'red', shade:'dark'},</span>
<span class="Comment">            {name:'blue', shade:'dark'},</span>
<span class="Comment">            {name:'yellow', shade:'light'}</span>
<span class="Comment">          ];</span>
<span class="Comment">          $scope.color = $scope.colors[2]; // red</span>
<span class="Comment">        }</span>
<span class="Comment">        &lt;/script&gt;</span>
<span class="Comment">        &lt;div ng-controller=&quot;MyCntrl&quot;&gt;</span>
<span class="Comment">          &lt;ul&gt;</span>
<span class="Comment">            &lt;li ng-repeat=&quot;color in colors&quot;&gt;</span>
<span class="Comment">              Name: &lt;input ng-model=&quot;color.name&quot;&gt;</span>
<span class="Comment">              [&lt;a href ng-click=&quot;colors.splice($index, 1)&quot;&gt;X&lt;/a&gt;]</span>
<span class="Comment">            &lt;/li&gt;</span>
<span class="Comment">            &lt;li&gt;</span>
<span class="Comment">              [&lt;a href ng-click=&quot;colors.push({})&quot;&gt;add&lt;/a&gt;]</span>
<span class="Comment">            &lt;/li&gt;</span>
<span class="Comment">          &lt;/ul&gt;</span>
<span class="Comment">          &lt;hr/&gt;</span>
<span class="Comment">          Color (null not allowed):</span>
<span class="Comment">          &lt;select ng-model=&quot;color&quot; ng-options=&quot;c.name for c in colors&quot;&gt;&lt;/select&gt;&lt;br&gt;</span>

<span class="Comment">          Color (null allowed):</span>
<span class="Comment">          &lt;span  class=&quot;nullable&quot;&gt;</span>
<span class="Comment">            &lt;select ng-model=&quot;color&quot; ng-options=&quot;c.name for c in colors&quot;&gt;</span>
<span class="Comment">              &lt;option value=&quot;&quot;&gt;-- choose color --&lt;/option&gt;</span>
<span class="Comment">            &lt;/select&gt;</span>
<span class="Comment">          &lt;/span&gt;&lt;br/&gt;</span>

<span class="Comment">          Color grouped by shade:</span>
<span class="Comment">          &lt;select ng-model=&quot;color&quot; ng-options=&quot;c.name group by c.shade for c in colors&quot;&gt;</span>
<span class="Comment">          &lt;/select&gt;&lt;br/&gt;</span>


<span class="Comment">          Select &lt;a href ng-click=&quot;color={name:'not in list'}&quot;&gt;bogus&lt;/a&gt;.&lt;br&gt;</span>
<span class="Comment">          &lt;hr/&gt;</span>
<span class="Comment">          Currently selected: {{ {selected_color:color}  }}</span>
<span class="Comment">          &lt;div style=&quot;border:solid 1px black; height:20px&quot;</span>
<span class="Comment">               ng-style=&quot;{'background-color':color.name}&quot;&gt;</span>
<span class="Comment">          &lt;/div&gt;</span>
<span class="Comment">        &lt;/div&gt;</span>
<span class="Comment">      &lt;/doc:source&gt;</span>
<span class="Comment">      &lt;doc:scenario&gt;</span>
<span class="Comment">         it('should check ng-options', function() {</span>
<span class="Comment">           expect(binding('{selected_color:color}')).toMatch('red');</span>
<span class="Comment">           select('color').option('0');</span>
<span class="Comment">           expect(binding('{selected_color:color}')).toMatch('black');</span>
<span class="Comment">           using('.nullable').select('color').option('');</span>
<span class="Comment">           expect(binding('{selected_color:color}')).toMatch('null');</span>
<span class="Comment">         });</span>
<span class="Comment">      &lt;/doc:scenario&gt;</span>
<span class="Comment">    &lt;/doc:example&gt;</span>
<span class="Comment"> */</span>

<span class="Identifier">var</span> ngOptionsDirective = valueFn(<span class="Identifier">{</span> terminal: <span class="Constant">true</span> <span class="Identifier">}</span>);
<span class="Comment">// jshint maxlen: false</span>
<span class="Identifier">var</span> selectDirective = <span class="Identifier">[</span><span class="Constant">'$compile'</span>, <span class="Constant">'$parse'</span>, <span class="Identifier">function</span>($compile,   $parse) <span class="Identifier">{</span>
                         <span class="Comment">//0000111110000000000022220000000000000000000000333300000000000000444444444444444000000000555555555555555000000066666666666666600000000000000007777000000000000000000088888</span>
  <span class="Identifier">var</span> NG_OPTIONS_REGEXP = <span class="Constant">/^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/</span>,
      nullModelCtrl = <span class="Identifier">{</span>$setViewValue: noop<span class="Identifier">}</span>;
<span class="Comment">// jshint maxlen: 100</span>

  <span class="Statement">return</span> <span class="Identifier">{</span>
    restrict: <span class="Constant">'E'</span>,
    require: <span class="Identifier">[</span><span class="Constant">'select'</span>, <span class="Constant">'?ngModel'</span><span class="Identifier">]</span>,
    controller: <span class="Identifier">[</span><span class="Constant">'$element'</span>, <span class="Constant">'$scope'</span>, <span class="Constant">'$attrs'</span>, <span class="Identifier">function</span>($element, $scope, $attrs) <span class="Identifier">{</span>
      <span class="Identifier">var</span> <span class="Statement">self</span> = <span class="Identifier">this</span>,
          optionsMap = <span class="Identifier">{}</span>,
          ngModelCtrl = nullModelCtrl,
          nullOption,
          unknownOption;


      <span class="Statement">self</span>.databound = $attrs.ngModel;


      <span class="Statement">self</span>.init = <span class="Identifier">function</span>(ngModelCtrl_, nullOption_, unknownOption_) <span class="Identifier">{</span>
        ngModelCtrl = ngModelCtrl_;
        nullOption = nullOption_;
        unknownOption = unknownOption_;
      <span class="Identifier">}</span>;


      <span class="Statement">self</span>.addOption = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
        assertNotHasOwnProperty(value, <span class="Constant">'&quot;option value&quot;'</span>);
        optionsMap<span class="Identifier">[</span>value<span class="Identifier">]</span> = <span class="Constant">true</span>;

        <span class="Statement">if</span> (ngModelCtrl.$viewValue == value) <span class="Identifier">{</span>
          $element.val(value);
          <span class="Statement">if</span> (unknownOption.<span class="Statement">parent</span>()) unknownOption.remove();
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>;


      <span class="Statement">self</span>.removeOption = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
        <span class="Statement">if</span> (<span class="Identifier">this</span>.hasOption(value)) <span class="Identifier">{</span>
          <span class="Statement">delete</span> optionsMap<span class="Identifier">[</span>value<span class="Identifier">]</span>;
          <span class="Statement">if</span> (ngModelCtrl.$viewValue == value) <span class="Identifier">{</span>
            <span class="Identifier">this</span>.renderUnknownOption(value);
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>;


      <span class="Statement">self</span>.renderUnknownOption = <span class="Identifier">function</span>(val) <span class="Identifier">{</span>
        <span class="Identifier">var</span> unknownVal = <span class="Constant">'? '</span> + hashKey(val) + <span class="Constant">' ?'</span>;
        unknownOption.val(unknownVal);
        $element.prepend(unknownOption);
        $element.val(unknownVal);
        unknownOption.prop(<span class="Constant">'selected'</span>, <span class="Constant">true</span>); <span class="Comment">// needed for IE</span>
      <span class="Identifier">}</span>;


      <span class="Statement">self</span>.hasOption = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
        <span class="Statement">return</span> optionsMap.hasOwnProperty(value);
      <span class="Identifier">}</span>;

      $scope.$on(<span class="Constant">'$destroy'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
        <span class="Comment">// disable unknown option so that we don't do work when the whole select is being destroyed</span>
        <span class="Statement">self</span>.renderUnknownOption = noop;
      <span class="Identifier">}</span>);
    <span class="Identifier">}]</span>,

    link: <span class="Identifier">function</span>(scope, element, attr, ctrls) <span class="Identifier">{</span>
      <span class="Comment">// if ngModel is not defined, we don't need to do anything</span>
      <span class="Statement">if</span> (!ctrls<span class="Identifier">[</span>1<span class="Identifier">]</span>) <span class="Statement">return</span>;

      <span class="Identifier">var</span> selectCtrl = ctrls<span class="Identifier">[</span>0<span class="Identifier">]</span>,
          ngModelCtrl = ctrls<span class="Identifier">[</span>1<span class="Identifier">]</span>,
          multiple = attr.multiple,
          optionsExp = attr.ngOptions,
          nullOption = <span class="Constant">false</span>, <span class="Comment">// if false, user will not be able to select it (used by ngOptions)</span>
          emptyOption,
          <span class="Comment">// we can't just jqLite('&lt;option&gt;') since jqLite is not smart enough</span>
          <span class="Comment">// to create it in &lt;select&gt; and IE barfs otherwise.</span>
          optionTemplate = jqLite(<span class="Statement">document</span>.createElement(<span class="Constant">'option'</span>)),
          optGroupTemplate =jqLite(<span class="Statement">document</span>.createElement(<span class="Constant">'optgroup'</span>)),
          unknownOption = optionTemplate.clone();

      <span class="Comment">// find &quot;null&quot; option</span>
      <span class="Statement">for</span>(<span class="Identifier">var</span> i = 0, children = element.children(), ii = children.length; i &lt; ii; i++) <span class="Identifier">{</span>
        <span class="Statement">if</span> (children<span class="Identifier">[</span>i<span class="Identifier">]</span>.value === <span class="Constant">''</span>) <span class="Identifier">{</span>
          emptyOption = nullOption = children.eq(i);
          <span class="Statement">break</span>;
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>

      selectCtrl.init(ngModelCtrl, nullOption, unknownOption);

      <span class="Comment">// required validator</span>
      <span class="Statement">if</span> (multiple &amp;&amp; (attr.required || attr.ngRequired)) <span class="Identifier">{</span>
        <span class="Identifier">var</span> requiredValidator = <span class="Identifier">function</span>(value) <span class="Identifier">{</span>
          ngModelCtrl.$setValidity(<span class="Constant">'required'</span>, !attr.required || (value &amp;&amp; value.length));
          <span class="Statement">return</span> value;
        <span class="Identifier">}</span>;

        ngModelCtrl.$parsers.push(requiredValidator);
        ngModelCtrl.$formatters.unshift(requiredValidator);

        attr.$observe(<span class="Constant">'required'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
          requiredValidator(ngModelCtrl.$viewValue);
        <span class="Identifier">}</span>);
      <span class="Identifier">}</span>

      <span class="Statement">if</span> (optionsExp) setupAsOptions(scope, element, ngModelCtrl);
      <span class="Statement">else</span> <span class="Statement">if</span> (multiple) setupAsMultiple(scope, element, ngModelCtrl);
      <span class="Statement">else</span> setupAsSingle(scope, element, ngModelCtrl, selectCtrl);


      <span class="Comment">////////////////////////////</span>



      <span class="Identifier">function</span> setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) <span class="Identifier">{</span>
        ngModelCtrl.$render = <span class="Identifier">function</span>() <span class="Identifier">{</span>
          <span class="Identifier">var</span> viewValue = ngModelCtrl.$viewValue;

          <span class="Statement">if</span> (selectCtrl.hasOption(viewValue)) <span class="Identifier">{</span>
            <span class="Statement">if</span> (unknownOption.<span class="Statement">parent</span>()) unknownOption.remove();
            selectElement.val(viewValue);
            <span class="Statement">if</span> (viewValue === <span class="Constant">''</span>) emptyOption.prop(<span class="Constant">'selected'</span>, <span class="Constant">true</span>); <span class="Comment">// to make IE9 happy</span>
          <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
            <span class="Statement">if</span> (isUndefined(viewValue) &amp;&amp; emptyOption) <span class="Identifier">{</span>
              selectElement.val(<span class="Constant">''</span>);
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
              selectCtrl.renderUnknownOption(viewValue);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>;

        selectElement.on(<span class="Constant">'change'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
          scope.$apply(<span class="Identifier">function</span>() <span class="Identifier">{</span>
            <span class="Statement">if</span> (unknownOption.<span class="Statement">parent</span>()) unknownOption.remove();
            ngModelCtrl.$setViewValue(selectElement.val());
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>);
      <span class="Identifier">}</span>

      <span class="Identifier">function</span> setupAsMultiple(scope, selectElement, ctrl) <span class="Identifier">{</span>
        <span class="Identifier">var</span> lastView;
        ctrl.$render = <span class="Identifier">function</span>() <span class="Identifier">{</span>
          <span class="Identifier">var</span> items = <span class="Statement">new</span> HashMap(ctrl.$viewValue);
          forEach(selectElement.find(<span class="Constant">'option'</span>), <span class="Identifier">function</span>(option) <span class="Identifier">{</span>
            option.selected = isDefined(items.get(option.value));
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>;

        <span class="Comment">// we have to do it on each watch since ngModel watches reference, but</span>
        <span class="Comment">// we need to work of an array, so we need to see if anything was inserted/removed</span>
        scope.$watch(<span class="Identifier">function</span> selectMultipleWatch() <span class="Identifier">{</span>
          <span class="Statement">if</span> (!equals(lastView, ctrl.$viewValue)) <span class="Identifier">{</span>
            lastView = copy(ctrl.$viewValue);
            ctrl.$render();
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>);

        selectElement.on(<span class="Constant">'change'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
          scope.$apply(<span class="Identifier">function</span>() <span class="Identifier">{</span>
            <span class="Identifier">var</span> array = <span class="Identifier">[]</span>;
            forEach(selectElement.find(<span class="Constant">'option'</span>), <span class="Identifier">function</span>(option) <span class="Identifier">{</span>
              <span class="Statement">if</span> (option.selected) <span class="Identifier">{</span>
                array.push(option.value);
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>);
            ctrl.$setViewValue(array);
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>);
      <span class="Identifier">}</span>

      <span class="Identifier">function</span> setupAsOptions(scope, selectElement, ctrl) <span class="Identifier">{</span>
        <span class="Identifier">var</span> match;

        <span class="Statement">if</span> (! (match = optionsExp.match(NG_OPTIONS_REGEXP))) <span class="Identifier">{</span>
          <span class="Statement">throw</span> ngOptionsMinErr(<span class="Constant">'iexp'</span>,
            <span class="Constant">&quot;Expected expression in form of &quot;</span> +
            <span class="Constant">&quot;'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'&quot;</span> +
            <span class="Constant">&quot; but got '{0}'. Element: {1}&quot;</span>,
            optionsExp, startingTag(selectElement));
        <span class="Identifier">}</span>

        <span class="Identifier">var</span> displayFn = $parse(match<span class="Identifier">[</span>2<span class="Identifier">]</span> || match<span class="Identifier">[</span>1<span class="Identifier">]</span>),
            valueName = match<span class="Identifier">[</span>4<span class="Identifier">]</span> || match<span class="Identifier">[</span>6<span class="Identifier">]</span>,
            keyName = match<span class="Identifier">[</span>5<span class="Identifier">]</span>,
            groupByFn = $parse(match<span class="Identifier">[</span>3<span class="Identifier">]</span> || <span class="Constant">''</span>),
            valueFn = $parse(match<span class="Identifier">[</span>2<span class="Identifier">]</span> ? match<span class="Identifier">[</span>1<span class="Identifier">]</span> : valueName),
            valuesFn = $parse(match<span class="Identifier">[</span>7<span class="Identifier">]</span>),
            track = match<span class="Identifier">[</span>8<span class="Identifier">]</span>,
            trackFn = track ? $parse(match<span class="Identifier">[</span>8<span class="Identifier">]</span>) : <span class="Statement">null</span>,
            <span class="Comment">// This is an array of array of existing option groups in DOM.</span>
            <span class="Comment">// We try to reuse these if possible</span>
            <span class="Comment">// - optionGroupsCache[0] is the options with no option group</span>
            <span class="Comment">// - optionGroupsCache[?][0] is the parent: either the SELECT or OPTGROUP element</span>
            optionGroupsCache = <span class="Identifier">[[{</span>element: selectElement, label:<span class="Constant">''</span><span class="Identifier">}]]</span>;

        <span class="Statement">if</span> (nullOption) <span class="Identifier">{</span>
          <span class="Comment">// compile the element since there might be bindings in it</span>
          $compile(nullOption)(scope);

          <span class="Comment">// remove the class, which is added automatically because we recompile the element and it</span>
          <span class="Comment">// becomes the compilation root</span>
          nullOption.removeClass(<span class="Constant">'ng-scope'</span>);

          <span class="Comment">// we need to remove it before calling selectElement.html('') because otherwise IE will</span>
          <span class="Comment">// remove the label from the element. wtf?</span>
          nullOption.remove();
        <span class="Identifier">}</span>

        <span class="Comment">// clear contents, we'll add what's needed based on the model</span>
        selectElement.html(<span class="Constant">''</span>);

        selectElement.on(<span class="Constant">'change'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
          scope.$apply(<span class="Identifier">function</span>() <span class="Identifier">{</span>
            <span class="Identifier">var</span> optionGroup,
                collection = valuesFn(scope) || <span class="Identifier">[]</span>,
                locals = <span class="Identifier">{}</span>,
                key, value, optionElement, index, groupIndex, length, groupLength, trackIndex;

            <span class="Statement">if</span> (multiple) <span class="Identifier">{</span>
              value = <span class="Identifier">[]</span>;
              <span class="Statement">for</span> (groupIndex = 0, groupLength = optionGroupsCache.length;
                   groupIndex &lt; groupLength;
                   groupIndex++) <span class="Identifier">{</span>
                <span class="Comment">// list of options for that group. (first item has the parent)</span>
                optionGroup = optionGroupsCache<span class="Identifier">[</span>groupIndex<span class="Identifier">]</span>;

                <span class="Statement">for</span>(index = 1, length = optionGroup.length; index &lt; length; index++) <span class="Identifier">{</span>
                  <span class="Statement">if</span> ((optionElement = optionGroup<span class="Identifier">[</span>index<span class="Identifier">]</span>.element)<span class="Identifier">[</span>0<span class="Identifier">]</span>.selected) <span class="Identifier">{</span>
                    key = optionElement.val();
                    <span class="Statement">if</span> (keyName) locals<span class="Identifier">[</span>keyName<span class="Identifier">]</span> = key;
                    <span class="Statement">if</span> (trackFn) <span class="Identifier">{</span>
                      <span class="Statement">for</span> (trackIndex = 0; trackIndex &lt; collection.length; trackIndex++) <span class="Identifier">{</span>
                        locals<span class="Identifier">[</span>valueName<span class="Identifier">]</span> = collection<span class="Identifier">[</span>trackIndex<span class="Identifier">]</span>;
                        <span class="Statement">if</span> (trackFn(scope, locals) == key) <span class="Statement">break</span>;
                      <span class="Identifier">}</span>
                    <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
                      locals<span class="Identifier">[</span>valueName<span class="Identifier">]</span> = collection<span class="Identifier">[</span>key<span class="Identifier">]</span>;
                    <span class="Identifier">}</span>
                    value.push(valueFn(scope, locals));
                  <span class="Identifier">}</span>
                <span class="Identifier">}</span>
              <span class="Identifier">}</span>
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
              key = selectElement.val();
              <span class="Statement">if</span> (key == <span class="Constant">'?'</span>) <span class="Identifier">{</span>
                value = <span class="Statement">undefined</span>;
              <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (key === <span class="Constant">''</span>)<span class="Identifier">{</span>
                value = <span class="Statement">null</span>;
              <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
                <span class="Statement">if</span> (trackFn) <span class="Identifier">{</span>
                  <span class="Statement">for</span> (trackIndex = 0; trackIndex &lt; collection.length; trackIndex++) <span class="Identifier">{</span>
                    locals<span class="Identifier">[</span>valueName<span class="Identifier">]</span> = collection<span class="Identifier">[</span>trackIndex<span class="Identifier">]</span>;
                    <span class="Statement">if</span> (trackFn(scope, locals) == key) <span class="Identifier">{</span>
                      value = valueFn(scope, locals);
                      <span class="Statement">break</span>;
                    <span class="Identifier">}</span>
                  <span class="Identifier">}</span>
                <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
                  locals<span class="Identifier">[</span>valueName<span class="Identifier">]</span> = collection<span class="Identifier">[</span>key<span class="Identifier">]</span>;
                  <span class="Statement">if</span> (keyName) locals<span class="Identifier">[</span>keyName<span class="Identifier">]</span> = key;
                  value = valueFn(scope, locals);
                <span class="Identifier">}</span>
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>
            ctrl.$setViewValue(value);
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span>);

        ctrl.$render = render;

        <span class="Comment">// </span><span class="Todo">TODO</span><span class="Comment">(vojta): can't we optimize this ?</span>
        scope.$watch(render);

        <span class="Identifier">function</span> render() <span class="Identifier">{</span>
              <span class="Comment">// Temporary location for the option groups before we render them</span>
          <span class="Identifier">var</span> optionGroups = <span class="Identifier">{</span><span class="Constant">''</span>:<span class="Identifier">[]}</span>,
              optionGroupNames = <span class="Identifier">[</span><span class="Constant">''</span><span class="Identifier">]</span>,
              optionGroupName,
              optionGroup,
              option,
              existingParent, existingOptions, existingOption,
              modelValue = ctrl.$modelValue,
              values = valuesFn(scope) || <span class="Identifier">[]</span>,
              keys = keyName ? sortedKeys(values) : values,
              key,
              groupLength, length,
              groupIndex, index,
              locals = <span class="Identifier">{}</span>,
              selected,
              selectedSet = <span class="Constant">false</span>, <span class="Comment">// nothing is selected yet</span>
              lastElement,
              element,
              label;

          <span class="Statement">if</span> (multiple) <span class="Identifier">{</span>
            <span class="Statement">if</span> (trackFn &amp;&amp; isArray(modelValue)) <span class="Identifier">{</span>
              selectedSet = <span class="Statement">new</span> HashMap(<span class="Identifier">[]</span>);
              <span class="Statement">for</span> (<span class="Identifier">var</span> trackIndex = 0; trackIndex &lt; modelValue.length; trackIndex++) <span class="Identifier">{</span>
                locals<span class="Identifier">[</span>valueName<span class="Identifier">]</span> = modelValue<span class="Identifier">[</span>trackIndex<span class="Identifier">]</span>;
                selectedSet.put(trackFn(scope, locals), modelValue<span class="Identifier">[</span>trackIndex<span class="Identifier">]</span>);
              <span class="Identifier">}</span>
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
              selectedSet = <span class="Statement">new</span> HashMap(modelValue);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>

          <span class="Comment">// We now build up the list of options we need (we merge later)</span>
          <span class="Statement">for</span> (index = 0; length = keys.length, index &lt; length; index++) <span class="Identifier">{</span>

            key = index;
            <span class="Statement">if</span> (keyName) <span class="Identifier">{</span>
              key = keys<span class="Identifier">[</span>index<span class="Identifier">]</span>;
              <span class="Statement">if</span> ( key.charAt(0) === <span class="Constant">'$'</span> ) <span class="Statement">continue</span>;
              locals<span class="Identifier">[</span>keyName<span class="Identifier">]</span> = key;
            <span class="Identifier">}</span>

            locals<span class="Identifier">[</span>valueName<span class="Identifier">]</span> = values<span class="Identifier">[</span>key<span class="Identifier">]</span>;

            optionGroupName = groupByFn(scope, locals) || <span class="Constant">''</span>;
            <span class="Statement">if</span> (!(optionGroup = optionGroups<span class="Identifier">[</span>optionGroupName<span class="Identifier">]</span>)) <span class="Identifier">{</span>
              optionGroup = optionGroups<span class="Identifier">[</span>optionGroupName<span class="Identifier">]</span> = <span class="Identifier">[]</span>;
              optionGroupNames.push(optionGroupName);
            <span class="Identifier">}</span>
            <span class="Statement">if</span> (multiple) <span class="Identifier">{</span>
              selected = isDefined(
                selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals))
              );
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
              <span class="Statement">if</span> (trackFn) <span class="Identifier">{</span>
                <span class="Identifier">var</span> modelCast = <span class="Identifier">{}</span>;
                modelCast<span class="Identifier">[</span>valueName<span class="Identifier">]</span> = modelValue;
                selected = trackFn(scope, modelCast) === trackFn(scope, locals);
              <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
                selected = modelValue === valueFn(scope, locals);
              <span class="Identifier">}</span>
              selectedSet = selectedSet || selected; <span class="Comment">// see if at least one item is selected</span>
            <span class="Identifier">}</span>
            label = displayFn(scope, locals); <span class="Comment">// what will be seen by the user</span>

            <span class="Comment">// doing displayFn(scope, locals) || '' overwrites zero values</span>
            label = isDefined(label) ? label : <span class="Constant">''</span>;
            optionGroup.push(<span class="Identifier">{</span>
              <span class="Comment">// either the index into array or key from object</span>
              id: trackFn ? trackFn(scope, locals) : (keyName ? keys<span class="Identifier">[</span>index<span class="Identifier">]</span> : index),
              label: label,
              selected: selected                   <span class="Comment">// determine if we should be selected</span>
            <span class="Identifier">}</span>);
          <span class="Identifier">}</span>
          <span class="Statement">if</span> (!multiple) <span class="Identifier">{</span>
            <span class="Statement">if</span> (nullOption || modelValue === <span class="Statement">null</span>) <span class="Identifier">{</span>
              <span class="Comment">// insert null option if we have a placeholder, or the model is null</span>
              optionGroups<span class="Identifier">[</span><span class="Constant">''</span><span class="Identifier">]</span>.unshift(<span class="Identifier">{</span>id:<span class="Constant">''</span>, label:<span class="Constant">''</span>, selected:!selectedSet<span class="Identifier">}</span>);
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Statement">if</span> (!selectedSet) <span class="Identifier">{</span>
              <span class="Comment">// option could not be found, we have to insert the undefined item</span>
              optionGroups<span class="Identifier">[</span><span class="Constant">''</span><span class="Identifier">]</span>.unshift(<span class="Identifier">{</span>id:<span class="Constant">'?'</span>, label:<span class="Constant">''</span>, selected:<span class="Constant">true</span><span class="Identifier">}</span>);
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>

          <span class="Comment">// Now we need to update the list of DOM nodes to match the optionGroups we computed above</span>
          <span class="Statement">for</span> (groupIndex = 0, groupLength = optionGroupNames.length;
               groupIndex &lt; groupLength;
               groupIndex++) <span class="Identifier">{</span>
            <span class="Comment">// current option group name or '' if no group</span>
            optionGroupName = optionGroupNames<span class="Identifier">[</span>groupIndex<span class="Identifier">]</span>;

            <span class="Comment">// list of options for that group. (first item has the parent)</span>
            optionGroup = optionGroups<span class="Identifier">[</span>optionGroupName<span class="Identifier">]</span>;

            <span class="Statement">if</span> (optionGroupsCache.length &lt;= groupIndex) <span class="Identifier">{</span>
              <span class="Comment">// we need to grow the optionGroups</span>
              existingParent = <span class="Identifier">{</span>
                element: optGroupTemplate.clone().attr(<span class="Constant">'label'</span>, optionGroupName),
                label: optionGroup.label
              <span class="Identifier">}</span>;
              existingOptions = <span class="Identifier">[</span>existingParent<span class="Identifier">]</span>;
              optionGroupsCache.push(existingOptions);
              selectElement.append(existingParent.element);
            <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
              existingOptions = optionGroupsCache<span class="Identifier">[</span>groupIndex<span class="Identifier">]</span>;
              existingParent = existingOptions<span class="Identifier">[</span>0<span class="Identifier">]</span>;  <span class="Comment">// either SELECT (no group) or OPTGROUP element</span>

              <span class="Comment">// update the OPTGROUP label if not the same.</span>
              <span class="Statement">if</span> (existingParent.label != optionGroupName) <span class="Identifier">{</span>
                existingParent.element.attr(<span class="Constant">'label'</span>, existingParent.label = optionGroupName);
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>

            lastElement = <span class="Statement">null</span>;  <span class="Comment">// start at the beginning</span>
            <span class="Statement">for</span>(index = 0, length = optionGroup.length; index &lt; length; index++) <span class="Identifier">{</span>
              option = optionGroup<span class="Identifier">[</span>index<span class="Identifier">]</span>;
              <span class="Statement">if</span> ((existingOption = existingOptions<span class="Identifier">[</span>index+1<span class="Identifier">]</span>)) <span class="Identifier">{</span>
                <span class="Comment">// reuse elements</span>
                lastElement = existingOption.element;
                <span class="Statement">if</span> (existingOption.label !== option.label) <span class="Identifier">{</span>
                  lastElement.text(existingOption.label = option.label);
                <span class="Identifier">}</span>
                <span class="Statement">if</span> (existingOption.id !== option.id) <span class="Identifier">{</span>
                  lastElement.val(existingOption.id = option.id);
                <span class="Identifier">}</span>
                <span class="Comment">// lastElement.prop('selected') provided by jQuery has side-effects</span>
                <span class="Statement">if</span> (lastElement<span class="Identifier">[</span>0<span class="Identifier">]</span>.selected !== option.selected) <span class="Identifier">{</span>
                  lastElement.prop(<span class="Constant">'selected'</span>, (existingOption.selected = option.selected));
                <span class="Identifier">}</span>
              <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
                <span class="Comment">// grow elements</span>

                <span class="Comment">// if it's a null option</span>
                <span class="Statement">if</span> (option.id === <span class="Constant">''</span> &amp;&amp; nullOption) <span class="Identifier">{</span>
                  <span class="Comment">// put back the pre-compiled element</span>
                  element = nullOption;
                <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
                  <span class="Comment">// jQuery(v1.4.2) Bug: We should be able to chain the method calls, but</span>
                  <span class="Comment">// in this version of jQuery on some browser the .text() returns a string</span>
                  <span class="Comment">// rather then the element.</span>
                  (element = optionTemplate.clone())
                      .val(option.id)
                      .attr(<span class="Constant">'selected'</span>, option.selected)
                      .text(option.label);
                <span class="Identifier">}</span>

                existingOptions.push(existingOption = <span class="Identifier">{</span>
                    element: element,
                    label: option.label,
                    id: option.id,
                    selected: option.selected
                <span class="Identifier">}</span>);
                <span class="Statement">if</span> (lastElement) <span class="Identifier">{</span>
                  lastElement.after(element);
                <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
                  existingParent.element.append(element);
                <span class="Identifier">}</span>
                lastElement = element;
              <span class="Identifier">}</span>
            <span class="Identifier">}</span>
            <span class="Comment">// remove any excessive OPTIONs in a group</span>
            index++; <span class="Comment">// increment since the existingOptions[0] is parent element not OPTION</span>
            <span class="Statement">while</span>(existingOptions.length &gt; index) <span class="Identifier">{</span>
              existingOptions.pop().element.remove();
            <span class="Identifier">}</span>
          <span class="Identifier">}</span>
          <span class="Comment">// remove any excessive OPTGROUPs from select</span>
          <span class="Statement">while</span>(optionGroupsCache.length &gt; groupIndex) <span class="Identifier">{</span>
            optionGroupsCache.pop()<span class="Identifier">[</span>0<span class="Identifier">]</span>.element.remove();
          <span class="Identifier">}</span>
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}]</span>;

<span class="Identifier">var</span> optionDirective = <span class="Identifier">[</span><span class="Constant">'$interpolate'</span>, <span class="Identifier">function</span>($interpolate) <span class="Identifier">{</span>
  <span class="Identifier">var</span> nullSelectCtrl = <span class="Identifier">{</span>
    addOption: noop,
    removeOption: noop
  <span class="Identifier">}</span>;

  <span class="Statement">return</span> <span class="Identifier">{</span>
    restrict: <span class="Constant">'E'</span>,
    priority: 100,
    compile: <span class="Identifier">function</span>(element, attr) <span class="Identifier">{</span>
      <span class="Statement">if</span> (isUndefined(attr.value)) <span class="Identifier">{</span>
        <span class="Identifier">var</span> interpolateFn = $interpolate(element.text(), <span class="Constant">true</span>);
        <span class="Statement">if</span> (!interpolateFn) <span class="Identifier">{</span>
          attr.$set(<span class="Constant">'value'</span>, element.text());
        <span class="Identifier">}</span>
      <span class="Identifier">}</span>

      <span class="Statement">return</span> <span class="Identifier">function</span> (scope, element, attr) <span class="Identifier">{</span>
        <span class="Identifier">var</span> selectCtrlName = <span class="Constant">'$selectController'</span>,
            <span class="Statement">parent</span> = element.<span class="Statement">parent</span>(),
            selectCtrl = <span class="Statement">parent</span>.data(selectCtrlName) ||
              <span class="Statement">parent</span>.<span class="Statement">parent</span>().data(selectCtrlName); <span class="Comment">// in case we are in optgroup</span>

        <span class="Statement">if</span> (selectCtrl &amp;&amp; selectCtrl.databound) <span class="Identifier">{</span>
          <span class="Comment">// For some reason Opera defaults to true and if not overridden this messes up the repeater.</span>
          <span class="Comment">// We don't want the view to drive the initialization of the model anyway.</span>
          element.prop(<span class="Constant">'selected'</span>, <span class="Constant">false</span>);
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          selectCtrl = nullSelectCtrl;
        <span class="Identifier">}</span>

        <span class="Statement">if</span> (interpolateFn) <span class="Identifier">{</span>
          scope.$watch(interpolateFn, <span class="Identifier">function</span> interpolateWatchAction(newVal, oldVal) <span class="Identifier">{</span>
            attr.$set(<span class="Constant">'value'</span>, newVal);
            <span class="Statement">if</span> (newVal !== oldVal) selectCtrl.removeOption(oldVal);
            selectCtrl.addOption(newVal);
          <span class="Identifier">}</span>);
        <span class="Identifier">}</span> <span class="Statement">else</span> <span class="Identifier">{</span>
          selectCtrl.addOption(attr.value);
        <span class="Identifier">}</span>

        element.on(<span class="Constant">'$destroy'</span>, <span class="Identifier">function</span>() <span class="Identifier">{</span>
          selectCtrl.removeOption(attr.value);
        <span class="Identifier">}</span>);
      <span class="Identifier">}</span>;
    <span class="Identifier">}</span>
  <span class="Identifier">}</span>;
<span class="Identifier">}]</span>;

<span class="Identifier">var</span> styleDirective = valueFn(<span class="Identifier">{</span>
  restrict: <span class="Constant">'E'</span>,
  terminal: <span class="Constant">true</span>
<span class="Identifier">}</span>);

  <span class="Comment">//try to bind to jquery now so that one can write angular.element().read()</span>
  <span class="Comment">//but we will rebind on bootstrap again.</span>
  bindJQuery();

  publishExternalAPI(angular);

  jqLite(<span class="Statement">document</span>).ready(<span class="Identifier">function</span>() <span class="Identifier">{</span>
    angularInit(<span class="Statement">document</span>, bootstrap);
  <span class="Identifier">}</span>);

<span class="Identifier">}</span>)(<span class="Statement">window</span>, <span class="Statement">document</span>);

!angular.$$csp() &amp;&amp; angular.element(<span class="Statement">document</span>).find(<span class="Constant">'head'</span>).prepend(<span class="Constant">'&lt;style type=&quot;text/css&quot;&gt;@charset &quot;UTF-8&quot;;[ng</span><span class="Special">\\</span><span class="Constant">:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng</span><span class="Special">\\</span><span class="Constant">:form{display:block;}.ng-animate-start{border-spacing:1px 1px;-ms-zoom:1.0001;}.ng-animate-active{border-spacing:0px 0px;-ms-zoom:1;}&lt;/style&gt;'</span>);
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
